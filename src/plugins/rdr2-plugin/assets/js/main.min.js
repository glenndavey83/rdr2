(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, 
    global.Swiper = factory());
})(this, function() {
    "use strict";
    var doc = typeof document === "undefined" ? {
        body: {},
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        activeElement: {
            blur: function blur() {},
            nodeName: ""
        },
        querySelector: function querySelector() {
            return null;
        },
        querySelectorAll: function querySelectorAll() {
            return [];
        },
        getElementById: function getElementById() {
            return null;
        },
        createEvent: function createEvent() {
            return {
                initEvent: function initEvent() {}
            };
        },
        createElement: function createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function setAttribute() {},
                getElementsByTagName: function getElementsByTagName() {
                    return [];
                }
            };
        },
        location: {
            hash: ""
        }
    } : document;
    var win = typeof window === "undefined" ? {
        document: doc,
        navigator: {
            userAgent: ""
        },
        location: {},
        history: {},
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        getComputedStyle: function getComputedStyle() {
            return {
                getPropertyValue: function getPropertyValue() {
                    return "";
                }
            };
        },
        Image: function Image() {},
        Date: function Date() {},
        screen: {},
        setTimeout: function setTimeout() {},
        clearTimeout: function clearTimeout() {}
    } : window;
    var Dom7 = function Dom7(arr) {
        var self = this;
        for (var i = 0; i < arr.length; i += 1) {
            self[i] = arr[i];
        }
        self.length = arr.length;
        return this;
    };
    function $(selector, context) {
        var arr = [];
        var i = 0;
        if (selector && !context) {
            if (selector instanceof Dom7) {
                return selector;
            }
        }
        if (selector) {
            if (typeof selector === "string") {
                var els;
                var tempParent;
                var html = selector.trim();
                if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
                    var toCreate = "div";
                    if (html.indexOf("<li") === 0) {
                        toCreate = "ul";
                    }
                    if (html.indexOf("<tr") === 0) {
                        toCreate = "tbody";
                    }
                    if (html.indexOf("<td") === 0 || html.indexOf("<th") === 0) {
                        toCreate = "tr";
                    }
                    if (html.indexOf("<tbody") === 0) {
                        toCreate = "table";
                    }
                    if (html.indexOf("<option") === 0) {
                        toCreate = "select";
                    }
                    tempParent = doc.createElement(toCreate);
                    tempParent.innerHTML = html;
                    for (i = 0; i < tempParent.childNodes.length; i += 1) {
                        arr.push(tempParent.childNodes[i]);
                    }
                } else {
                    if (!context && selector[0] === "#" && !selector.match(/[ .<>:~]/)) {
                        els = [ doc.getElementById(selector.trim().split("#")[1]) ];
                    } else {
                        els = (context || doc).querySelectorAll(selector.trim());
                    }
                    for (i = 0; i < els.length; i += 1) {
                        if (els[i]) {
                            arr.push(els[i]);
                        }
                    }
                }
            } else if (selector.nodeType || selector === win || selector === doc) {
                arr.push(selector);
            } else if (selector.length > 0 && selector[0].nodeType) {
                for (i = 0; i < selector.length; i += 1) {
                    arr.push(selector[i]);
                }
            }
        }
        return new Dom7(arr);
    }
    $.fn = Dom7.prototype;
    $.Class = Dom7;
    $.Dom7 = Dom7;
    function unique(arr) {
        var uniqueArray = [];
        for (var i = 0; i < arr.length; i += 1) {
            if (uniqueArray.indexOf(arr[i]) === -1) {
                uniqueArray.push(arr[i]);
            }
        }
        return uniqueArray;
    }
    function addClass(className) {
        if (typeof className === "undefined") {
            return this;
        }
        var classes = className.split(" ");
        for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
                if (typeof this[j] !== "undefined" && typeof this[j].classList !== "undefined") {
                    this[j].classList.add(classes[i]);
                }
            }
        }
        return this;
    }
    function removeClass(className) {
        var classes = className.split(" ");
        for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
                if (typeof this[j] !== "undefined" && typeof this[j].classList !== "undefined") {
                    this[j].classList.remove(classes[i]);
                }
            }
        }
        return this;
    }
    function hasClass(className) {
        if (!this[0]) {
            return false;
        }
        return this[0].classList.contains(className);
    }
    function toggleClass(className) {
        var classes = className.split(" ");
        for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
                if (typeof this[j] !== "undefined" && typeof this[j].classList !== "undefined") {
                    this[j].classList.toggle(classes[i]);
                }
            }
        }
        return this;
    }
    function attr(attrs, value) {
        var arguments$1 = arguments;
        if (arguments.length === 1 && typeof attrs === "string") {
            if (this[0]) {
                return this[0].getAttribute(attrs);
            }
            return undefined;
        }
        for (var i = 0; i < this.length; i += 1) {
            if (arguments$1.length === 2) {
                this[i].setAttribute(attrs, value);
            } else {
                for (var attrName in attrs) {
                    this[i][attrName] = attrs[attrName];
                    this[i].setAttribute(attrName, attrs[attrName]);
                }
            }
        }
        return this;
    }
    function removeAttr(attr) {
        for (var i = 0; i < this.length; i += 1) {
            this[i].removeAttribute(attr);
        }
        return this;
    }
    function data(key, value) {
        var el;
        if (typeof value === "undefined") {
            el = this[0];
            if (el) {
                if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
                    return el.dom7ElementDataStorage[key];
                }
                var dataKey = el.getAttribute("data-" + key);
                if (dataKey) {
                    return dataKey;
                }
                return undefined;
            }
            return undefined;
        }
        for (var i = 0; i < this.length; i += 1) {
            el = this[i];
            if (!el.dom7ElementDataStorage) {
                el.dom7ElementDataStorage = {};
            }
            el.dom7ElementDataStorage[key] = value;
        }
        return this;
    }
    function transform(transform) {
        for (var i = 0; i < this.length; i += 1) {
            var elStyle = this[i].style;
            elStyle.webkitTransform = transform;
            elStyle.transform = transform;
        }
        return this;
    }
    function transition(duration) {
        if (typeof duration !== "string") {
            duration = duration + "ms";
        }
        for (var i = 0; i < this.length; i += 1) {
            var elStyle = this[i].style;
            elStyle.webkitTransitionDuration = duration;
            elStyle.transitionDuration = duration;
        }
        return this;
    }
    function on() {
        var assign;
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var eventType = args[0];
        var targetSelector = args[1];
        var listener = args[2];
        var capture = args[3];
        if (typeof args[1] === "function") {
            assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
            targetSelector = undefined;
        }
        if (!capture) {
            capture = false;
        }
        function handleLiveEvent(e) {
            var target = e.target;
            if (!target) {
                return;
            }
            var eventData = e.target.dom7EventData || [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            if ($(target).is(targetSelector)) {
                listener.apply(target, eventData);
            } else {
                var parents = $(target).parents();
                for (var k = 0; k < parents.length; k += 1) {
                    if ($(parents[k]).is(targetSelector)) {
                        listener.apply(parents[k], eventData);
                    }
                }
            }
        }
        function handleEvent(e) {
            var eventData = e && e.target ? e.target.dom7EventData || [] : [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            listener.apply(this, eventData);
        }
        var events = eventType.split(" ");
        var j;
        for (var i = 0; i < this.length; i += 1) {
            var el = this[i];
            if (!targetSelector) {
                for (j = 0; j < events.length; j += 1) {
                    var event = events[j];
                    if (!el.dom7Listeners) {
                        el.dom7Listeners = {};
                    }
                    if (!el.dom7Listeners[event]) {
                        el.dom7Listeners[event] = [];
                    }
                    el.dom7Listeners[event].push({
                        listener: listener,
                        proxyListener: handleEvent
                    });
                    el.addEventListener(event, handleEvent, capture);
                }
            } else {
                for (j = 0; j < events.length; j += 1) {
                    var event$1 = events[j];
                    if (!el.dom7LiveListeners) {
                        el.dom7LiveListeners = {};
                    }
                    if (!el.dom7LiveListeners[event$1]) {
                        el.dom7LiveListeners[event$1] = [];
                    }
                    el.dom7LiveListeners[event$1].push({
                        listener: listener,
                        proxyListener: handleLiveEvent
                    });
                    el.addEventListener(event$1, handleLiveEvent, capture);
                }
            }
        }
        return this;
    }
    function off() {
        var assign;
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var eventType = args[0];
        var targetSelector = args[1];
        var listener = args[2];
        var capture = args[3];
        if (typeof args[1] === "function") {
            assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
            targetSelector = undefined;
        }
        if (!capture) {
            capture = false;
        }
        var events = eventType.split(" ");
        for (var i = 0; i < events.length; i += 1) {
            var event = events[i];
            for (var j = 0; j < this.length; j += 1) {
                var el = this[j];
                var handlers = void 0;
                if (!targetSelector && el.dom7Listeners) {
                    handlers = el.dom7Listeners[event];
                } else if (targetSelector && el.dom7LiveListeners) {
                    handlers = el.dom7LiveListeners[event];
                }
                if (handlers && handlers.length) {
                    for (var k = handlers.length - 1; k >= 0; k -= 1) {
                        var handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
        }
        return this;
    }
    function trigger() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var events = args[0].split(" ");
        var eventData = args[1];
        for (var i = 0; i < events.length; i += 1) {
            var event = events[i];
            for (var j = 0; j < this.length; j += 1) {
                var el = this[j];
                var evt = void 0;
                try {
                    evt = new win.CustomEvent(event, {
                        detail: eventData,
                        bubbles: true,
                        cancelable: true
                    });
                } catch (e) {
                    evt = doc.createEvent("Event");
                    evt.initEvent(event, true, true);
                    evt.detail = eventData;
                }
                el.dom7EventData = args.filter(function(data, dataIndex) {
                    return dataIndex > 0;
                });
                el.dispatchEvent(evt);
                el.dom7EventData = [];
                delete el.dom7EventData;
            }
        }
        return this;
    }
    function transitionEnd(callback) {
        var events = [ "webkitTransitionEnd", "transitionend" ];
        var dom = this;
        var i;
        function fireCallBack(e) {
            if (e.target !== this) {
                return;
            }
            callback.call(this, e);
            for (i = 0; i < events.length; i += 1) {
                dom.off(events[i], fireCallBack);
            }
        }
        if (callback) {
            for (i = 0; i < events.length; i += 1) {
                dom.on(events[i], fireCallBack);
            }
        }
        return this;
    }
    function outerWidth(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                var styles = this.styles();
                return this[0].offsetWidth + parseFloat(styles.getPropertyValue("margin-right")) + parseFloat(styles.getPropertyValue("margin-left"));
            }
            return this[0].offsetWidth;
        }
        return null;
    }
    function outerHeight(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                var styles = this.styles();
                return this[0].offsetHeight + parseFloat(styles.getPropertyValue("margin-top")) + parseFloat(styles.getPropertyValue("margin-bottom"));
            }
            return this[0].offsetHeight;
        }
        return null;
    }
    function offset() {
        if (this.length > 0) {
            var el = this[0];
            var box = el.getBoundingClientRect();
            var body = doc.body;
            var clientTop = el.clientTop || body.clientTop || 0;
            var clientLeft = el.clientLeft || body.clientLeft || 0;
            var scrollTop = el === win ? win.scrollY : el.scrollTop;
            var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
            return {
                top: box.top + scrollTop - clientTop,
                left: box.left + scrollLeft - clientLeft
            };
        }
        return null;
    }
    function styles() {
        if (this[0]) {
            return win.getComputedStyle(this[0], null);
        }
        return {};
    }
    function css(props, value) {
        var i;
        if (arguments.length === 1) {
            if (typeof props === "string") {
                if (this[0]) {
                    return win.getComputedStyle(this[0], null).getPropertyValue(props);
                }
            } else {
                for (i = 0; i < this.length; i += 1) {
                    for (var prop in props) {
                        this[i].style[prop] = props[prop];
                    }
                }
                return this;
            }
        }
        if (arguments.length === 2 && typeof props === "string") {
            for (i = 0; i < this.length; i += 1) {
                this[i].style[props] = value;
            }
            return this;
        }
        return this;
    }
    function each(callback) {
        if (!callback) {
            return this;
        }
        for (var i = 0; i < this.length; i += 1) {
            if (callback.call(this[i], i, this[i]) === false) {
                return this;
            }
        }
        return this;
    }
    function html(html) {
        if (typeof html === "undefined") {
            return this[0] ? this[0].innerHTML : undefined;
        }
        for (var i = 0; i < this.length; i += 1) {
            this[i].innerHTML = html;
        }
        return this;
    }
    function text(text) {
        if (typeof text === "undefined") {
            if (this[0]) {
                return this[0].textContent.trim();
            }
            return null;
        }
        for (var i = 0; i < this.length; i += 1) {
            this[i].textContent = text;
        }
        return this;
    }
    function is(selector) {
        var el = this[0];
        var compareWith;
        var i;
        if (!el || typeof selector === "undefined") {
            return false;
        }
        if (typeof selector === "string") {
            if (el.matches) {
                return el.matches(selector);
            } else if (el.webkitMatchesSelector) {
                return el.webkitMatchesSelector(selector);
            } else if (el.msMatchesSelector) {
                return el.msMatchesSelector(selector);
            }
            compareWith = $(selector);
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) {
                    return true;
                }
            }
            return false;
        } else if (selector === doc) {
            return el === doc;
        } else if (selector === win) {
            return el === win;
        }
        if (selector.nodeType || selector instanceof Dom7) {
            compareWith = selector.nodeType ? [ selector ] : selector;
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }
    function index() {
        var child = this[0];
        var i;
        if (child) {
            i = 0;
            while ((child = child.previousSibling) !== null) {
                if (child.nodeType === 1) {
                    i += 1;
                }
            }
            return i;
        }
        return undefined;
    }
    function eq(index) {
        if (typeof index === "undefined") {
            return this;
        }
        var length = this.length;
        var returnIndex;
        if (index > length - 1) {
            return new Dom7([]);
        }
        if (index < 0) {
            returnIndex = length + index;
            if (returnIndex < 0) {
                return new Dom7([]);
            }
            return new Dom7([ this[returnIndex] ]);
        }
        return new Dom7([ this[index] ]);
    }
    function append() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var newChild;
        for (var k = 0; k < args.length; k += 1) {
            newChild = args[k];
            for (var i = 0; i < this.length; i += 1) {
                if (typeof newChild === "string") {
                    var tempDiv = doc.createElement("div");
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) {
                        this[i].appendChild(tempDiv.firstChild);
                    }
                } else if (newChild instanceof Dom7) {
                    for (var j = 0; j < newChild.length; j += 1) {
                        this[i].appendChild(newChild[j]);
                    }
                } else {
                    this[i].appendChild(newChild);
                }
            }
        }
        return this;
    }
    function prepend(newChild) {
        var i;
        var j;
        for (i = 0; i < this.length; i += 1) {
            if (typeof newChild === "string") {
                var tempDiv = doc.createElement("div");
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
                    this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                }
            } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j += 1) {
                    this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                }
            } else {
                this[i].insertBefore(newChild, this[i].childNodes[0]);
            }
        }
        return this;
    }
    function next(selector) {
        if (this.length > 0) {
            if (selector) {
                if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                    return new Dom7([ this[0].nextElementSibling ]);
                }
                return new Dom7([]);
            }
            if (this[0].nextElementSibling) {
                return new Dom7([ this[0].nextElementSibling ]);
            }
            return new Dom7([]);
        }
        return new Dom7([]);
    }
    function nextAll(selector) {
        var nextEls = [];
        var el = this[0];
        if (!el) {
            return new Dom7([]);
        }
        while (el.nextElementSibling) {
            var next = el.nextElementSibling;
            if (selector) {
                if ($(next).is(selector)) {
                    nextEls.push(next);
                }
            } else {
                nextEls.push(next);
            }
            el = next;
        }
        return new Dom7(nextEls);
    }
    function prev(selector) {
        if (this.length > 0) {
            var el = this[0];
            if (selector) {
                if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                    return new Dom7([ el.previousElementSibling ]);
                }
                return new Dom7([]);
            }
            if (el.previousElementSibling) {
                return new Dom7([ el.previousElementSibling ]);
            }
            return new Dom7([]);
        }
        return new Dom7([]);
    }
    function prevAll(selector) {
        var prevEls = [];
        var el = this[0];
        if (!el) {
            return new Dom7([]);
        }
        while (el.previousElementSibling) {
            var prev = el.previousElementSibling;
            if (selector) {
                if ($(prev).is(selector)) {
                    prevEls.push(prev);
                }
            } else {
                prevEls.push(prev);
            }
            el = prev;
        }
        return new Dom7(prevEls);
    }
    function parent(selector) {
        var parents = [];
        for (var i = 0; i < this.length; i += 1) {
            if (this[i].parentNode !== null) {
                if (selector) {
                    if ($(this[i].parentNode).is(selector)) {
                        parents.push(this[i].parentNode);
                    }
                } else {
                    parents.push(this[i].parentNode);
                }
            }
        }
        return $(unique(parents));
    }
    function parents(selector) {
        var parents = [];
        for (var i = 0; i < this.length; i += 1) {
            var parent = this[i].parentNode;
            while (parent) {
                if (selector) {
                    if ($(parent).is(selector)) {
                        parents.push(parent);
                    }
                } else {
                    parents.push(parent);
                }
                parent = parent.parentNode;
            }
        }
        return $(unique(parents));
    }
    function closest(selector) {
        var closest = this;
        if (typeof selector === "undefined") {
            return new Dom7([]);
        }
        if (!closest.is(selector)) {
            closest = closest.parents(selector).eq(0);
        }
        return closest;
    }
    function find(selector) {
        var foundElements = [];
        for (var i = 0; i < this.length; i += 1) {
            var found = this[i].querySelectorAll(selector);
            for (var j = 0; j < found.length; j += 1) {
                foundElements.push(found[j]);
            }
        }
        return new Dom7(foundElements);
    }
    function children(selector) {
        var children = [];
        for (var i = 0; i < this.length; i += 1) {
            var childNodes = this[i].childNodes;
            for (var j = 0; j < childNodes.length; j += 1) {
                if (!selector) {
                    if (childNodes[j].nodeType === 1) {
                        children.push(childNodes[j]);
                    }
                } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                    children.push(childNodes[j]);
                }
            }
        }
        return new Dom7(unique(children));
    }
    function remove() {
        for (var i = 0; i < this.length; i += 1) {
            if (this[i].parentNode) {
                this[i].parentNode.removeChild(this[i]);
            }
        }
        return this;
    }
    function add() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var dom = this;
        var i;
        var j;
        for (i = 0; i < args.length; i += 1) {
            var toAdd = $(args[i]);
            for (j = 0; j < toAdd.length; j += 1) {
                dom[dom.length] = toAdd[j];
                dom.length += 1;
            }
        }
        return dom;
    }
    var Methods = {
        addClass: addClass,
        removeClass: removeClass,
        hasClass: hasClass,
        toggleClass: toggleClass,
        attr: attr,
        removeAttr: removeAttr,
        data: data,
        transform: transform,
        transition: transition,
        on: on,
        off: off,
        trigger: trigger,
        transitionEnd: transitionEnd,
        outerWidth: outerWidth,
        outerHeight: outerHeight,
        offset: offset,
        css: css,
        each: each,
        html: html,
        text: text,
        is: is,
        index: index,
        eq: eq,
        append: append,
        prepend: prepend,
        next: next,
        nextAll: nextAll,
        prev: prev,
        prevAll: prevAll,
        parent: parent,
        parents: parents,
        closest: closest,
        find: find,
        children: children,
        remove: remove,
        add: add,
        styles: styles
    };
    Object.keys(Methods).forEach(function(methodName) {
        $.fn[methodName] = Methods[methodName];
    });
    var Utils = {
        deleteProps: function deleteProps(obj) {
            var object = obj;
            Object.keys(object).forEach(function(key) {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            });
        },
        nextTick: function nextTick(callback, delay) {
            if (delay === void 0) delay = 0;
            return setTimeout(callback, delay);
        },
        now: function now() {
            return Date.now();
        },
        getTranslate: function getTranslate(el, axis) {
            if (axis === void 0) axis = "x";
            var matrix;
            var curTransform;
            var transformMatrix;
            var curStyle = win.getComputedStyle(el, null);
            if (win.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) {
                    curTransform = curTransform.split(", ").map(function(a) {
                        return a.replace(",", ".");
                    }).join(", ");
                }
                transformMatrix = new win.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") {
                if (win.WebKitCSSMatrix) {
                    curTransform = transformMatrix.m41;
                } else if (matrix.length === 16) {
                    curTransform = parseFloat(matrix[12]);
                } else {
                    curTransform = parseFloat(matrix[4]);
                }
            }
            if (axis === "y") {
                if (win.WebKitCSSMatrix) {
                    curTransform = transformMatrix.m42;
                } else if (matrix.length === 16) {
                    curTransform = parseFloat(matrix[13]);
                } else {
                    curTransform = parseFloat(matrix[5]);
                }
            }
            return curTransform || 0;
        },
        parseUrlQuery: function parseUrlQuery(url) {
            var query = {};
            var urlToParse = url || win.location.href;
            var i;
            var params;
            var param;
            var length;
            if (typeof urlToParse === "string" && urlToParse.length) {
                urlToParse = urlToParse.indexOf("?") > -1 ? urlToParse.replace(/\S*\?/, "") : "";
                params = urlToParse.split("&").filter(function(paramsPart) {
                    return paramsPart !== "";
                });
                length = params.length;
                for (i = 0; i < length; i += 1) {
                    param = params[i].replace(/#\S+/g, "").split("=");
                    query[decodeURIComponent(param[0])] = typeof param[1] === "undefined" ? undefined : decodeURIComponent(param[1]) || "";
                }
            }
            return query;
        },
        isObject: function isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && o.constructor === Object;
        },
        extend: function extend() {
            var args = [], len$1 = arguments.length;
            while (len$1--) args[len$1] = arguments[len$1];
            var to = Object(args[0]);
            for (var i = 1; i < args.length; i += 1) {
                var nextSource = args[i];
                if (nextSource !== undefined && nextSource !== null) {
                    var keysArray = Object.keys(Object(nextSource));
                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        var nextKey = keysArray[nextIndex];
                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable) {
                            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                                Utils.extend(to[nextKey], nextSource[nextKey]);
                            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                                to[nextKey] = {};
                                Utils.extend(to[nextKey], nextSource[nextKey]);
                            } else {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                }
            }
            return to;
        }
    };
    var Support = function Support() {
        var testDiv = doc.createElement("div");
        return {
            touch: win.Modernizr && win.Modernizr.touch === true || function checkTouch() {
                return !!(win.navigator.maxTouchPoints > 0 || "ontouchstart" in win || win.DocumentTouch && doc instanceof win.DocumentTouch);
            }(),
            pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent || "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0),
            prefixedPointerEvents: !!win.navigator.msPointerEnabled,
            transition: function checkTransition() {
                var style = testDiv.style;
                return "transition" in style || "webkitTransition" in style || "MozTransition" in style;
            }(),
            transforms3d: win.Modernizr && win.Modernizr.csstransforms3d === true || function checkTransforms3d() {
                var style = testDiv.style;
                return "webkitPerspective" in style || "MozPerspective" in style || "OPerspective" in style || "MsPerspective" in style || "perspective" in style;
            }(),
            flexbox: function checkFlexbox() {
                var style = testDiv.style;
                var styles = "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" ");
                for (var i = 0; i < styles.length; i += 1) {
                    if (styles[i] in style) {
                        return true;
                    }
                }
                return false;
            }(),
            observer: function checkObserver() {
                return "MutationObserver" in win || "WebkitMutationObserver" in win;
            }(),
            passiveListener: function checkPassiveListener() {
                var supportsPassive = false;
                try {
                    var opts = Object.defineProperty({}, "passive", {
                        get: function get() {
                            supportsPassive = true;
                        }
                    });
                    win.addEventListener("testPassiveListener", null, opts);
                } catch (e) {}
                return supportsPassive;
            }(),
            gestures: function checkGestures() {
                return "ongesturestart" in win;
            }()
        };
    }();
    var Browser = function Browser() {
        function isSafari() {
            var ua = win.navigator.userAgent.toLowerCase();
            return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
        }
        return {
            isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),
            isEdge: !!win.navigator.userAgent.match(/Edge/g),
            isSafari: isSafari(),
            isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent)
        };
    }();
    var SwiperClass = function SwiperClass(params) {
        if (params === void 0) params = {};
        var self = this;
        self.params = params;
        self.eventsListeners = {};
        if (self.params && self.params.on) {
            Object.keys(self.params.on).forEach(function(eventName) {
                self.on(eventName, self.params.on[eventName]);
            });
        }
    };
    var staticAccessors = {
        components: {
            configurable: true
        }
    };
    SwiperClass.prototype.on = function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== "function") {
            return self;
        }
        var method = priority ? "unshift" : "push";
        events.split(" ").forEach(function(event) {
            if (!self.eventsListeners[event]) {
                self.eventsListeners[event] = [];
            }
            self.eventsListeners[event][method](handler);
        });
        return self;
    };
    SwiperClass.prototype.once = function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== "function") {
            return self;
        }
        function onceHandler() {
            var args = [], len = arguments.length;
            while (len--) args[len] = arguments[len];
            handler.apply(self, args);
            self.off(events, onceHandler);
            if (onceHandler.f7proxy) {
                delete onceHandler.f7proxy;
            }
        }
        onceHandler.f7proxy = handler;
        return self.on(events, onceHandler, priority);
    };
    SwiperClass.prototype.off = function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) {
            return self;
        }
        events.split(" ").forEach(function(event) {
            if (typeof handler === "undefined") {
                self.eventsListeners[event] = [];
            } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
                self.eventsListeners[event].forEach(function(eventHandler, index) {
                    if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
                        self.eventsListeners[event].splice(index, 1);
                    }
                });
            }
        });
        return self;
    };
    SwiperClass.prototype.emit = function emit() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var self = this;
        if (!self.eventsListeners) {
            return self;
        }
        var events;
        var data;
        var context;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
            events = args[0];
            data = args.slice(1, args.length);
            context = self;
        } else {
            events = args[0].events;
            data = args[0].data;
            context = args[0].context || self;
        }
        var eventsArray = Array.isArray(events) ? events : events.split(" ");
        eventsArray.forEach(function(event) {
            if (self.eventsListeners && self.eventsListeners[event]) {
                var handlers = [];
                self.eventsListeners[event].forEach(function(eventHandler) {
                    handlers.push(eventHandler);
                });
                handlers.forEach(function(eventHandler) {
                    eventHandler.apply(context, data);
                });
            }
        });
        return self;
    };
    SwiperClass.prototype.useModulesParams = function useModulesParams(instanceParams) {
        var instance = this;
        if (!instance.modules) {
            return;
        }
        Object.keys(instance.modules).forEach(function(moduleName) {
            var module = instance.modules[moduleName];
            if (module.params) {
                Utils.extend(instanceParams, module.params);
            }
        });
    };
    SwiperClass.prototype.useModules = function useModules(modulesParams) {
        if (modulesParams === void 0) modulesParams = {};
        var instance = this;
        if (!instance.modules) {
            return;
        }
        Object.keys(instance.modules).forEach(function(moduleName) {
            var module = instance.modules[moduleName];
            var moduleParams = modulesParams[moduleName] || {};
            if (module.instance) {
                Object.keys(module.instance).forEach(function(modulePropName) {
                    var moduleProp = module.instance[modulePropName];
                    if (typeof moduleProp === "function") {
                        instance[modulePropName] = moduleProp.bind(instance);
                    } else {
                        instance[modulePropName] = moduleProp;
                    }
                });
            }
            if (module.on && instance.on) {
                Object.keys(module.on).forEach(function(moduleEventName) {
                    instance.on(moduleEventName, module.on[moduleEventName]);
                });
            }
            if (module.create) {
                module.create.bind(instance)(moduleParams);
            }
        });
    };
    staticAccessors.components.set = function(components) {
        var Class = this;
        if (!Class.use) {
            return;
        }
        Class.use(components);
    };
    SwiperClass.installModule = function installModule(module) {
        var params = [], len = arguments.length - 1;
        while (len-- > 0) params[len] = arguments[len + 1];
        var Class = this;
        if (!Class.prototype.modules) {
            Class.prototype.modules = {};
        }
        var name = module.name || Object.keys(Class.prototype.modules).length + "_" + Utils.now();
        Class.prototype.modules[name] = module;
        if (module.proto) {
            Object.keys(module.proto).forEach(function(key) {
                Class.prototype[key] = module.proto[key];
            });
        }
        if (module.static) {
            Object.keys(module.static).forEach(function(key) {
                Class[key] = module.static[key];
            });
        }
        if (module.install) {
            module.install.apply(Class, params);
        }
        return Class;
    };
    SwiperClass.use = function use(module) {
        var params = [], len = arguments.length - 1;
        while (len-- > 0) params[len] = arguments[len + 1];
        var Class = this;
        if (Array.isArray(module)) {
            module.forEach(function(m) {
                return Class.installModule(m);
            });
            return Class;
        }
        return Class.installModule.apply(Class, [ module ].concat(params));
    };
    Object.defineProperties(SwiperClass, staticAccessors);
    function updateSize() {
        var swiper = this;
        var width;
        var height;
        var $el = swiper.$el;
        if (typeof swiper.params.width !== "undefined") {
            width = swiper.params.width;
        } else {
            width = $el[0].clientWidth;
        }
        if (typeof swiper.params.height !== "undefined") {
            height = swiper.params.height;
        } else {
            height = $el[0].clientHeight;
        }
        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
            return;
        }
        width = width - parseInt($el.css("padding-left"), 10) - parseInt($el.css("padding-right"), 10);
        height = height - parseInt($el.css("padding-top"), 10) - parseInt($el.css("padding-bottom"), 10);
        Utils.extend(swiper, {
            width: width,
            height: height,
            size: swiper.isHorizontal() ? width : height
        });
    }
    function updateSlides() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var swiperSize = swiper.size;
        var rtl = swiper.rtlTranslate;
        var wrongRTL = swiper.wrongRTL;
        var isVirtual = swiper.virtual && params.virtual.enabled;
        var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
        var slides = $wrapperEl.children("." + swiper.params.slideClass);
        var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        var snapGrid = [];
        var slidesGrid = [];
        var slidesSizesGrid = [];
        var offsetBefore = params.slidesOffsetBefore;
        if (typeof offsetBefore === "function") {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
        }
        var offsetAfter = params.slidesOffsetAfter;
        if (typeof offsetAfter === "function") {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
        }
        var previousSnapGridLength = swiper.snapGrid.length;
        var previousSlidesGridLength = swiper.snapGrid.length;
        var spaceBetween = params.spaceBetween;
        var slidePosition = -offsetBefore;
        var prevSlideSize = 0;
        var index = 0;
        if (typeof swiperSize === "undefined") {
            return;
        }
        if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
        }
        swiper.virtualSize = -spaceBetween;
        if (rtl) {
            slides.css({
                marginLeft: "",
                marginTop: ""
            });
        } else {
            slides.css({
                marginRight: "",
                marginBottom: ""
            });
        }
        var slidesNumberEvenToRows;
        if (params.slidesPerColumn > 1) {
            if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
                slidesNumberEvenToRows = slidesLength;
            } else {
                slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
            }
            if (params.slidesPerView !== "auto" && params.slidesPerColumnFill === "row") {
                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
            }
        }
        var slideSize;
        var slidesPerColumn = params.slidesPerColumn;
        var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
        var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
        for (var i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            var slide = slides.eq(i);
            if (params.slidesPerColumn > 1) {
                var newSlideOrderIndex = void 0;
                var column = void 0;
                var row = void 0;
                if (params.slidesPerColumnFill === "column") {
                    column = Math.floor(i / slidesPerColumn);
                    row = i - column * slidesPerColumn;
                    if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
                        row += 1;
                        if (row >= slidesPerColumn) {
                            row = 0;
                            column += 1;
                        }
                    }
                    newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                    slide.css({
                        "-webkit-box-ordinal-group": newSlideOrderIndex,
                        "-moz-box-ordinal-group": newSlideOrderIndex,
                        "-ms-flex-order": newSlideOrderIndex,
                        "-webkit-order": newSlideOrderIndex,
                        order: newSlideOrderIndex
                    });
                } else {
                    row = Math.floor(i / slidesPerRow);
                    column = i - row * slidesPerRow;
                }
                slide.css("margin-" + (swiper.isHorizontal() ? "top" : "left"), row !== 0 && params.spaceBetween && params.spaceBetween + "px").attr("data-swiper-column", column).attr("data-swiper-row", row);
            }
            if (slide.css("display") === "none") {
                continue;
            }
            if (params.slidesPerView === "auto") {
                var slideStyles = win.getComputedStyle(slide[0], null);
                var currentTransform = slide[0].style.transform;
                var currentWebKitTransform = slide[0].style.webkitTransform;
                if (currentTransform) {
                    slide[0].style.transform = "none";
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = "none";
                }
                if (params.roundLengths) {
                    slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                } else {
                    if (swiper.isHorizontal()) {
                        var width = parseFloat(slideStyles.getPropertyValue("width"));
                        var paddingLeft = parseFloat(slideStyles.getPropertyValue("padding-left"));
                        var paddingRight = parseFloat(slideStyles.getPropertyValue("padding-right"));
                        var marginLeft = parseFloat(slideStyles.getPropertyValue("margin-left"));
                        var marginRight = parseFloat(slideStyles.getPropertyValue("margin-right"));
                        var boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") {
                            slideSize = width + marginLeft + marginRight;
                        } else {
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
                        }
                    } else {
                        var height = parseFloat(slideStyles.getPropertyValue("height"));
                        var paddingTop = parseFloat(slideStyles.getPropertyValue("padding-top"));
                        var paddingBottom = parseFloat(slideStyles.getPropertyValue("padding-bottom"));
                        var marginTop = parseFloat(slideStyles.getPropertyValue("margin-top"));
                        var marginBottom = parseFloat(slideStyles.getPropertyValue("margin-bottom"));
                        var boxSizing$1 = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing$1 && boxSizing$1 === "border-box") {
                            slideSize = height + marginTop + marginBottom;
                        } else {
                            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
                        }
                    }
                }
                if (currentTransform) {
                    slide[0].style.transform = currentTransform;
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = currentWebKitTransform;
                }
                if (params.roundLengths) {
                    slideSize = Math.floor(slideSize);
                }
            } else {
                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                if (params.roundLengths) {
                    slideSize = Math.floor(slideSize);
                }
                if (slides[i]) {
                    if (swiper.isHorizontal()) {
                        slides[i].style.width = slideSize + "px";
                    } else {
                        slides[i].style.height = slideSize + "px";
                    }
                }
            }
            if (slides[i]) {
                slides[i].swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);
            if (params.centeredSlides) {
                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                if (prevSlideSize === 0 && i !== 0) {
                    slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                }
                if (i === 0) {
                    slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                }
                if (Math.abs(slidePosition) < 1 / 1e3) {
                    slidePosition = 0;
                }
                if (params.roundLengths) {
                    slidePosition = Math.floor(slidePosition);
                }
                if (index % params.slidesPerGroup === 0) {
                    snapGrid.push(slidePosition);
                }
                slidesGrid.push(slidePosition);
            } else {
                if (params.roundLengths) {
                    slidePosition = Math.floor(slidePosition);
                }
                if (index % params.slidesPerGroup === 0) {
                    snapGrid.push(slidePosition);
                }
                slidesGrid.push(slidePosition);
                slidePosition = slidePosition + slideSize + spaceBetween;
            }
            swiper.virtualSize += slideSize + spaceBetween;
            prevSlideSize = slideSize;
            index += 1;
        }
        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        var newSlidesGrid;
        if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
            $wrapperEl.css({
                width: swiper.virtualSize + params.spaceBetween + "px"
            });
        }
        if (!Support.flexbox || params.setWrapperSize) {
            if (swiper.isHorizontal()) {
                $wrapperEl.css({
                    width: swiper.virtualSize + params.spaceBetween + "px"
                });
            } else {
                $wrapperEl.css({
                    height: swiper.virtualSize + params.spaceBetween + "px"
                });
            }
        }
        if (params.slidesPerColumn > 1) {
            swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
            if (swiper.isHorizontal()) {
                $wrapperEl.css({
                    width: swiper.virtualSize + params.spaceBetween + "px"
                });
            } else {
                $wrapperEl.css({
                    height: swiper.virtualSize + params.spaceBetween + "px"
                });
            }
            if (params.centeredSlides) {
                newSlidesGrid = [];
                for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
                    var slidesGridItem = snapGrid[i$1];
                    if (params.roundLengths) {
                        slidesGridItem = Math.floor(slidesGridItem);
                    }
                    if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) {
                        newSlidesGrid.push(slidesGridItem);
                    }
                }
                snapGrid = newSlidesGrid;
            }
        }
        if (!params.centeredSlides) {
            newSlidesGrid = [];
            for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
                var slidesGridItem$1 = snapGrid[i$2];
                if (params.roundLengths) {
                    slidesGridItem$1 = Math.floor(slidesGridItem$1);
                }
                if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
                    newSlidesGrid.push(slidesGridItem$1);
                }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
                snapGrid.push(swiper.virtualSize - swiperSize);
            }
        }
        if (snapGrid.length === 0) {
            snapGrid = [ 0 ];
        }
        if (params.spaceBetween !== 0) {
            if (swiper.isHorizontal()) {
                if (rtl) {
                    slides.css({
                        marginLeft: spaceBetween + "px"
                    });
                } else {
                    slides.css({
                        marginRight: spaceBetween + "px"
                    });
                }
            } else {
                slides.css({
                    marginBottom: spaceBetween + "px"
                });
            }
        }
        if (params.centerInsufficientSlides) {
            var allSlidesSize = 0;
            slidesSizesGrid.forEach(function(slideSizeValue) {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            if (allSlidesSize < swiperSize) {
                var allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                snapGrid.forEach(function(snap, snapIndex) {
                    snapGrid[snapIndex] = snap - allSlidesOffset;
                });
                slidesGrid.forEach(function(snap, snapIndex) {
                    slidesGrid[snapIndex] = snap + allSlidesOffset;
                });
            }
        }
        Utils.extend(swiper, {
            slides: slides,
            snapGrid: snapGrid,
            slidesGrid: slidesGrid,
            slidesSizesGrid: slidesSizesGrid
        });
        if (slidesLength !== previousSlidesLength) {
            swiper.emit("slidesLengthChange");
        }
        if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            }
            swiper.emit("snapGridLengthChange");
        }
        if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit("slidesGridLengthChange");
        }
        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateSlidesOffset();
        }
    }
    function updateAutoHeight(speed) {
        var swiper = this;
        var activeSlides = [];
        var newHeight = 0;
        var i;
        if (typeof speed === "number") {
            swiper.setTransition(speed);
        } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
        }
        if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
            for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                var index = swiper.activeIndex + i;
                if (index > swiper.slides.length) {
                    break;
                }
                activeSlides.push(swiper.slides.eq(index)[0]);
            }
        } else {
            activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
        }
        for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== "undefined") {
                var height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
        }
        if (newHeight) {
            swiper.$wrapperEl.css("height", newHeight + "px");
        }
    }
    function updateSlidesOffset() {
        var swiper = this;
        var slides = swiper.slides;
        for (var i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
    }
    function updateSlidesProgress(translate) {
        if (translate === void 0) translate = this && this.translate || 0;
        var swiper = this;
        var params = swiper.params;
        var slides = swiper.slides;
        var rtl = swiper.rtlTranslate;
        if (slides.length === 0) {
            return;
        }
        if (typeof slides[0].swiperSlideOffset === "undefined") {
            swiper.updateSlidesOffset();
        }
        var offsetCenter = -translate;
        if (rtl) {
            offsetCenter = translate;
        }
        slides.removeClass(params.slideVisibleClass);
        swiper.visibleSlidesIndexes = [];
        swiper.visibleSlides = [];
        for (var i = 0; i < slides.length; i += 1) {
            var slide = slides[i];
            var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            if (params.watchSlidesVisibility) {
                var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                var isVisible = slideBefore >= 0 && slideBefore < swiper.size || slideAfter > 0 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides.eq(i).addClass(params.slideVisibleClass);
                }
            }
            slide.progress = rtl ? -slideProgress : slideProgress;
        }
        swiper.visibleSlides = $(swiper.visibleSlides);
    }
    function updateProgress(translate) {
        if (translate === void 0) translate = this && this.translate || 0;
        var swiper = this;
        var params = swiper.params;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        var progress = swiper.progress;
        var isBeginning = swiper.isBeginning;
        var isEnd = swiper.isEnd;
        var wasBeginning = isBeginning;
        var wasEnd = isEnd;
        if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
        } else {
            progress = (translate - swiper.minTranslate()) / translatesDiff;
            isBeginning = progress <= 0;
            isEnd = progress >= 1;
        }
        Utils.extend(swiper, {
            progress: progress,
            isBeginning: isBeginning,
            isEnd: isEnd
        });
        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateSlidesProgress(translate);
        }
        if (isBeginning && !wasBeginning) {
            swiper.emit("reachBeginning toEdge");
        }
        if (isEnd && !wasEnd) {
            swiper.emit("reachEnd toEdge");
        }
        if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
            swiper.emit("fromEdge");
        }
        swiper.emit("progress", progress);
    }
    function updateSlidesClasses() {
        var swiper = this;
        var slides = swiper.slides;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;
        var realIndex = swiper.realIndex;
        var isVirtual = swiper.virtual && params.virtual.enabled;
        slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
        var activeSlide;
        if (isVirtual) {
            activeSlide = swiper.$wrapperEl.find("." + params.slideClass + '[data-swiper-slide-index="' + activeIndex + '"]');
        } else {
            activeSlide = slides.eq(activeIndex);
        }
        activeSlide.addClass(params.slideActiveClass);
        if (params.loop) {
            if (activeSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
            } else {
                $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
            }
        }
        var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);
        if (params.loop && nextSlide.length === 0) {
            nextSlide = slides.eq(0);
            nextSlide.addClass(params.slideNextClass);
        }
        var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);
        if (params.loop && prevSlide.length === 0) {
            prevSlide = slides.eq(-1);
            prevSlide.addClass(params.slidePrevClass);
        }
        if (params.loop) {
            if (nextSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
            } else {
                $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
            }
            if (prevSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
            } else {
                $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
            }
        }
    }
    function updateActiveIndex(newActiveIndex) {
        var swiper = this;
        var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        var slidesGrid = swiper.slidesGrid;
        var snapGrid = swiper.snapGrid;
        var params = swiper.params;
        var previousIndex = swiper.activeIndex;
        var previousRealIndex = swiper.realIndex;
        var previousSnapIndex = swiper.snapIndex;
        var activeIndex = newActiveIndex;
        var snapIndex;
        if (typeof activeIndex === "undefined") {
            for (var i = 0; i < slidesGrid.length; i += 1) {
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                        activeIndex = i;
                    } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                        activeIndex = i + 1;
                    }
                } else if (translate >= slidesGrid[i]) {
                    activeIndex = i;
                }
            }
            if (params.normalizeSlideIndex) {
                if (activeIndex < 0 || typeof activeIndex === "undefined") {
                    activeIndex = 0;
                }
            }
        }
        if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
        } else {
            snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
        }
        if (snapIndex >= snapGrid.length) {
            snapIndex = snapGrid.length - 1;
        }
        if (activeIndex === previousIndex) {
            if (snapIndex !== previousSnapIndex) {
                swiper.snapIndex = snapIndex;
                swiper.emit("snapIndexChange");
            }
            return;
        }
        var realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
        Utils.extend(swiper, {
            snapIndex: snapIndex,
            realIndex: realIndex,
            previousIndex: previousIndex,
            activeIndex: activeIndex
        });
        swiper.emit("activeIndexChange");
        swiper.emit("snapIndexChange");
        if (previousRealIndex !== realIndex) {
            swiper.emit("realIndexChange");
        }
        swiper.emit("slideChange");
    }
    function updateClickedSlide(e) {
        var swiper = this;
        var params = swiper.params;
        var slide = $(e.target).closest("." + params.slideClass)[0];
        var slideFound = false;
        if (slide) {
            for (var i = 0; i < swiper.slides.length; i += 1) {
                if (swiper.slides[i] === slide) {
                    slideFound = true;
                }
            }
        }
        if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
                swiper.clickedIndex = parseInt($(slide).attr("data-swiper-slide-index"), 10);
            } else {
                swiper.clickedIndex = $(slide).index();
            }
        } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
        }
        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
        }
    }
    var update = {
        updateSize: updateSize,
        updateSlides: updateSlides,
        updateAutoHeight: updateAutoHeight,
        updateSlidesOffset: updateSlidesOffset,
        updateSlidesProgress: updateSlidesProgress,
        updateProgress: updateProgress,
        updateSlidesClasses: updateSlidesClasses,
        updateActiveIndex: updateActiveIndex,
        updateClickedSlide: updateClickedSlide
    };
    function getTranslate(axis) {
        if (axis === void 0) axis = this.isHorizontal() ? "x" : "y";
        var swiper = this;
        var params = swiper.params;
        var rtl = swiper.rtlTranslate;
        var translate = swiper.translate;
        var $wrapperEl = swiper.$wrapperEl;
        if (params.virtualTranslate) {
            return rtl ? -translate : translate;
        }
        var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
        if (rtl) {
            currentTranslate = -currentTranslate;
        }
        return currentTranslate || 0;
    }
    function setTranslate(translate, byController) {
        var swiper = this;
        var rtl = swiper.rtlTranslate;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var progress = swiper.progress;
        var x = 0;
        var y = 0;
        var z = 0;
        if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
        } else {
            y = translate;
        }
        if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
        }
        if (!params.virtualTranslate) {
            if (Support.transforms3d) {
                $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
            } else {
                $wrapperEl.transform("translate(" + x + "px, " + y + "px)");
            }
        }
        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y;
        var newProgress;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (translate - swiper.minTranslate()) / translatesDiff;
        }
        if (newProgress !== progress) {
            swiper.updateProgress(translate);
        }
        swiper.emit("setTranslate", swiper.translate, byController);
    }
    function minTranslate() {
        return -this.snapGrid[0];
    }
    function maxTranslate() {
        return -this.snapGrid[this.snapGrid.length - 1];
    }
    var translate = {
        getTranslate: getTranslate,
        setTranslate: setTranslate,
        minTranslate: minTranslate,
        maxTranslate: maxTranslate
    };
    function setTransition(duration, byController) {
        var swiper = this;
        swiper.$wrapperEl.transition(duration);
        swiper.emit("setTransition", duration, byController);
    }
    function transitionStart(runCallbacks, direction) {
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var params = swiper.params;
        var previousIndex = swiper.previousIndex;
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        var dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) {
                dir = "next";
            } else if (activeIndex < previousIndex) {
                dir = "prev";
            } else {
                dir = "reset";
            }
        }
        swiper.emit("transitionStart");
        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === "reset") {
                swiper.emit("slideResetTransitionStart");
                return;
            }
            swiper.emit("slideChangeTransitionStart");
            if (dir === "next") {
                swiper.emit("slideNextTransitionStart");
            } else {
                swiper.emit("slidePrevTransitionStart");
            }
        }
    }
    function transitionEnd$1(runCallbacks, direction) {
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var previousIndex = swiper.previousIndex;
        swiper.animating = false;
        swiper.setTransition(0);
        var dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) {
                dir = "next";
            } else if (activeIndex < previousIndex) {
                dir = "prev";
            } else {
                dir = "reset";
            }
        }
        swiper.emit("transitionEnd");
        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === "reset") {
                swiper.emit("slideResetTransitionEnd");
                return;
            }
            swiper.emit("slideChangeTransitionEnd");
            if (dir === "next") {
                swiper.emit("slideNextTransitionEnd");
            } else {
                swiper.emit("slidePrevTransitionEnd");
            }
        }
    }
    var transition$1 = {
        setTransition: setTransition,
        transitionStart: transitionStart,
        transitionEnd: transitionEnd$1
    };
    function slideTo(index, speed, runCallbacks, internal) {
        if (index === void 0) index = 0;
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var slideIndex = index;
        if (slideIndex < 0) {
            slideIndex = 0;
        }
        var params = swiper.params;
        var snapGrid = swiper.snapGrid;
        var slidesGrid = swiper.slidesGrid;
        var previousIndex = swiper.previousIndex;
        var activeIndex = swiper.activeIndex;
        var rtl = swiper.rtlTranslate;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
        }
        var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
        if (snapIndex >= snapGrid.length) {
            snapIndex = snapGrid.length - 1;
        }
        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
            swiper.emit("beforeSlideChangeStart");
        }
        var translate = -snapGrid[snapIndex];
        swiper.updateProgress(translate);
        if (params.normalizeSlideIndex) {
            for (var i = 0; i < slidesGrid.length; i += 1) {
                if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
                    slideIndex = i;
                }
            }
        }
        if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
                return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
                if ((activeIndex || 0) !== slideIndex) {
                    return false;
                }
            }
        }
        var direction;
        if (slideIndex > activeIndex) {
            direction = "next";
        } else if (slideIndex < activeIndex) {
            direction = "prev";
        } else {
            direction = "reset";
        }
        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
            swiper.updateActiveIndex(slideIndex);
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== "slide") {
                swiper.setTranslate(translate);
            }
            if (direction !== "reset") {
                swiper.transitionStart(runCallbacks, direction);
                swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
        }
        if (speed === 0 || !Support.transition) {
            swiper.setTransition(0);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        } else {
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) {
                    swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) {
                            return;
                        }
                        if (e.target !== this) {
                            return;
                        }
                        swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
                        swiper.onSlideToWrapperTransitionEnd = null;
                        delete swiper.onSlideToWrapperTransitionEnd;
                        swiper.transitionEnd(runCallbacks, direction);
                    };
                }
                swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
            }
        }
        return true;
    }
    function slideToLoop(index, speed, runCallbacks, internal) {
        if (index === void 0) index = 0;
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var newIndex = index;
        if (swiper.params.loop) {
            newIndex += swiper.loopedSlides;
        }
        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }
    function slideNext(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var params = swiper.params;
        var animating = swiper.animating;
        if (params.loop) {
            if (animating) {
                return false;
            }
            swiper.loopFix();
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
        }
        return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
    }
    function slidePrev(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var params = swiper.params;
        var animating = swiper.animating;
        var snapGrid = swiper.snapGrid;
        var slidesGrid = swiper.slidesGrid;
        var rtlTranslate = swiper.rtlTranslate;
        if (params.loop) {
            if (animating) {
                return false;
            }
            swiper.loopFix();
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        var translate = rtlTranslate ? swiper.translate : -swiper.translate;
        function normalize(val) {
            if (val < 0) {
                return -Math.floor(Math.abs(val));
            }
            return Math.floor(val);
        }
        var normalizedTranslate = normalize(translate);
        var normalizedSnapGrid = snapGrid.map(function(val) {
            return normalize(val);
        });
        var normalizedSlidesGrid = slidesGrid.map(function(val) {
            return normalize(val);
        });
        var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
        var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
        var prevIndex;
        if (typeof prevSnap !== "undefined") {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) {
                prevIndex = swiper.activeIndex - 1;
            }
        }
        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }
    function slideReset(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }
    function slideToClosest(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var index = swiper.activeIndex;
        var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);
        if (snapIndex < swiper.snapGrid.length - 1) {
            var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            var currentSnap = swiper.snapGrid[snapIndex];
            var nextSnap = swiper.snapGrid[snapIndex + 1];
            if (translate - currentSnap > (nextSnap - currentSnap) / 2) {
                index = swiper.params.slidesPerGroup;
            }
        }
        return swiper.slideTo(index, speed, runCallbacks, internal);
    }
    function slideToClickedSlide() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        var slideToIndex = swiper.clickedIndex;
        var realIndex;
        if (params.loop) {
            if (swiper.animating) {
                return;
            }
            realIndex = parseInt($(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
            if (params.centeredSlides) {
                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
                    Utils.nextTick(function() {
                        swiper.slideTo(slideToIndex);
                    });
                } else {
                    swiper.slideTo(slideToIndex);
                }
            } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                swiper.loopFix();
                slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
                Utils.nextTick(function() {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else {
            swiper.slideTo(slideToIndex);
        }
    }
    var slide = {
        slideTo: slideTo,
        slideToLoop: slideToLoop,
        slideNext: slideNext,
        slidePrev: slidePrev,
        slideReset: slideReset,
        slideToClosest: slideToClosest,
        slideToClickedSlide: slideToClickedSlide
    };
    function loopCreate() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
        var slides = $wrapperEl.children("." + params.slideClass);
        if (params.loopFillGroupWithBlank) {
            var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
            if (blankSlidesNum !== params.slidesPerGroup) {
                for (var i = 0; i < blankSlidesNum; i += 1) {
                    var blankNode = $(doc.createElement("div")).addClass(params.slideClass + " " + params.slideBlankClass);
                    $wrapperEl.append(blankNode);
                }
                slides = $wrapperEl.children("." + params.slideClass);
            }
        }
        if (params.slidesPerView === "auto" && !params.loopedSlides) {
            params.loopedSlides = slides.length;
        }
        swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
        swiper.loopedSlides += params.loopAdditionalSlides;
        if (swiper.loopedSlides > slides.length) {
            swiper.loopedSlides = slides.length;
        }
        var prependSlides = [];
        var appendSlides = [];
        slides.each(function(index, el) {
            var slide = $(el);
            if (index < swiper.loopedSlides) {
                appendSlides.push(el);
            }
            if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
                prependSlides.push(el);
            }
            slide.attr("data-swiper-slide-index", index);
        });
        for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
            $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
            $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
    }
    function loopFix() {
        var swiper = this;
        var params = swiper.params;
        var activeIndex = swiper.activeIndex;
        var slides = swiper.slides;
        var loopedSlides = swiper.loopedSlides;
        var allowSlidePrev = swiper.allowSlidePrev;
        var allowSlideNext = swiper.allowSlideNext;
        var snapGrid = swiper.snapGrid;
        var rtl = swiper.rtlTranslate;
        var newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        var snapTranslate = -snapGrid[activeIndex];
        var diff = snapTranslate - swiper.getTranslate();
        if (activeIndex < loopedSlides) {
            newIndex = slides.length - loopedSlides * 3 + activeIndex;
            newIndex += loopedSlides;
            var slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        } else if (params.slidesPerView === "auto" && activeIndex >= loopedSlides * 2 || activeIndex >= slides.length - loopedSlides) {
            newIndex = -slides.length + activeIndex + loopedSlides;
            newIndex += loopedSlides;
            var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged$1 && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
    }
    function loopDestroy() {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        var slides = swiper.slides;
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
        slides.removeAttr("data-swiper-slide-index");
    }
    var loop = {
        loopCreate: loopCreate,
        loopFix: loopFix,
        loopDestroy: loopDestroy
    };
    function setGrabCursor(moving) {
        var swiper = this;
        if (Support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked) {
            return;
        }
        var el = swiper.el;
        el.style.cursor = "move";
        el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
        el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
        el.style.cursor = moving ? "grabbing" : "grab";
    }
    function unsetGrabCursor() {
        var swiper = this;
        if (Support.touch || swiper.params.watchOverflow && swiper.isLocked) {
            return;
        }
        swiper.el.style.cursor = "";
    }
    var grabCursor = {
        setGrabCursor: setGrabCursor,
        unsetGrabCursor: unsetGrabCursor
    };
    function appendSlide(slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (typeof slides === "object" && "length" in slides) {
            for (var i = 0; i < slides.length; i += 1) {
                if (slides[i]) {
                    $wrapperEl.append(slides[i]);
                }
            }
        } else {
            $wrapperEl.append(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
    }
    function prependSlide(slides) {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;
        if (params.loop) {
            swiper.loopDestroy();
        }
        var newActiveIndex = activeIndex + 1;
        if (typeof slides === "object" && "length" in slides) {
            for (var i = 0; i < slides.length; i += 1) {
                if (slides[i]) {
                    $wrapperEl.prepend(slides[i]);
                }
            }
            newActiveIndex = activeIndex + slides.length;
        } else {
            $wrapperEl.prepend(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        swiper.slideTo(newActiveIndex, 0, false);
    }
    function addSlide(index, slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        var activeIndex = swiper.activeIndex;
        var activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children("." + params.slideClass);
        }
        var baseLength = swiper.slides.length;
        if (index <= 0) {
            swiper.prependSlide(slides);
            return;
        }
        if (index >= baseLength) {
            swiper.appendSlide(slides);
            return;
        }
        var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
        var slidesBuffer = [];
        for (var i = baseLength - 1; i >= index; i -= 1) {
            var currentSlide = swiper.slides.eq(i);
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
        }
        if (typeof slides === "object" && "length" in slides) {
            for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
                if (slides[i$1]) {
                    $wrapperEl.append(slides[i$1]);
                }
            }
            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
        } else {
            $wrapperEl.append(slides);
        }
        for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
            $wrapperEl.append(slidesBuffer[i$2]);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeSlide(slidesIndexes) {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;
        var activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children("." + params.slideClass);
        }
        var newActiveIndex = activeIndexBuffer;
        var indexToRemove;
        if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
            for (var i = 0; i < slidesIndexes.length; i += 1) {
                indexToRemove = slidesIndexes[i];
                if (swiper.slides[indexToRemove]) {
                    swiper.slides.eq(indexToRemove).remove();
                }
                if (indexToRemove < newActiveIndex) {
                    newActiveIndex -= 1;
                }
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) {
                swiper.slides.eq(indexToRemove).remove();
            }
            if (indexToRemove < newActiveIndex) {
                newActiveIndex -= 1;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeAllSlides() {
        var swiper = this;
        var slidesIndexes = [];
        for (var i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
        }
        swiper.removeSlide(slidesIndexes);
    }
    var manipulation = {
        appendSlide: appendSlide,
        prependSlide: prependSlide,
        addSlide: addSlide,
        removeSlide: removeSlide,
        removeAllSlides: removeAllSlides
    };
    var Device = function Device() {
        var ua = win.navigator.userAgent;
        var device = {
            ios: false,
            android: false,
            androidChrome: false,
            desktop: false,
            windows: false,
            iphone: false,
            ipod: false,
            ipad: false,
            cordova: win.cordova || win.phonegap,
            phonegap: win.cordova || win.phonegap
        };
        var windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/);
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        if (windows) {
            device.os = "windows";
            device.osVersion = windows[2];
            device.windows = true;
        }
        if (android && !windows) {
            device.os = "android";
            device.osVersion = android[2];
            device.android = true;
            device.androidChrome = ua.toLowerCase().indexOf("chrome") >= 0;
        }
        if (ipad || iphone || ipod) {
            device.os = "ios";
            device.ios = true;
        }
        if (iphone && !ipod) {
            device.osVersion = iphone[2].replace(/_/g, ".");
            device.iphone = true;
        }
        if (ipad) {
            device.osVersion = ipad[2].replace(/_/g, ".");
            device.ipad = true;
        }
        if (ipod) {
            device.osVersion = ipod[3] ? ipod[3].replace(/_/g, ".") : null;
            device.iphone = true;
        }
        if (device.ios && device.osVersion && ua.indexOf("Version/") >= 0) {
            if (device.osVersion.split(".")[0] === "10") {
                device.osVersion = ua.toLowerCase().split("version/")[1].split(" ")[0];
            }
        }
        device.desktop = !(device.os || device.android || device.webView);
        device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);
        if (device.os && device.os === "ios") {
            var osVersionArr = device.osVersion.split(".");
            var metaViewport = doc.querySelector('meta[name="viewport"]');
            device.minimalUi = !device.webView && (ipod || iphone) && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) && metaViewport && metaViewport.getAttribute("content").indexOf("minimal-ui") >= 0;
        }
        device.pixelRatio = win.devicePixelRatio || 1;
        return device;
    }();
    function onTouchStart(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return;
        }
        var e = event;
        if (e.originalEvent) {
            e = e.originalEvent;
        }
        data.isTouchEvent = e.type === "touchstart";
        if (!data.isTouchEvent && "which" in e && e.which === 3) {
            return;
        }
        if (!data.isTouchEvent && "button" in e && e.button > 0) {
            return;
        }
        if (data.isTouched && data.isMoved) {
            return;
        }
        if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
            swiper.allowClick = true;
            return;
        }
        if (params.swipeHandler) {
            if (!$(e).closest(params.swipeHandler)[0]) {
                return;
            }
        }
        touches.currentX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
        var startX = touches.currentX;
        var startY = touches.currentY;
        var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= win.screen.width - edgeSwipeThreshold)) {
            return;
        }
        Utils.extend(data, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined
        });
        touches.startX = startX;
        touches.startY = startY;
        data.touchStartTime = Utils.now();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;
        if (params.threshold > 0) {
            data.allowThresholdMove = false;
        }
        if (e.type !== "touchstart") {
            var preventDefault = true;
            if ($(e.target).is(data.formElements)) {
                preventDefault = false;
            }
            if (doc.activeElement && $(doc.activeElement).is(data.formElements) && doc.activeElement !== e.target) {
                doc.activeElement.blur();
            }
            var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if (params.touchStartForcePreventDefault || shouldPreventDefault) {
                e.preventDefault();
            }
        }
        swiper.emit("touchStart", e);
    }
    function onTouchMove(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;
        var rtl = swiper.rtlTranslate;
        var e = event;
        if (e.originalEvent) {
            e = e.originalEvent;
        }
        if (!data.isTouched) {
            if (data.startMoving && data.isScrolling) {
                swiper.emit("touchMoveOpposite", e);
            }
            return;
        }
        if (data.isTouchEvent && e.type === "mousemove") {
            return;
        }
        var pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
        var pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
        if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
        }
        if (!swiper.allowTouchMove) {
            swiper.allowClick = false;
            if (data.isTouched) {
                Utils.extend(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY
                });
                data.touchStartTime = Utils.now();
            }
            return;
        }
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
                return;
            }
        }
        if (data.isTouchEvent && doc.activeElement) {
            if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
        }
        if (data.allowTouchCallbacks) {
            swiper.emit("touchMove", e);
        }
        if (e.targetTouches && e.targetTouches.length > 1) {
            return;
        }
        touches.currentX = pageX;
        touches.currentY = pageY;
        var diffX = touches.currentX - touches.startX;
        var diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) {
            return;
        }
        if (typeof data.isScrolling === "undefined") {
            var touchAngle;
            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
                data.isScrolling = false;
            } else {
                if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
        }
        if (data.isScrolling) {
            swiper.emit("touchMoveOpposite", e);
        }
        if (typeof data.startMoving === "undefined") {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                data.startMoving = true;
            }
        }
        if (data.isScrolling) {
            data.isTouched = false;
            return;
        }
        if (!data.startMoving) {
            return;
        }
        swiper.allowClick = false;
        e.preventDefault();
        if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
        }
        if (!data.isMoved) {
            if (params.loop) {
                swiper.loopFix();
            }
            data.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
                swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
            }
            data.allowMomentumBounce = false;
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                swiper.setGrabCursor(true);
            }
            swiper.emit("sliderFirstMove", e);
        }
        swiper.emit("sliderMove", e);
        data.isMoved = true;
        var diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;
        diff *= params.touchRatio;
        if (rtl) {
            diff = -diff;
        }
        swiper.swipeDirection = diff > 0 ? "prev" : "next";
        data.currentTranslate = diff + data.startTranslate;
        var disableParentSwiper = true;
        var resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
        }
        if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
            }
        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
            }
        }
        if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
        }
        if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
        }
        if (!params.followFinger) {
            return;
        }
        if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        if (params.freeMode) {
            if (data.velocities.length === 0) {
                data.velocities.push({
                    position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                    time: data.touchStartTime
                });
            }
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
                time: Utils.now()
            });
        }
        swiper.updateProgress(data.currentTranslate);
        swiper.setTranslate(data.currentTranslate);
    }
    function onTouchEnd(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;
        var rtl = swiper.rtlTranslate;
        var $wrapperEl = swiper.$wrapperEl;
        var slidesGrid = swiper.slidesGrid;
        var snapGrid = swiper.snapGrid;
        var e = event;
        if (e.originalEvent) {
            e = e.originalEvent;
        }
        if (data.allowTouchCallbacks) {
            swiper.emit("touchEnd", e);
        }
        data.allowTouchCallbacks = false;
        if (!data.isTouched) {
            if (data.isMoved && params.grabCursor) {
                swiper.setGrabCursor(false);
            }
            data.isMoved = false;
            data.startMoving = false;
            return;
        }
        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
        }
        var touchEndTime = Utils.now();
        var timeDiff = touchEndTime - data.touchStartTime;
        if (swiper.allowClick) {
            swiper.updateClickedSlide(e);
            swiper.emit("tap", e);
            if (timeDiff < 300 && touchEndTime - data.lastClickTime > 300) {
                if (data.clickTimeout) {
                    clearTimeout(data.clickTimeout);
                }
                data.clickTimeout = Utils.nextTick(function() {
                    if (!swiper || swiper.destroyed) {
                        return;
                    }
                    swiper.emit("click", e);
                }, 300);
            }
            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
                if (data.clickTimeout) {
                    clearTimeout(data.clickTimeout);
                }
                swiper.emit("doubleTap", e);
            }
        }
        data.lastClickTime = Utils.now();
        Utils.nextTick(function() {
            if (!swiper.destroyed) {
                swiper.allowClick = true;
            }
        });
        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            return;
        }
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        var currentPos;
        if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
            currentPos = -data.currentTranslate;
        }
        if (params.freeMode) {
            if (currentPos < -swiper.minTranslate()) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (currentPos > -swiper.maxTranslate()) {
                if (swiper.slides.length < snapGrid.length) {
                    swiper.slideTo(snapGrid.length - 1);
                } else {
                    swiper.slideTo(swiper.slides.length - 1);
                }
                return;
            }
            if (params.freeModeMomentum) {
                if (data.velocities.length > 1) {
                    var lastMoveEvent = data.velocities.pop();
                    var velocityEvent = data.velocities.pop();
                    var distance = lastMoveEvent.position - velocityEvent.position;
                    var time = lastMoveEvent.time - velocityEvent.time;
                    swiper.velocity = distance / time;
                    swiper.velocity /= 2;
                    if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                        swiper.velocity = 0;
                    }
                    if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {
                        swiper.velocity = 0;
                    }
                } else {
                    swiper.velocity = 0;
                }
                swiper.velocity *= params.freeModeMomentumVelocityRatio;
                data.velocities.length = 0;
                var momentumDuration = 1e3 * params.freeModeMomentumRatio;
                var momentumDistance = swiper.velocity * momentumDuration;
                var newPosition = swiper.translate + momentumDistance;
                if (rtl) {
                    newPosition = -newPosition;
                }
                var doBounce = false;
                var afterBouncePosition;
                var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
                var needsLoopFix;
                if (newPosition < swiper.maxTranslate()) {
                    if (params.freeModeMomentumBounce) {
                        if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                            newPosition = swiper.maxTranslate() - bounceAmount;
                        }
                        afterBouncePosition = swiper.maxTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.maxTranslate();
                    }
                    if (params.loop && params.centeredSlides) {
                        needsLoopFix = true;
                    }
                } else if (newPosition > swiper.minTranslate()) {
                    if (params.freeModeMomentumBounce) {
                        if (newPosition - swiper.minTranslate() > bounceAmount) {
                            newPosition = swiper.minTranslate() + bounceAmount;
                        }
                        afterBouncePosition = swiper.minTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.minTranslate();
                    }
                    if (params.loop && params.centeredSlides) {
                        needsLoopFix = true;
                    }
                } else if (params.freeModeSticky) {
                    var nextSlide;
                    for (var j = 0; j < snapGrid.length; j += 1) {
                        if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                    }
                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
                        newPosition = snapGrid[nextSlide];
                    } else {
                        newPosition = snapGrid[nextSlide - 1];
                    }
                    newPosition = -newPosition;
                }
                if (needsLoopFix) {
                    swiper.once("transitionEnd", function() {
                        swiper.loopFix();
                    });
                }
                if (swiper.velocity !== 0) {
                    if (rtl) {
                        momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                    } else {
                        momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                    }
                } else if (params.freeModeSticky) {
                    swiper.slideToClosest();
                    return;
                }
                if (params.freeModeMomentumBounce && doBounce) {
                    swiper.updateProgress(afterBouncePosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(function() {
                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) {
                            return;
                        }
                        swiper.emit("momentumBounce");
                        swiper.setTransition(params.speed);
                        swiper.setTranslate(afterBouncePosition);
                        $wrapperEl.transitionEnd(function() {
                            if (!swiper || swiper.destroyed) {
                                return;
                            }
                            swiper.transitionEnd();
                        });
                    });
                } else if (swiper.velocity) {
                    swiper.updateProgress(newPosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    if (!swiper.animating) {
                        swiper.animating = true;
                        $wrapperEl.transitionEnd(function() {
                            if (!swiper || swiper.destroyed) {
                                return;
                            }
                            swiper.transitionEnd();
                        });
                    }
                } else {
                    swiper.updateProgress(newPosition);
                }
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            } else if (params.freeModeSticky) {
                swiper.slideToClosest();
                return;
            }
            if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            return;
        }
        var stopIndex = 0;
        var groupSize = swiper.slidesSizesGrid[0];
        for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
            if (typeof slidesGrid[i + params.slidesPerGroup] !== "undefined") {
                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
                    stopIndex = i;
                    groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
                }
            } else if (currentPos >= slidesGrid[i]) {
                stopIndex = i;
                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
        }
        var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
        if (timeDiff > params.longSwipesMs) {
            if (!params.longSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === "next") {
                if (ratio >= params.longSwipesRatio) {
                    swiper.slideTo(stopIndex + params.slidesPerGroup);
                } else {
                    swiper.slideTo(stopIndex);
                }
            }
            if (swiper.swipeDirection === "prev") {
                if (ratio > 1 - params.longSwipesRatio) {
                    swiper.slideTo(stopIndex + params.slidesPerGroup);
                } else {
                    swiper.slideTo(stopIndex);
                }
            }
        } else {
            if (!params.shortSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === "next") {
                swiper.slideTo(stopIndex + params.slidesPerGroup);
            }
            if (swiper.swipeDirection === "prev") {
                swiper.slideTo(stopIndex);
            }
        }
    }
    function onResize() {
        var swiper = this;
        var params = swiper.params;
        var el = swiper.el;
        if (el && el.offsetWidth === 0) {
            return;
        }
        if (params.breakpoints) {
            swiper.setBreakpoint();
        }
        var allowSlideNext = swiper.allowSlideNext;
        var allowSlidePrev = swiper.allowSlidePrev;
        var snapGrid = swiper.snapGrid;
        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;
        swiper.updateSize();
        swiper.updateSlides();
        if (params.freeMode) {
            var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
        } else {
            swiper.updateSlidesClasses();
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
                swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
    }
    function onClick(e) {
        var swiper = this;
        if (!swiper.allowClick) {
            if (swiper.params.preventClicks) {
                e.preventDefault();
            }
            if (swiper.params.preventClicksPropagation && swiper.animating) {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }
    }
    function attachEvents() {
        var swiper = this;
        var params = swiper.params;
        var touchEvents = swiper.touchEvents;
        var el = swiper.el;
        var wrapperEl = swiper.wrapperEl;
        {
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
        }
        swiper.onClick = onClick.bind(swiper);
        var target = params.touchEventsTarget === "container" ? el : wrapperEl;
        var capture = !!params.nested;
        {
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
                doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
                doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
            } else {
                if (Support.touch) {
                    var passiveListener = touchEvents.start === "touchstart" && Support.passiveListener && params.passiveListeners ? {
                        passive: true,
                        capture: false
                    } : false;
                    target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
                    target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? {
                        passive: false,
                        capture: capture
                    } : capture);
                    target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
                }
                if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
                    target.addEventListener("mousedown", swiper.onTouchStart, false);
                    doc.addEventListener("mousemove", swiper.onTouchMove, capture);
                    doc.addEventListener("mouseup", swiper.onTouchEnd, false);
                }
            }
            if (params.preventClicks || params.preventClicksPropagation) {
                target.addEventListener("click", swiper.onClick, true);
            }
        }
        swiper.on(Device.ios || Device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    }
    function detachEvents() {
        var swiper = this;
        var params = swiper.params;
        var touchEvents = swiper.touchEvents;
        var el = swiper.el;
        var wrapperEl = swiper.wrapperEl;
        var target = params.touchEventsTarget === "container" ? el : wrapperEl;
        var capture = !!params.nested;
        {
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
                doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
                doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
            } else {
                if (Support.touch) {
                    var passiveListener = touchEvents.start === "onTouchStart" && Support.passiveListener && params.passiveListeners ? {
                        passive: true,
                        capture: false
                    } : false;
                    target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
                    target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
                    target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
                }
                if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
                    target.removeEventListener("mousedown", swiper.onTouchStart, false);
                    doc.removeEventListener("mousemove", swiper.onTouchMove, capture);
                    doc.removeEventListener("mouseup", swiper.onTouchEnd, false);
                }
            }
            if (params.preventClicks || params.preventClicksPropagation) {
                target.removeEventListener("click", swiper.onClick, true);
            }
        }
        swiper.off(Device.ios || Device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize);
    }
    var events = {
        attachEvents: attachEvents,
        detachEvents: detachEvents
    };
    function setBreakpoint() {
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var initialized = swiper.initialized;
        var loopedSlides = swiper.loopedSlides;
        if (loopedSlides === void 0) loopedSlides = 0;
        var params = swiper.params;
        var breakpoints = params.breakpoints;
        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) {
            return;
        }
        var breakpoint = swiper.getBreakpoint(breakpoints);
        if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
            var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
            if (breakpointOnlyParams) {
                [ "slidesPerView", "spaceBetween", "slidesPerGroup" ].forEach(function(param) {
                    var paramValue = breakpointOnlyParams[param];
                    if (typeof paramValue === "undefined") {
                        return;
                    }
                    if (param === "slidesPerView" && (paramValue === "AUTO" || paramValue === "auto")) {
                        breakpointOnlyParams[param] = "auto";
                    } else if (param === "slidesPerView") {
                        breakpointOnlyParams[param] = parseFloat(paramValue);
                    } else {
                        breakpointOnlyParams[param] = parseInt(paramValue, 10);
                    }
                });
            }
            var breakpointParams = breakpointOnlyParams || swiper.originalParams;
            var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            if (directionChanged && initialized) {
                swiper.changeDirection();
            }
            Utils.extend(swiper.params, breakpointParams);
            Utils.extend(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            swiper.currentBreakpoint = breakpoint;
            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate();
                swiper.updateSlides();
                swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
            }
            swiper.emit("breakpoint", breakpointParams);
        }
    }
    function getBreakpoint(breakpoints) {
        var swiper = this;
        if (!breakpoints) {
            return undefined;
        }
        var breakpoint = false;
        var points = [];
        Object.keys(breakpoints).forEach(function(point) {
            points.push(point);
        });
        points.sort(function(a, b) {
            return parseInt(a, 10) - parseInt(b, 10);
        });
        for (var i = 0; i < points.length; i += 1) {
            var point = points[i];
            if (swiper.params.breakpointsInverse) {
                if (point <= win.innerWidth) {
                    breakpoint = point;
                }
            } else if (point >= win.innerWidth && !breakpoint) {
                breakpoint = point;
            }
        }
        return breakpoint || "max";
    }
    var breakpoints = {
        setBreakpoint: setBreakpoint,
        getBreakpoint: getBreakpoint
    };
    function addClasses() {
        var swiper = this;
        var classNames = swiper.classNames;
        var params = swiper.params;
        var rtl = swiper.rtl;
        var $el = swiper.$el;
        var suffixes = [];
        suffixes.push("initialized");
        suffixes.push(params.direction);
        if (params.freeMode) {
            suffixes.push("free-mode");
        }
        if (!Support.flexbox) {
            suffixes.push("no-flexbox");
        }
        if (params.autoHeight) {
            suffixes.push("autoheight");
        }
        if (rtl) {
            suffixes.push("rtl");
        }
        if (params.slidesPerColumn > 1) {
            suffixes.push("multirow");
        }
        if (Device.android) {
            suffixes.push("android");
        }
        if (Device.ios) {
            suffixes.push("ios");
        }
        if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
            suffixes.push("wp8-" + params.direction);
        }
        suffixes.forEach(function(suffix) {
            classNames.push(params.containerModifierClass + suffix);
        });
        $el.addClass(classNames.join(" "));
    }
    function removeClasses() {
        var swiper = this;
        var $el = swiper.$el;
        var classNames = swiper.classNames;
        $el.removeClass(classNames.join(" "));
    }
    var classes = {
        addClasses: addClasses,
        removeClasses: removeClasses
    };
    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        var image;
        function onReady() {
            if (callback) {
                callback();
            }
        }
        if (!imageEl.complete || !checkForComplete) {
            if (src) {
                image = new win.Image();
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) {
                    image.sizes = sizes;
                }
                if (srcset) {
                    image.srcset = srcset;
                }
                if (src) {
                    image.src = src;
                }
            } else {
                onReady();
            }
        } else {
            onReady();
        }
    }
    function preloadImages() {
        var swiper = this;
        swiper.imagesToLoad = swiper.$el.find("img");
        function onReady() {
            if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed) {
                return;
            }
            if (swiper.imagesLoaded !== undefined) {
                swiper.imagesLoaded += 1;
            }
            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                if (swiper.params.updateOnImagesReady) {
                    swiper.update();
                }
                swiper.emit("imagesReady");
            }
        }
        for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
            var imageEl = swiper.imagesToLoad[i];
            swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
        }
    }
    var images = {
        loadImage: loadImage,
        preloadImages: preloadImages
    };
    function checkOverflow() {
        var swiper = this;
        var wasLocked = swiper.isLocked;
        swiper.isLocked = swiper.snapGrid.length === 1;
        swiper.allowSlideNext = !swiper.isLocked;
        swiper.allowSlidePrev = !swiper.isLocked;
        if (wasLocked !== swiper.isLocked) {
            swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
            swiper.navigation.update();
        }
    }
    var checkOverflow$1 = {
        checkOverflow: checkOverflow
    };
    var defaults = {
        init: true,
        direction: "horizontal",
        touchEventsTarget: "container",
        initialSlide: 0,
        speed: 300,
        preventInteractionOnTransition: false,
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,
        freeMode: false,
        freeModeMomentum: true,
        freeModeMomentumRatio: 1,
        freeModeMomentumBounce: true,
        freeModeMomentumBounceRatio: 1,
        freeModeMomentumVelocityRatio: 1,
        freeModeSticky: false,
        freeModeMinimumVelocity: .02,
        autoHeight: false,
        setWrapperSize: false,
        virtualTranslate: false,
        effect: "slide",
        breakpoints: undefined,
        breakpointsInverse: false,
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerColumnFill: "column",
        slidesPerGroup: 1,
        centeredSlides: false,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,
        watchOverflow: false,
        roundLengths: false,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: true,
        touchStartPreventDefault: true,
        touchStartForcePreventDefault: false,
        touchReleaseOnEdges: false,
        uniqueNavElements: true,
        resistance: true,
        resistanceRatio: .85,
        watchSlidesProgress: false,
        watchSlidesVisibility: false,
        grabCursor: false,
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,
        preloadImages: true,
        updateOnImagesReady: true,
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        noSwiping: true,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: true,
        containerModifierClass: "swiper-container-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: true
    };
    var prototypes = {
        update: update,
        translate: translate,
        transition: transition$1,
        slide: slide,
        loop: loop,
        grabCursor: grabCursor,
        manipulation: manipulation,
        events: events,
        breakpoints: breakpoints,
        checkOverflow: checkOverflow$1,
        classes: classes,
        images: images
    };
    var extendedDefaults = {};
    var Swiper = function(SwiperClass) {
        function Swiper() {
            var assign;
            var args = [], len = arguments.length;
            while (len--) args[len] = arguments[len];
            var el;
            var params;
            if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
                params = args[0];
            } else {
                assign = args, el = assign[0], params = assign[1];
            }
            if (!params) {
                params = {};
            }
            params = Utils.extend({}, params);
            if (el && !params.el) {
                params.el = el;
            }
            SwiperClass.call(this, params);
            Object.keys(prototypes).forEach(function(prototypeGroup) {
                Object.keys(prototypes[prototypeGroup]).forEach(function(protoMethod) {
                    if (!Swiper.prototype[protoMethod]) {
                        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
                    }
                });
            });
            var swiper = this;
            if (typeof swiper.modules === "undefined") {
                swiper.modules = {};
            }
            Object.keys(swiper.modules).forEach(function(moduleName) {
                var module = swiper.modules[moduleName];
                if (module.params) {
                    var moduleParamName = Object.keys(module.params)[0];
                    var moduleParams = module.params[moduleParamName];
                    if (typeof moduleParams !== "object" || moduleParams === null) {
                        return;
                    }
                    if (!(moduleParamName in params && "enabled" in moduleParams)) {
                        return;
                    }
                    if (params[moduleParamName] === true) {
                        params[moduleParamName] = {
                            enabled: true
                        };
                    }
                    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
                        params[moduleParamName].enabled = true;
                    }
                    if (!params[moduleParamName]) {
                        params[moduleParamName] = {
                            enabled: false
                        };
                    }
                }
            });
            var swiperParams = Utils.extend({}, defaults);
            swiper.useModulesParams(swiperParams);
            swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
            swiper.originalParams = Utils.extend({}, swiper.params);
            swiper.passedParams = Utils.extend({}, params);
            swiper.$ = $;
            var $el = $(swiper.params.el);
            el = $el[0];
            if (!el) {
                return undefined;
            }
            if ($el.length > 1) {
                var swipers = [];
                $el.each(function(index, containerEl) {
                    var newParams = Utils.extend({}, params, {
                        el: containerEl
                    });
                    swipers.push(new Swiper(newParams));
                });
                return swipers;
            }
            el.swiper = swiper;
            $el.data("swiper", swiper);
            var $wrapperEl = $el.children("." + swiper.params.wrapperClass);
            Utils.extend(swiper, {
                $el: $el,
                el: el,
                $wrapperEl: $wrapperEl,
                wrapperEl: $wrapperEl[0],
                classNames: [],
                slides: $(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: function isHorizontal() {
                    return swiper.params.direction === "horizontal";
                },
                isVertical: function isVertical() {
                    return swiper.params.direction === "vertical";
                },
                rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
                rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
                wrongRTL: $wrapperEl.css("display") === "-webkit-box",
                activeIndex: 0,
                realIndex: 0,
                isBeginning: true,
                isEnd: false,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: false,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
                touchEvents: function touchEvents() {
                    var touch = [ "touchstart", "touchmove", "touchend" ];
                    var desktop = [ "mousedown", "mousemove", "mouseup" ];
                    if (Support.pointerEvents) {
                        desktop = [ "pointerdown", "pointermove", "pointerup" ];
                    } else if (Support.prefixedPointerEvents) {
                        desktop = [ "MSPointerDown", "MSPointerMove", "MSPointerUp" ];
                    }
                    swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2]
                    };
                    swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2]
                    };
                    return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                }(),
                touchEventsData: {
                    isTouched: undefined,
                    isMoved: undefined,
                    allowTouchCallbacks: undefined,
                    touchStartTime: undefined,
                    isScrolling: undefined,
                    currentTranslate: undefined,
                    startTranslate: undefined,
                    allowThresholdMove: undefined,
                    formElements: "input, select, option, textarea, button, video",
                    lastClickTime: Utils.now(),
                    clickTimeout: undefined,
                    velocities: [],
                    allowMomentumBounce: undefined,
                    isTouchEvent: undefined,
                    startMoving: undefined
                },
                allowClick: true,
                allowTouchMove: swiper.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            });
            swiper.useModules();
            if (swiper.params.init) {
                swiper.init();
            }
            return swiper;
        }
        if (SwiperClass) Swiper.__proto__ = SwiperClass;
        Swiper.prototype = Object.create(SwiperClass && SwiperClass.prototype);
        Swiper.prototype.constructor = Swiper;
        var staticAccessors = {
            extendedDefaults: {
                configurable: true
            },
            defaults: {
                configurable: true
            },
            Class: {
                configurable: true
            },
            $: {
                configurable: true
            }
        };
        Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic() {
            var swiper = this;
            var params = swiper.params;
            var slides = swiper.slides;
            var slidesGrid = swiper.slidesGrid;
            var swiperSize = swiper.size;
            var activeIndex = swiper.activeIndex;
            var spv = 1;
            if (params.centeredSlides) {
                var slideSize = slides[activeIndex].swiperSlideSize;
                var breakLoop;
                for (var i = activeIndex + 1; i < slides.length; i += 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) {
                            breakLoop = true;
                        }
                    }
                }
                for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
                    if (slides[i$1] && !breakLoop) {
                        slideSize += slides[i$1].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) {
                            breakLoop = true;
                        }
                    }
                }
            } else {
                for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
                    if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
                        spv += 1;
                    }
                }
            }
            return spv;
        };
        Swiper.prototype.update = function update() {
            var swiper = this;
            if (!swiper || swiper.destroyed) {
                return;
            }
            var snapGrid = swiper.snapGrid;
            var params = swiper.params;
            if (params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            function setTranslate() {
                var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            var translated;
            if (swiper.params.freeMode) {
                setTranslate();
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            } else {
                if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                    translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                } else {
                    translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                }
                if (!translated) {
                    setTranslate();
                }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                swiper.checkOverflow();
            }
            swiper.emit("update");
        };
        Swiper.prototype.changeDirection = function changeDirection(newDirection, needUpdate) {
            if (needUpdate === void 0) needUpdate = true;
            var swiper = this;
            var currentDirection = swiper.params.direction;
            if (!newDirection) {
                newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
            }
            if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
                return swiper;
            }
            if (currentDirection === "vertical") {
                swiper.$el.removeClass(swiper.params.containerModifierClass + "vertical wp8-vertical").addClass("" + swiper.params.containerModifierClass + newDirection);
                if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                    swiper.$el.addClass(swiper.params.containerModifierClass + "wp8-" + newDirection);
                }
            }
            if (currentDirection === "horizontal") {
                swiper.$el.removeClass(swiper.params.containerModifierClass + "horizontal wp8-horizontal").addClass("" + swiper.params.containerModifierClass + newDirection);
                if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                    swiper.$el.addClass(swiper.params.containerModifierClass + "wp8-" + newDirection);
                }
            }
            swiper.params.direction = newDirection;
            swiper.slides.each(function(slideIndex, slideEl) {
                if (newDirection === "vertical") {
                    slideEl.style.width = "";
                } else {
                    slideEl.style.height = "";
                }
            });
            swiper.emit("changeDirection");
            if (needUpdate) {
                swiper.update();
            }
            return swiper;
        };
        Swiper.prototype.init = function init() {
            var swiper = this;
            if (swiper.initialized) {
                return;
            }
            swiper.emit("beforeInit");
            if (swiper.params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.addClasses();
            if (swiper.params.loop) {
                swiper.loopCreate();
            }
            swiper.updateSize();
            swiper.updateSlides();
            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            }
            if (swiper.params.grabCursor) {
                swiper.setGrabCursor();
            }
            if (swiper.params.preloadImages) {
                swiper.preloadImages();
            }
            if (swiper.params.loop) {
                swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
            } else {
                swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
            }
            swiper.attachEvents();
            swiper.initialized = true;
            swiper.emit("init");
        };
        Swiper.prototype.destroy = function destroy(deleteInstance, cleanStyles) {
            if (deleteInstance === void 0) deleteInstance = true;
            if (cleanStyles === void 0) cleanStyles = true;
            var swiper = this;
            var params = swiper.params;
            var $el = swiper.$el;
            var $wrapperEl = swiper.$wrapperEl;
            var slides = swiper.slides;
            if (typeof swiper.params === "undefined" || swiper.destroyed) {
                return null;
            }
            swiper.emit("beforeDestroy");
            swiper.initialized = false;
            swiper.detachEvents();
            if (params.loop) {
                swiper.loopDestroy();
            }
            if (cleanStyles) {
                swiper.removeClasses();
                $el.removeAttr("style");
                $wrapperEl.removeAttr("style");
                if (slides && slides.length) {
                    slides.removeClass([ params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass ].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index").removeAttr("data-swiper-column").removeAttr("data-swiper-row");
                }
            }
            swiper.emit("destroy");
            Object.keys(swiper.eventsListeners).forEach(function(eventName) {
                swiper.off(eventName);
            });
            if (deleteInstance !== false) {
                swiper.$el[0].swiper = null;
                swiper.$el.data("swiper", null);
                Utils.deleteProps(swiper);
            }
            swiper.destroyed = true;
            return null;
        };
        Swiper.extendDefaults = function extendDefaults(newDefaults) {
            Utils.extend(extendedDefaults, newDefaults);
        };
        staticAccessors.extendedDefaults.get = function() {
            return extendedDefaults;
        };
        staticAccessors.defaults.get = function() {
            return defaults;
        };
        staticAccessors.Class.get = function() {
            return SwiperClass;
        };
        staticAccessors.$.get = function() {
            return $;
        };
        Object.defineProperties(Swiper, staticAccessors);
        return Swiper;
    }(SwiperClass);
    var Device$1 = {
        name: "device",
        proto: {
            device: Device
        },
        "static": {
            device: Device
        }
    };
    var Support$1 = {
        name: "support",
        proto: {
            support: Support
        },
        "static": {
            support: Support
        }
    };
    var Browser$1 = {
        name: "browser",
        proto: {
            browser: Browser
        },
        "static": {
            browser: Browser
        }
    };
    var Resize = {
        name: "resize",
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                resize: {
                    resizeHandler: function resizeHandler() {
                        if (!swiper || swiper.destroyed || !swiper.initialized) {
                            return;
                        }
                        swiper.emit("beforeResize");
                        swiper.emit("resize");
                    },
                    orientationChangeHandler: function orientationChangeHandler() {
                        if (!swiper || swiper.destroyed || !swiper.initialized) {
                            return;
                        }
                        swiper.emit("orientationchange");
                    }
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                win.addEventListener("resize", swiper.resize.resizeHandler);
                win.addEventListener("orientationchange", swiper.resize.orientationChangeHandler);
            },
            destroy: function destroy() {
                var swiper = this;
                win.removeEventListener("resize", swiper.resize.resizeHandler);
                win.removeEventListener("orientationchange", swiper.resize.orientationChangeHandler);
            }
        }
    };
    var Observer = {
        func: win.MutationObserver || win.WebkitMutationObserver,
        attach: function attach(target, options) {
            if (options === void 0) options = {};
            var swiper = this;
            var ObserverFunc = Observer.func;
            var observer = new ObserverFunc(function(mutations) {
                if (mutations.length === 1) {
                    swiper.emit("observerUpdate", mutations[0]);
                    return;
                }
                var observerUpdate = function observerUpdate() {
                    swiper.emit("observerUpdate", mutations[0]);
                };
                if (win.requestAnimationFrame) {
                    win.requestAnimationFrame(observerUpdate);
                } else {
                    win.setTimeout(observerUpdate, 0);
                }
            });
            observer.observe(target, {
                attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                childList: typeof options.childList === "undefined" ? true : options.childList,
                characterData: typeof options.characterData === "undefined" ? true : options.characterData
            });
            swiper.observer.observers.push(observer);
        },
        init: function init() {
            var swiper = this;
            if (!Support.observer || !swiper.params.observer) {
                return;
            }
            if (swiper.params.observeParents) {
                var containerParents = swiper.$el.parents();
                for (var i = 0; i < containerParents.length; i += 1) {
                    swiper.observer.attach(containerParents[i]);
                }
            }
            swiper.observer.attach(swiper.$el[0], {
                childList: swiper.params.observeSlideChildren
            });
            swiper.observer.attach(swiper.$wrapperEl[0], {
                attributes: false
            });
        },
        destroy: function destroy() {
            var swiper = this;
            swiper.observer.observers.forEach(function(observer) {
                observer.disconnect();
            });
            swiper.observer.observers = [];
        }
    };
    var Observer$1 = {
        name: "observer",
        params: {
            observer: false,
            observeParents: false,
            observeSlideChildren: false
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                observer: {
                    init: Observer.init.bind(swiper),
                    attach: Observer.attach.bind(swiper),
                    destroy: Observer.destroy.bind(swiper),
                    observers: []
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.observer.init();
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.observer.destroy();
            }
        }
    };
    var Virtual = {
        update: function update(force) {
            var swiper = this;
            var ref = swiper.params;
            var slidesPerView = ref.slidesPerView;
            var slidesPerGroup = ref.slidesPerGroup;
            var centeredSlides = ref.centeredSlides;
            var ref$1 = swiper.params.virtual;
            var addSlidesBefore = ref$1.addSlidesBefore;
            var addSlidesAfter = ref$1.addSlidesAfter;
            var ref$2 = swiper.virtual;
            var previousFrom = ref$2.from;
            var previousTo = ref$2.to;
            var slides = ref$2.slides;
            var previousSlidesGrid = ref$2.slidesGrid;
            var renderSlide = ref$2.renderSlide;
            var previousOffset = ref$2.offset;
            swiper.updateActiveIndex();
            var activeIndex = swiper.activeIndex || 0;
            var offsetProp;
            if (swiper.rtlTranslate) {
                offsetProp = "right";
            } else {
                offsetProp = swiper.isHorizontal() ? "left" : "top";
            }
            var slidesAfter;
            var slidesBefore;
            if (centeredSlides) {
                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
            } else {
                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
                slidesBefore = slidesPerGroup + addSlidesAfter;
            }
            var from = Math.max((activeIndex || 0) - slidesBefore, 0);
            var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
            var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
            Utils.extend(swiper.virtual, {
                from: from,
                to: to,
                offset: offset,
                slidesGrid: swiper.slidesGrid
            });
            function onRendered() {
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                if (swiper.lazy && swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            }
            if (previousFrom === from && previousTo === to && !force) {
                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                    swiper.slides.css(offsetProp, offset + "px");
                }
                swiper.updateProgress();
                return;
            }
            if (swiper.params.virtual.renderExternal) {
                swiper.params.virtual.renderExternal.call(swiper, {
                    offset: offset,
                    from: from,
                    to: to,
                    slides: function getSlides() {
                        var slidesToRender = [];
                        for (var i = from; i <= to; i += 1) {
                            slidesToRender.push(slides[i]);
                        }
                        return slidesToRender;
                    }()
                });
                onRendered();
                return;
            }
            var prependIndexes = [];
            var appendIndexes = [];
            if (force) {
                swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
            } else {
                for (var i = previousFrom; i <= previousTo; i += 1) {
                    if (i < from || i > to) {
                        swiper.$wrapperEl.find("." + swiper.params.slideClass + '[data-swiper-slide-index="' + i + '"]').remove();
                    }
                }
            }
            for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
                if (i$1 >= from && i$1 <= to) {
                    if (typeof previousTo === "undefined" || force) {
                        appendIndexes.push(i$1);
                    } else {
                        if (i$1 > previousTo) {
                            appendIndexes.push(i$1);
                        }
                        if (i$1 < previousFrom) {
                            prependIndexes.push(i$1);
                        }
                    }
                }
            }
            appendIndexes.forEach(function(index) {
                swiper.$wrapperEl.append(renderSlide(slides[index], index));
            });
            prependIndexes.sort(function(a, b) {
                return b - a;
            }).forEach(function(index) {
                swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
            });
            swiper.$wrapperEl.children(".swiper-slide").css(offsetProp, offset + "px");
            onRendered();
        },
        renderSlide: function renderSlide(slide, index) {
            var swiper = this;
            var params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index]) {
                return swiper.virtual.cache[index];
            }
            var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $('<div class="' + swiper.params.slideClass + '" data-swiper-slide-index="' + index + '">' + slide + "</div>");
            if (!$slideEl.attr("data-swiper-slide-index")) {
                $slideEl.attr("data-swiper-slide-index", index);
            }
            if (params.cache) {
                swiper.virtual.cache[index] = $slideEl;
            }
            return $slideEl;
        },
        appendSlide: function appendSlide(slides) {
            var swiper = this;
            if (typeof slides === "object" && "length" in slides) {
                for (var i = 0; i < slides.length; i += 1) {
                    if (slides[i]) {
                        swiper.virtual.slides.push(slides[i]);
                    }
                }
            } else {
                swiper.virtual.slides.push(slides);
            }
            swiper.virtual.update(true);
        },
        prependSlide: function prependSlide(slides) {
            var swiper = this;
            var activeIndex = swiper.activeIndex;
            var newActiveIndex = activeIndex + 1;
            var numberOfNewSlides = 1;
            if (Array.isArray(slides)) {
                for (var i = 0; i < slides.length; i += 1) {
                    if (slides[i]) {
                        swiper.virtual.slides.unshift(slides[i]);
                    }
                }
                newActiveIndex = activeIndex + slides.length;
                numberOfNewSlides = slides.length;
            } else {
                swiper.virtual.slides.unshift(slides);
            }
            if (swiper.params.virtual.cache) {
                var cache = swiper.virtual.cache;
                var newCache = {};
                Object.keys(cache).forEach(function(cachedIndex) {
                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];
                });
                swiper.virtual.cache = newCache;
            }
            swiper.virtual.update(true);
            swiper.slideTo(newActiveIndex, 0);
        },
        removeSlide: function removeSlide(slidesIndexes) {
            var swiper = this;
            if (typeof slidesIndexes === "undefined" || slidesIndexes === null) {
                return;
            }
            var activeIndex = swiper.activeIndex;
            if (Array.isArray(slidesIndexes)) {
                for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                    swiper.virtual.slides.splice(slidesIndexes[i], 1);
                    if (swiper.params.virtual.cache) {
                        delete swiper.virtual.cache[slidesIndexes[i]];
                    }
                    if (slidesIndexes[i] < activeIndex) {
                        activeIndex -= 1;
                    }
                    activeIndex = Math.max(activeIndex, 0);
                }
            } else {
                swiper.virtual.slides.splice(slidesIndexes, 1);
                if (swiper.params.virtual.cache) {
                    delete swiper.virtual.cache[slidesIndexes];
                }
                if (slidesIndexes < activeIndex) {
                    activeIndex -= 1;
                }
                activeIndex = Math.max(activeIndex, 0);
            }
            swiper.virtual.update(true);
            swiper.slideTo(activeIndex, 0);
        },
        removeAllSlides: function removeAllSlides() {
            var swiper = this;
            swiper.virtual.slides = [];
            if (swiper.params.virtual.cache) {
                swiper.virtual.cache = {};
            }
            swiper.virtual.update(true);
            swiper.slideTo(0, 0);
        }
    };
    var Virtual$1 = {
        name: "virtual",
        params: {
            virtual: {
                enabled: false,
                slides: [],
                cache: true,
                renderSlide: null,
                renderExternal: null,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                virtual: {
                    update: Virtual.update.bind(swiper),
                    appendSlide: Virtual.appendSlide.bind(swiper),
                    prependSlide: Virtual.prependSlide.bind(swiper),
                    removeSlide: Virtual.removeSlide.bind(swiper),
                    removeAllSlides: Virtual.removeAllSlides.bind(swiper),
                    renderSlide: Virtual.renderSlide.bind(swiper),
                    slides: swiper.params.virtual.slides,
                    cache: {}
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (!swiper.params.virtual.enabled) {
                    return;
                }
                swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
                var overwriteParams = {
                    watchSlidesProgress: true
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
                if (!swiper.params.initialSlide) {
                    swiper.virtual.update();
                }
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (!swiper.params.virtual.enabled) {
                    return;
                }
                swiper.virtual.update();
            }
        }
    };
    var Keyboard = {
        handle: function handle(event) {
            var swiper = this;
            var rtl = swiper.rtlTranslate;
            var e = event;
            if (e.originalEvent) {
                e = e.originalEvent;
            }
            var kc = e.keyCode || e.charCode;
            if (!swiper.allowSlideNext && (swiper.isHorizontal() && kc === 39 || swiper.isVertical() && kc === 40)) {
                return false;
            }
            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && kc === 37 || swiper.isVertical() && kc === 38)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return undefined;
            }
            if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === "input" || doc.activeElement.nodeName.toLowerCase() === "textarea")) {
                return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
                var inView = false;
                if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
                    return undefined;
                }
                var windowWidth = win.innerWidth;
                var windowHeight = win.innerHeight;
                var swiperOffset = swiper.$el.offset();
                if (rtl) {
                    swiperOffset.left -= swiper.$el[0].scrollLeft;
                }
                var swiperCoord = [ [ swiperOffset.left, swiperOffset.top ], [ swiperOffset.left + swiper.width, swiperOffset.top ], [ swiperOffset.left, swiperOffset.top + swiper.height ], [ swiperOffset.left + swiper.width, swiperOffset.top + swiper.height ] ];
                for (var i = 0; i < swiperCoord.length; i += 1) {
                    var point = swiperCoord[i];
                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                        inView = true;
                    }
                }
                if (!inView) {
                    return undefined;
                }
            }
            if (swiper.isHorizontal()) {
                if (kc === 37 || kc === 39) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                }
                if (kc === 39 && !rtl || kc === 37 && rtl) {
                    swiper.slideNext();
                }
                if (kc === 37 && !rtl || kc === 39 && rtl) {
                    swiper.slidePrev();
                }
            } else {
                if (kc === 38 || kc === 40) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                }
                if (kc === 40) {
                    swiper.slideNext();
                }
                if (kc === 38) {
                    swiper.slidePrev();
                }
            }
            swiper.emit("keyPress", kc);
            return undefined;
        },
        enable: function enable() {
            var swiper = this;
            if (swiper.keyboard.enabled) {
                return;
            }
            $(doc).on("keydown", swiper.keyboard.handle);
            swiper.keyboard.enabled = true;
        },
        disable: function disable() {
            var swiper = this;
            if (!swiper.keyboard.enabled) {
                return;
            }
            $(doc).off("keydown", swiper.keyboard.handle);
            swiper.keyboard.enabled = false;
        }
    };
    var Keyboard$1 = {
        name: "keyboard",
        params: {
            keyboard: {
                enabled: false,
                onlyInViewport: true
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                keyboard: {
                    enabled: false,
                    enable: Keyboard.enable.bind(swiper),
                    disable: Keyboard.disable.bind(swiper),
                    handle: Keyboard.handle.bind(swiper)
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.keyboard.enabled) {
                    swiper.keyboard.enable();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.keyboard.enabled) {
                    swiper.keyboard.disable();
                }
            }
        }
    };
    function isEventSupported() {
        var eventName = "onwheel";
        var isSupported = eventName in doc;
        if (!isSupported) {
            var element = doc.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
        }
        if (!isSupported && doc.implementation && doc.implementation.hasFeature && doc.implementation.hasFeature("", "") !== true) {
            isSupported = doc.implementation.hasFeature("Events.wheel", "3.0");
        }
        return isSupported;
    }
    var Mousewheel = {
        lastScrollTime: Utils.now(),
        event: function getEvent() {
            if (win.navigator.userAgent.indexOf("firefox") > -1) {
                return "DOMMouseScroll";
            }
            return isEventSupported() ? "wheel" : "mousewheel";
        }(),
        normalize: function normalize(e) {
            var PIXEL_STEP = 10;
            var LINE_HEIGHT = 40;
            var PAGE_HEIGHT = 800;
            var sX = 0;
            var sY = 0;
            var pX = 0;
            var pY = 0;
            if ("detail" in e) {
                sY = e.detail;
            }
            if ("wheelDelta" in e) {
                sY = -e.wheelDelta / 120;
            }
            if ("wheelDeltaY" in e) {
                sY = -e.wheelDeltaY / 120;
            }
            if ("wheelDeltaX" in e) {
                sX = -e.wheelDeltaX / 120;
            }
            if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                sX = sY;
                sY = 0;
            }
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
            if ("deltaY" in e) {
                pY = e.deltaY;
            }
            if ("deltaX" in e) {
                pX = e.deltaX;
            }
            if ((pX || pY) && e.deltaMode) {
                if (e.deltaMode === 1) {
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }
            if (pX && !sX) {
                sX = pX < 1 ? -1 : 1;
            }
            if (pY && !sY) {
                sY = pY < 1 ? -1 : 1;
            }
            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        },
        handleMouseEnter: function handleMouseEnter() {
            var swiper = this;
            swiper.mouseEntered = true;
        },
        handleMouseLeave: function handleMouseLeave() {
            var swiper = this;
            swiper.mouseEntered = false;
        },
        handle: function handle(event) {
            var e = event;
            var swiper = this;
            var params = swiper.params.mousewheel;
            if (!swiper.mouseEntered && !params.releaseOnEdges) {
                return true;
            }
            if (e.originalEvent) {
                e = e.originalEvent;
            }
            var delta = 0;
            var rtlFactor = swiper.rtlTranslate ? -1 : 1;
            var data = Mousewheel.normalize(e);
            if (params.forceToAxis) {
                if (swiper.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) {
                        delta = data.pixelX * rtlFactor;
                    } else {
                        return true;
                    }
                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) {
                    delta = data.pixelY;
                } else {
                    return true;
                }
            } else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }
            if (delta === 0) {
                return true;
            }
            if (params.invert) {
                delta = -delta;
            }
            if (!swiper.params.freeMode) {
                if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
                    if (delta < 0) {
                        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                            swiper.slideNext();
                            swiper.emit("scroll", e);
                        } else if (params.releaseOnEdges) {
                            return true;
                        }
                    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                        swiper.slidePrev();
                        swiper.emit("scroll", e);
                    } else if (params.releaseOnEdges) {
                        return true;
                    }
                }
                swiper.mousewheel.lastScrollTime = new win.Date().getTime();
            } else {
                if (swiper.params.loop) {
                    swiper.loopFix();
                }
                var position = swiper.getTranslate() + delta * params.sensitivity;
                var wasBeginning = swiper.isBeginning;
                var wasEnd = swiper.isEnd;
                if (position >= swiper.minTranslate()) {
                    position = swiper.minTranslate();
                }
                if (position <= swiper.maxTranslate()) {
                    position = swiper.maxTranslate();
                }
                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
                if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                    swiper.updateSlidesClasses();
                }
                if (swiper.params.freeModeSticky) {
                    clearTimeout(swiper.mousewheel.timeout);
                    swiper.mousewheel.timeout = Utils.nextTick(function() {
                        swiper.slideToClosest();
                    }, 300);
                }
                swiper.emit("scroll", e);
                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) {
                    swiper.autoplay.stop();
                }
                if (position === swiper.minTranslate() || position === swiper.maxTranslate()) {
                    return true;
                }
            }
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return false;
        },
        enable: function enable() {
            var swiper = this;
            if (!Mousewheel.event) {
                return false;
            }
            if (swiper.mousewheel.enabled) {
                return false;
            }
            var target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== "container") {
                target = $(swiper.params.mousewheel.eventsTarged);
            }
            target.on("mouseenter", swiper.mousewheel.handleMouseEnter);
            target.on("mouseleave", swiper.mousewheel.handleMouseLeave);
            target.on(Mousewheel.event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = true;
            return true;
        },
        disable: function disable() {
            var swiper = this;
            if (!Mousewheel.event) {
                return false;
            }
            if (!swiper.mousewheel.enabled) {
                return false;
            }
            var target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== "container") {
                target = $(swiper.params.mousewheel.eventsTarged);
            }
            target.off(Mousewheel.event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = false;
            return true;
        }
    };
    var Mousewheel$1 = {
        name: "mousewheel",
        params: {
            mousewheel: {
                enabled: false,
                releaseOnEdges: false,
                invert: false,
                forceToAxis: false,
                sensitivity: 1,
                eventsTarged: "container"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                mousewheel: {
                    enabled: false,
                    enable: Mousewheel.enable.bind(swiper),
                    disable: Mousewheel.disable.bind(swiper),
                    handle: Mousewheel.handle.bind(swiper),
                    handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
                    handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
                    lastScrollTime: Utils.now()
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.mousewheel.enabled) {
                    swiper.mousewheel.enable();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.mousewheel.enabled) {
                    swiper.mousewheel.disable();
                }
            }
        }
    };
    var Navigation = {
        update: function update() {
            var swiper = this;
            var params = swiper.params.navigation;
            if (swiper.params.loop) {
                return;
            }
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;
            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    $prevEl.addClass(params.disabledClass);
                } else {
                    $prevEl.removeClass(params.disabledClass);
                }
                $prevEl[swiper.params.watchOverflow && swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    $nextEl.addClass(params.disabledClass);
                } else {
                    $nextEl.removeClass(params.disabledClass);
                }
                $nextEl[swiper.params.watchOverflow && swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
        },
        onPrevClick: function onPrevClick(e) {
            var swiper = this;
            e.preventDefault();
            if (swiper.isBeginning && !swiper.params.loop) {
                return;
            }
            swiper.slidePrev();
        },
        onNextClick: function onNextClick(e) {
            var swiper = this;
            e.preventDefault();
            if (swiper.isEnd && !swiper.params.loop) {
                return;
            }
            swiper.slideNext();
        },
        init: function init() {
            var swiper = this;
            var params = swiper.params.navigation;
            if (!(params.nextEl || params.prevEl)) {
                return;
            }
            var $nextEl;
            var $prevEl;
            if (params.nextEl) {
                $nextEl = $(params.nextEl);
                if (swiper.params.uniqueNavElements && typeof params.nextEl === "string" && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
                    $nextEl = swiper.$el.find(params.nextEl);
                }
            }
            if (params.prevEl) {
                $prevEl = $(params.prevEl);
                if (swiper.params.uniqueNavElements && typeof params.prevEl === "string" && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
                    $prevEl = swiper.$el.find(params.prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                $nextEl.on("click", swiper.navigation.onNextClick);
            }
            if ($prevEl && $prevEl.length > 0) {
                $prevEl.on("click", swiper.navigation.onPrevClick);
            }
            Utils.extend(swiper.navigation, {
                $nextEl: $nextEl,
                nextEl: $nextEl && $nextEl[0],
                $prevEl: $prevEl,
                prevEl: $prevEl && $prevEl[0]
            });
        },
        destroy: function destroy() {
            var swiper = this;
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;
            if ($nextEl && $nextEl.length) {
                $nextEl.off("click", swiper.navigation.onNextClick);
                $nextEl.removeClass(swiper.params.navigation.disabledClass);
            }
            if ($prevEl && $prevEl.length) {
                $prevEl.off("click", swiper.navigation.onPrevClick);
                $prevEl.removeClass(swiper.params.navigation.disabledClass);
            }
        }
    };
    var Navigation$1 = {
        name: "navigation",
        params: {
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: false,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                navigation: {
                    init: Navigation.init.bind(swiper),
                    update: Navigation.update.bind(swiper),
                    destroy: Navigation.destroy.bind(swiper),
                    onNextClick: Navigation.onNextClick.bind(swiper),
                    onPrevClick: Navigation.onPrevClick.bind(swiper)
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.navigation.init();
                swiper.navigation.update();
            },
            toEdge: function toEdge() {
                var swiper = this;
                swiper.navigation.update();
            },
            fromEdge: function fromEdge() {
                var swiper = this;
                swiper.navigation.update();
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.navigation.destroy();
            },
            click: function click(e) {
                var swiper = this;
                var ref = swiper.navigation;
                var $nextEl = ref.$nextEl;
                var $prevEl = ref.$prevEl;
                if (swiper.params.navigation.hideOnClick && !$(e.target).is($prevEl) && !$(e.target).is($nextEl)) {
                    var isHidden;
                    if ($nextEl) {
                        isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
                    } else if ($prevEl) {
                        isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                    }
                    if (isHidden === true) {
                        swiper.emit("navigationShow", swiper);
                    } else {
                        swiper.emit("navigationHide", swiper);
                    }
                    if ($nextEl) {
                        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                    }
                    if ($prevEl) {
                        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                    }
                }
            }
        }
    };
    var Pagination = {
        update: function update() {
            var swiper = this;
            var rtl = swiper.rtl;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
                return;
            }
            var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            var $el = swiper.pagination.$el;
            var current;
            var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
                current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
                    current -= slidesLength - swiper.loopedSlides * 2;
                }
                if (current > total - 1) {
                    current -= total;
                }
                if (current < 0 && swiper.params.paginationType !== "bullets") {
                    current = total + current;
                }
            } else if (typeof swiper.snapIndex !== "undefined") {
                current = swiper.snapIndex;
            } else {
                current = swiper.activeIndex || 0;
            }
            if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                var bullets = swiper.pagination.bullets;
                var firstIndex;
                var lastIndex;
                var midIndex;
                if (params.dynamicBullets) {
                    swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
                    $el.css(swiper.isHorizontal() ? "width" : "height", swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");
                    if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                        swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;
                        if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
                        } else if (swiper.pagination.dynamicBulletIndex < 0) {
                            swiper.pagination.dynamicBulletIndex = 0;
                        }
                    }
                    firstIndex = current - swiper.pagination.dynamicBulletIndex;
                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                    midIndex = (lastIndex + firstIndex) / 2;
                }
                bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");
                if ($el.length > 1) {
                    bullets.each(function(index, bullet) {
                        var $bullet = $(bullet);
                        var bulletIndex = $bullet.index();
                        if (bulletIndex === current) {
                            $bullet.addClass(params.bulletActiveClass);
                        }
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                $bullet.addClass(params.bulletActiveClass + "-main");
                            }
                            if (bulletIndex === firstIndex) {
                                $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                            }
                            if (bulletIndex === lastIndex) {
                                $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                            }
                        }
                    });
                } else {
                    var $bullet = bullets.eq(current);
                    $bullet.addClass(params.bulletActiveClass);
                    if (params.dynamicBullets) {
                        var $firstDisplayedBullet = bullets.eq(firstIndex);
                        var $lastDisplayedBullet = bullets.eq(lastIndex);
                        for (var i = firstIndex; i <= lastIndex; i += 1) {
                            bullets.eq(i).addClass(params.bulletActiveClass + "-main");
                        }
                        $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                        $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                    }
                }
                if (params.dynamicBullets) {
                    var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                    var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
                    var offsetProp = rtl ? "right" : "left";
                    bullets.css(swiper.isHorizontal() ? offsetProp : "top", bulletsOffset + "px");
                }
            }
            if (params.type === "fraction") {
                $el.find("." + params.currentClass).text(params.formatFractionCurrent(current + 1));
                $el.find("." + params.totalClass).text(params.formatFractionTotal(total));
            }
            if (params.type === "progressbar") {
                var progressbarDirection;
                if (params.progressbarOpposite) {
                    progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
                } else {
                    progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                }
                var scale = (current + 1) / total;
                var scaleX = 1;
                var scaleY = 1;
                if (progressbarDirection === "horizontal") {
                    scaleX = scale;
                } else {
                    scaleY = scale;
                }
                $el.find("." + params.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
            }
            if (params.type === "custom" && params.renderCustom) {
                $el.html(params.renderCustom(swiper, current + 1, total));
                swiper.emit("paginationRender", swiper, $el[0]);
            } else {
                swiper.emit("paginationUpdate", swiper, $el[0]);
            }
            $el[swiper.params.watchOverflow && swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
        },
        render: function render() {
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
                return;
            }
            var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            var $el = swiper.pagination.$el;
            var paginationHTML = "";
            if (params.type === "bullets") {
                var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                for (var i = 0; i < numberOfBullets; i += 1) {
                    if (params.renderBullet) {
                        paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                    } else {
                        paginationHTML += "<" + params.bulletElement + ' class="' + params.bulletClass + '"></' + params.bulletElement + ">";
                    }
                }
                $el.html(paginationHTML);
                swiper.pagination.bullets = $el.find("." + params.bulletClass);
            }
            if (params.type === "fraction") {
                if (params.renderFraction) {
                    paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
                } else {
                    paginationHTML = '<span class="' + params.currentClass + '"></span>' + " / " + '<span class="' + params.totalClass + '"></span>';
                }
                $el.html(paginationHTML);
            }
            if (params.type === "progressbar") {
                if (params.renderProgressbar) {
                    paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
                } else {
                    paginationHTML = '<span class="' + params.progressbarFillClass + '"></span>';
                }
                $el.html(paginationHTML);
            }
            if (params.type !== "custom") {
                swiper.emit("paginationRender", swiper.pagination.$el[0]);
            }
        },
        init: function init() {
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el) {
                return;
            }
            var $el = $(params.el);
            if ($el.length === 0) {
                return;
            }
            if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1 && swiper.$el.find(params.el).length === 1) {
                $el = swiper.$el.find(params.el);
            }
            if (params.type === "bullets" && params.clickable) {
                $el.addClass(params.clickableClass);
            }
            $el.addClass(params.modifierClass + params.type);
            if (params.type === "bullets" && params.dynamicBullets) {
                $el.addClass("" + params.modifierClass + params.type + "-dynamic");
                swiper.pagination.dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                    params.dynamicMainBullets = 1;
                }
            }
            if (params.type === "progressbar" && params.progressbarOpposite) {
                $el.addClass(params.progressbarOppositeClass);
            }
            if (params.clickable) {
                $el.on("click", "." + params.bulletClass, function onClick(e) {
                    e.preventDefault();
                    var index = $(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) {
                        index += swiper.loopedSlides;
                    }
                    swiper.slideTo(index);
                });
            }
            Utils.extend(swiper.pagination, {
                $el: $el,
                el: $el[0]
            });
        },
        destroy: function destroy() {
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
                return;
            }
            var $el = swiper.pagination.$el;
            $el.removeClass(params.hiddenClass);
            $el.removeClass(params.modifierClass + params.type);
            if (swiper.pagination.bullets) {
                swiper.pagination.bullets.removeClass(params.bulletActiveClass);
            }
            if (params.clickable) {
                $el.off("click", "." + params.bulletClass);
            }
        }
    };
    var Pagination$1 = {
        name: "pagination",
        params: {
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: false,
                hideOnClick: false,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: false,
                type: "bullets",
                dynamicBullets: false,
                dynamicMainBullets: 1,
                formatFractionCurrent: function(number) {
                    return number;
                },
                formatFractionTotal: function(number) {
                    return number;
                },
                bulletClass: "swiper-pagination-bullet",
                bulletActiveClass: "swiper-pagination-bullet-active",
                modifierClass: "swiper-pagination-",
                currentClass: "swiper-pagination-current",
                totalClass: "swiper-pagination-total",
                hiddenClass: "swiper-pagination-hidden",
                progressbarFillClass: "swiper-pagination-progressbar-fill",
                progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
                clickableClass: "swiper-pagination-clickable",
                lockClass: "swiper-pagination-lock"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                pagination: {
                    init: Pagination.init.bind(swiper),
                    render: Pagination.render.bind(swiper),
                    update: Pagination.update.bind(swiper),
                    destroy: Pagination.destroy.bind(swiper),
                    dynamicBulletIndex: 0
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.pagination.init();
                swiper.pagination.render();
                swiper.pagination.update();
            },
            activeIndexChange: function activeIndexChange() {
                var swiper = this;
                if (swiper.params.loop) {
                    swiper.pagination.update();
                } else if (typeof swiper.snapIndex === "undefined") {
                    swiper.pagination.update();
                }
            },
            snapIndexChange: function snapIndexChange() {
                var swiper = this;
                if (!swiper.params.loop) {
                    swiper.pagination.update();
                }
            },
            slidesLengthChange: function slidesLengthChange() {
                var swiper = this;
                if (swiper.params.loop) {
                    swiper.pagination.render();
                    swiper.pagination.update();
                }
            },
            snapGridLengthChange: function snapGridLengthChange() {
                var swiper = this;
                if (!swiper.params.loop) {
                    swiper.pagination.render();
                    swiper.pagination.update();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.pagination.destroy();
            },
            click: function click(e) {
                var swiper = this;
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(e.target).hasClass(swiper.params.pagination.bulletClass)) {
                    var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
                    if (isHidden === true) {
                        swiper.emit("paginationShow", swiper);
                    } else {
                        swiper.emit("paginationHide", swiper);
                    }
                    swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
                }
            }
        }
    };
    var Scrollbar = {
        setTranslate: function setTranslate() {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var rtl = swiper.rtlTranslate;
            var progress = swiper.progress;
            var dragSize = scrollbar.dragSize;
            var trackSize = scrollbar.trackSize;
            var $dragEl = scrollbar.$dragEl;
            var $el = scrollbar.$el;
            var params = swiper.params.scrollbar;
            var newSize = dragSize;
            var newPos = (trackSize - dragSize) * progress;
            if (rtl) {
                newPos = -newPos;
                if (newPos > 0) {
                    newSize = dragSize - newPos;
                    newPos = 0;
                } else if (-newPos + dragSize > trackSize) {
                    newSize = trackSize + newPos;
                }
            } else if (newPos < 0) {
                newSize = dragSize + newPos;
                newPos = 0;
            } else if (newPos + dragSize > trackSize) {
                newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
                if (Support.transforms3d) {
                    $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
                } else {
                    $dragEl.transform("translateX(" + newPos + "px)");
                }
                $dragEl[0].style.width = newSize + "px";
            } else {
                if (Support.transforms3d) {
                    $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
                } else {
                    $dragEl.transform("translateY(" + newPos + "px)");
                }
                $dragEl[0].style.height = newSize + "px";
            }
            if (params.hide) {
                clearTimeout(swiper.scrollbar.timeout);
                $el[0].style.opacity = 1;
                swiper.scrollbar.timeout = setTimeout(function() {
                    $el[0].style.opacity = 0;
                    $el.transition(400);
                }, 1e3);
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
                return;
            }
            swiper.scrollbar.$dragEl.transition(duration);
        },
        updateSize: function updateSize() {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var $dragEl = scrollbar.$dragEl;
            var $el = scrollbar.$el;
            $dragEl[0].style.width = "";
            $dragEl[0].style.height = "";
            var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
            var divider = swiper.size / swiper.virtualSize;
            var moveDivider = divider * (trackSize / swiper.size);
            var dragSize;
            if (swiper.params.scrollbar.dragSize === "auto") {
                dragSize = trackSize * divider;
            } else {
                dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }
            if (swiper.isHorizontal()) {
                $dragEl[0].style.width = dragSize + "px";
            } else {
                $dragEl[0].style.height = dragSize + "px";
            }
            if (divider >= 1) {
                $el[0].style.display = "none";
            } else {
                $el[0].style.display = "";
            }
            if (swiper.params.scrollbar.hide) {
                $el[0].style.opacity = 0;
            }
            Utils.extend(scrollbar, {
                trackSize: trackSize,
                divider: divider,
                moveDivider: moveDivider,
                dragSize: dragSize
            });
            scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? "addClass" : "removeClass"](swiper.params.scrollbar.lockClass);
        },
        setDragPosition: function setDragPosition(e) {
            var swiper = this;
            var scrollbar = swiper.scrollbar;
            var rtl = swiper.rtlTranslate;
            var $el = scrollbar.$el;
            var dragSize = scrollbar.dragSize;
            var trackSize = scrollbar.trackSize;
            var pointerPosition;
            if (swiper.isHorizontal()) {
                pointerPosition = e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX || e.clientX;
            } else {
                pointerPosition = e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY || e.clientY;
            }
            var positionRatio;
            positionRatio = (pointerPosition - $el.offset()[swiper.isHorizontal() ? "left" : "top"] - dragSize / 2) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
                positionRatio = 1 - positionRatio;
            }
            var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        },
        onDragStart: function onDragStart(e) {
            var swiper = this;
            var params = swiper.params.scrollbar;
            var scrollbar = swiper.scrollbar;
            var $wrapperEl = swiper.$wrapperEl;
            var $el = scrollbar.$el;
            var $dragEl = scrollbar.$dragEl;
            swiper.scrollbar.isTouched = true;
            e.preventDefault();
            e.stopPropagation();
            $wrapperEl.transition(100);
            $dragEl.transition(100);
            scrollbar.setDragPosition(e);
            clearTimeout(swiper.scrollbar.dragTimeout);
            $el.transition(0);
            if (params.hide) {
                $el.css("opacity", 1);
            }
            swiper.emit("scrollbarDragStart", e);
        },
        onDragMove: function onDragMove(e) {
            var swiper = this;
            var scrollbar = swiper.scrollbar;
            var $wrapperEl = swiper.$wrapperEl;
            var $el = scrollbar.$el;
            var $dragEl = scrollbar.$dragEl;
            if (!swiper.scrollbar.isTouched) {
                return;
            }
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            scrollbar.setDragPosition(e);
            $wrapperEl.transition(0);
            $el.transition(0);
            $dragEl.transition(0);
            swiper.emit("scrollbarDragMove", e);
        },
        onDragEnd: function onDragEnd(e) {
            var swiper = this;
            var params = swiper.params.scrollbar;
            var scrollbar = swiper.scrollbar;
            var $el = scrollbar.$el;
            if (!swiper.scrollbar.isTouched) {
                return;
            }
            swiper.scrollbar.isTouched = false;
            if (params.hide) {
                clearTimeout(swiper.scrollbar.dragTimeout);
                swiper.scrollbar.dragTimeout = Utils.nextTick(function() {
                    $el.css("opacity", 0);
                    $el.transition(400);
                }, 1e3);
            }
            swiper.emit("scrollbarDragEnd", e);
            if (params.snapOnRelease) {
                swiper.slideToClosest();
            }
        },
        enableDraggable: function enableDraggable() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var touchEventsTouch = swiper.touchEventsTouch;
            var touchEventsDesktop = swiper.touchEventsDesktop;
            var params = swiper.params;
            var $el = scrollbar.$el;
            var target = $el[0];
            var activeListener = Support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            var passiveListener = Support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!Support.touch) {
                target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
                doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
                doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
                target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
                target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
                target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
            }
        },
        disableDraggable: function disableDraggable() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var touchEventsTouch = swiper.touchEventsTouch;
            var touchEventsDesktop = swiper.touchEventsDesktop;
            var params = swiper.params;
            var $el = scrollbar.$el;
            var target = $el[0];
            var activeListener = Support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            var passiveListener = Support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!Support.touch) {
                target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
                doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
                doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
                target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
                target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
                target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
            }
        },
        init: function init() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var $swiperEl = swiper.$el;
            var params = swiper.params.scrollbar;
            var $el = $(params.el);
            if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
                $el = $swiperEl.find(params.el);
            }
            var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);
            if ($dragEl.length === 0) {
                $dragEl = $('<div class="' + swiper.params.scrollbar.dragClass + '"></div>');
                $el.append($dragEl);
            }
            Utils.extend(scrollbar, {
                $el: $el,
                el: $el[0],
                $dragEl: $dragEl,
                dragEl: $dragEl[0]
            });
            if (params.draggable) {
                scrollbar.enableDraggable();
            }
        },
        destroy: function destroy() {
            var swiper = this;
            swiper.scrollbar.disableDraggable();
        }
    };
    var Scrollbar$1 = {
        name: "scrollbar",
        params: {
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: false,
                draggable: false,
                snapOnRelease: true,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                scrollbar: {
                    init: Scrollbar.init.bind(swiper),
                    destroy: Scrollbar.destroy.bind(swiper),
                    updateSize: Scrollbar.updateSize.bind(swiper),
                    setTranslate: Scrollbar.setTranslate.bind(swiper),
                    setTransition: Scrollbar.setTransition.bind(swiper),
                    enableDraggable: Scrollbar.enableDraggable.bind(swiper),
                    disableDraggable: Scrollbar.disableDraggable.bind(swiper),
                    setDragPosition: Scrollbar.setDragPosition.bind(swiper),
                    onDragStart: Scrollbar.onDragStart.bind(swiper),
                    onDragMove: Scrollbar.onDragMove.bind(swiper),
                    onDragEnd: Scrollbar.onDragEnd.bind(swiper),
                    isTouched: false,
                    timeout: null,
                    dragTimeout: null
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.scrollbar.init();
                swiper.scrollbar.updateSize();
                swiper.scrollbar.setTranslate();
            },
            update: function update() {
                var swiper = this;
                swiper.scrollbar.updateSize();
            },
            resize: function resize() {
                var swiper = this;
                swiper.scrollbar.updateSize();
            },
            observerUpdate: function observerUpdate() {
                var swiper = this;
                swiper.scrollbar.updateSize();
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                swiper.scrollbar.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                swiper.scrollbar.setTransition(duration);
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.scrollbar.destroy();
            }
        }
    };
    var Parallax = {
        setTransform: function setTransform(el, progress) {
            var swiper = this;
            var rtl = swiper.rtl;
            var $el = $(el);
            var rtlFactor = rtl ? -1 : 1;
            var p = $el.attr("data-swiper-parallax") || "0";
            var x = $el.attr("data-swiper-parallax-x");
            var y = $el.attr("data-swiper-parallax-y");
            var scale = $el.attr("data-swiper-parallax-scale");
            var opacity = $el.attr("data-swiper-parallax-opacity");
            if (x || y) {
                x = x || "0";
                y = y || "0";
            } else if (swiper.isHorizontal()) {
                x = p;
                y = "0";
            } else {
                y = p;
                x = "0";
            }
            if (x.indexOf("%") >= 0) {
                x = parseInt(x, 10) * progress * rtlFactor + "%";
            } else {
                x = x * progress * rtlFactor + "px";
            }
            if (y.indexOf("%") >= 0) {
                y = parseInt(y, 10) * progress + "%";
            } else {
                y = y * progress + "px";
            }
            if (typeof opacity !== "undefined" && opacity !== null) {
                var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
                $el[0].style.opacity = currentOpacity;
            }
            if (typeof scale === "undefined" || scale === null) {
                $el.transform("translate3d(" + x + ", " + y + ", 0px)");
            } else {
                var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
                $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
            }
        },
        setTranslate: function setTranslate() {
            var swiper = this;
            var $el = swiper.$el;
            var slides = swiper.slides;
            var progress = swiper.progress;
            var snapGrid = swiper.snapGrid;
            $el.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function(index, el) {
                swiper.parallax.setTransform(el, progress);
            });
            slides.each(function(slideIndex, slideEl) {
                var slideProgress = slideEl.progress;
                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
                    slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
                }
                slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                $(slideEl).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function(index, el) {
                    swiper.parallax.setTransform(el, slideProgress);
                });
            });
        },
        setTransition: function setTransition(duration) {
            if (duration === void 0) duration = this.params.speed;
            var swiper = this;
            var $el = swiper.$el;
            $el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function(index, parallaxEl) {
                var $parallaxEl = $(parallaxEl);
                var parallaxDuration = parseInt($parallaxEl.attr("data-swiper-parallax-duration"), 10) || duration;
                if (duration === 0) {
                    parallaxDuration = 0;
                }
                $parallaxEl.transition(parallaxDuration);
            });
        }
    };
    var Parallax$1 = {
        name: "parallax",
        params: {
            parallax: {
                enabled: false
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                parallax: {
                    setTransform: Parallax.setTransform.bind(swiper),
                    setTranslate: Parallax.setTranslate.bind(swiper),
                    setTransition: Parallax.setTransition.bind(swiper)
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (!swiper.params.parallax.enabled) {
                    return;
                }
                swiper.params.watchSlidesProgress = true;
                swiper.originalParams.watchSlidesProgress = true;
            },
            init: function init() {
                var swiper = this;
                if (!swiper.params.parallax.enabled) {
                    return;
                }
                swiper.parallax.setTranslate();
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (!swiper.params.parallax.enabled) {
                    return;
                }
                swiper.parallax.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (!swiper.params.parallax.enabled) {
                    return;
                }
                swiper.parallax.setTransition(duration);
            }
        }
    };
    var Zoom = {
        getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) {
                return 1;
            }
            var x1 = e.targetTouches[0].pageX;
            var y1 = e.targetTouches[0].pageY;
            var x2 = e.targetTouches[1].pageX;
            var y2 = e.targetTouches[1].pageY;
            var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            return distance;
        },
        onGestureStart: function onGestureStart(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
            if (!Support.gestures) {
                if (e.type !== "touchstart" || e.type === "touchstart" && e.targetTouches.length < 2) {
                    return;
                }
                zoom.fakeGestureTouched = true;
                gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$slideEl || !gesture.$slideEl.length) {
                gesture.$slideEl = $(e.target).closest(".swiper-slide");
                if (gesture.$slideEl.length === 0) {
                    gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                }
                gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas");
                gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
                gesture.maxRatio = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
                if (gesture.$imageWrapEl.length === 0) {
                    gesture.$imageEl = undefined;
                    return;
                }
            }
            gesture.$imageEl.transition(0);
            swiper.zoom.isScaling = true;
        },
        onGestureChange: function onGestureChange(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (!Support.gestures) {
                if (e.type !== "touchmove" || e.type === "touchmove" && e.targetTouches.length < 2) {
                    return;
                }
                zoom.fakeGestureMoved = true;
                gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            if (Support.gestures) {
                zoom.scale = e.scale * zoom.currentScale;
            } else {
                zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
            }
            if (zoom.scale > gesture.maxRatio) {
                zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, .5);
            }
            if (zoom.scale < params.minRatio) {
                zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, .5);
            }
            gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
        },
        onGestureEnd: function onGestureEnd(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (!Support.gestures) {
                if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
                    return;
                }
                if (e.type !== "touchend" || e.type === "touchend" && e.changedTouches.length < 2 && !Device.android) {
                    return;
                }
                zoom.fakeGestureTouched = false;
                zoom.fakeGestureMoved = false;
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
            zoom.currentScale = zoom.scale;
            zoom.isScaling = false;
            if (zoom.scale === 1) {
                gesture.$slideEl = undefined;
            }
        },
        onTouchStart: function onTouchStart(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            if (image.isTouched) {
                return;
            }
            if (Device.android) {
                e.preventDefault();
            }
            image.isTouched = true;
            image.touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
            image.touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
        },
        onTouchMove: function onTouchMove(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            var velocity = zoom.velocity;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            swiper.allowClick = false;
            if (!image.isTouched || !gesture.$slideEl) {
                return;
            }
            if (!image.isMoved) {
                image.width = gesture.$imageEl[0].offsetWidth;
                image.height = gesture.$imageEl[0].offsetHeight;
                image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], "x") || 0;
                image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], "y") || 0;
                gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
                gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
                gesture.$imageWrapEl.transition(0);
                if (swiper.rtl) {
                    image.startX = -image.startX;
                    image.startY = -image.startY;
                }
            }
            var scaledWidth = image.width * zoom.scale;
            var scaledHeight = image.height * zoom.scale;
            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) {
                return;
            }
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.touchesCurrent.x = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
            image.touchesCurrent.y = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
            if (!image.isMoved && !zoom.isScaling) {
                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                    image.isTouched = false;
                    return;
                }
                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                    image.isTouched = false;
                    return;
                }
            }
            e.preventDefault();
            e.stopPropagation();
            image.isMoved = true;
            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
            if (image.currentX < image.minX) {
                image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, .8);
            }
            if (image.currentX > image.maxX) {
                image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, .8);
            }
            if (image.currentY < image.minY) {
                image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, .8);
            }
            if (image.currentY > image.maxY) {
                image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, .8);
            }
            if (!velocity.prevPositionX) {
                velocity.prevPositionX = image.touchesCurrent.x;
            }
            if (!velocity.prevPositionY) {
                velocity.prevPositionY = image.touchesCurrent.y;
            }
            if (!velocity.prevTime) {
                velocity.prevTime = Date.now();
            }
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) {
                velocity.x = 0;
            }
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) {
                velocity.y = 0;
            }
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();
            gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
        },
        onTouchEnd: function onTouchEnd() {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            var velocity = zoom.velocity;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            if (!image.isTouched || !image.isMoved) {
                image.isTouched = false;
                image.isMoved = false;
                return;
            }
            image.isTouched = false;
            image.isMoved = false;
            var momentumDurationX = 300;
            var momentumDurationY = 300;
            var momentumDistanceX = velocity.x * momentumDurationX;
            var newPositionX = image.currentX + momentumDistanceX;
            var momentumDistanceY = velocity.y * momentumDurationY;
            var newPositionY = image.currentY + momentumDistanceY;
            if (velocity.x !== 0) {
                momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
            }
            if (velocity.y !== 0) {
                momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
            }
            var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
            image.currentX = newPositionX;
            image.currentY = newPositionY;
            var scaledWidth = image.width * zoom.scale;
            var scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
            gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
        },
        onTransitionEnd: function onTransitionEnd() {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
                gesture.$imageEl.transform("translate3d(0,0,0) scale(1)");
                gesture.$imageWrapEl.transform("translate3d(0,0,0)");
                zoom.scale = 1;
                zoom.currentScale = 1;
                gesture.$slideEl = undefined;
                gesture.$imageEl = undefined;
                gesture.$imageWrapEl = undefined;
            }
        },
        toggle: function toggle(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            if (zoom.scale && zoom.scale !== 1) {
                zoom.out();
            } else {
                zoom.in(e);
            }
        },
        "in": function in$1(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            var params = swiper.params.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            if (!gesture.$slideEl) {
                gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas");
                gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            gesture.$slideEl.addClass("" + params.zoomedSlideClass);
            var touchX;
            var touchY;
            var offsetX;
            var offsetY;
            var diffX;
            var diffY;
            var translateX;
            var translateY;
            var imageWidth;
            var imageHeight;
            var scaledWidth;
            var scaledHeight;
            var translateMinX;
            var translateMinY;
            var translateMaxX;
            var translateMaxY;
            var slideWidth;
            var slideHeight;
            if (typeof image.touchesStart.x === "undefined" && e) {
                touchX = e.type === "touchend" ? e.changedTouches[0].pageX : e.pageX;
                touchY = e.type === "touchend" ? e.changedTouches[0].pageY : e.pageY;
            } else {
                touchX = image.touchesStart.x;
                touchY = image.touchesStart.y;
            }
            zoom.scale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
            zoom.currentScale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
            if (e) {
                slideWidth = gesture.$slideEl[0].offsetWidth;
                slideHeight = gesture.$slideEl[0].offsetHeight;
                offsetX = gesture.$slideEl.offset().left;
                offsetY = gesture.$slideEl.offset().top;
                diffX = offsetX + slideWidth / 2 - touchX;
                diffY = offsetY + slideHeight / 2 - touchY;
                imageWidth = gesture.$imageEl[0].offsetWidth;
                imageHeight = gesture.$imageEl[0].offsetHeight;
                scaledWidth = imageWidth * zoom.scale;
                scaledHeight = imageHeight * zoom.scale;
                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
                translateMaxX = -translateMinX;
                translateMaxY = -translateMinY;
                translateX = diffX * zoom.scale;
                translateY = diffY * zoom.scale;
                if (translateX < translateMinX) {
                    translateX = translateMinX;
                }
                if (translateX > translateMaxX) {
                    translateX = translateMaxX;
                }
                if (translateY < translateMinY) {
                    translateY = translateMinY;
                }
                if (translateY > translateMaxY) {
                    translateY = translateMaxY;
                }
            } else {
                translateX = 0;
                translateY = 0;
            }
            gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
            gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
        },
        out: function out() {
            var swiper = this;
            var zoom = swiper.zoom;
            var params = swiper.params.zoom;
            var gesture = zoom.gesture;
            if (!gesture.$slideEl) {
                gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas");
                gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$imageWrapEl.transition(300).transform("translate3d(0,0,0)");
            gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)");
            gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
            gesture.$slideEl = undefined;
        },
        enable: function enable() {
            var swiper = this;
            var zoom = swiper.zoom;
            if (zoom.enabled) {
                return;
            }
            zoom.enabled = true;
            var passiveListener = swiper.touchEvents.start === "touchstart" && Support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (Support.gestures) {
                swiper.$wrapperEl.on("gesturestart", ".swiper-slide", zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.on("gesturechange", ".swiper-slide", zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.on("gestureend", ".swiper-slide", zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === "touchstart") {
                swiper.$wrapperEl.on(swiper.touchEvents.start, ".swiper-slide", zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.move, ".swiper-slide", zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.end, ".swiper-slide", zoom.onGestureEnd, passiveListener);
            }
            swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove);
        },
        disable: function disable() {
            var swiper = this;
            var zoom = swiper.zoom;
            if (!zoom.enabled) {
                return;
            }
            swiper.zoom.enabled = false;
            var passiveListener = swiper.touchEvents.start === "touchstart" && Support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (Support.gestures) {
                swiper.$wrapperEl.off("gesturestart", ".swiper-slide", zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.off("gesturechange", ".swiper-slide", zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.off("gestureend", ".swiper-slide", zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === "touchstart") {
                swiper.$wrapperEl.off(swiper.touchEvents.start, ".swiper-slide", zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.move, ".swiper-slide", zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.end, ".swiper-slide", zoom.onGestureEnd, passiveListener);
            }
            swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove);
        }
    };
    var Zoom$1 = {
        name: "zoom",
        params: {
            zoom: {
                enabled: false,
                maxRatio: 3,
                minRatio: 1,
                toggle: true,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        },
        create: function create() {
            var swiper = this;
            var zoom = {
                enabled: false,
                scale: 1,
                currentScale: 1,
                isScaling: false,
                gesture: {
                    $slideEl: undefined,
                    slideWidth: undefined,
                    slideHeight: undefined,
                    $imageEl: undefined,
                    $imageWrapEl: undefined,
                    maxRatio: 3
                },
                image: {
                    isTouched: undefined,
                    isMoved: undefined,
                    currentX: undefined,
                    currentY: undefined,
                    minX: undefined,
                    minY: undefined,
                    maxX: undefined,
                    maxY: undefined,
                    width: undefined,
                    height: undefined,
                    startX: undefined,
                    startY: undefined,
                    touchesStart: {},
                    touchesCurrent: {}
                },
                velocity: {
                    x: undefined,
                    y: undefined,
                    prevPositionX: undefined,
                    prevPositionY: undefined,
                    prevTime: undefined
                }
            };
            "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out".split(" ").forEach(function(methodName) {
                zoom[methodName] = Zoom[methodName].bind(swiper);
            });
            Utils.extend(swiper, {
                zoom: zoom
            });
            var scale = 1;
            Object.defineProperty(swiper.zoom, "scale", {
                get: function get() {
                    return scale;
                },
                set: function set(value) {
                    if (scale !== value) {
                        var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
                        var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
                        swiper.emit("zoomChange", value, imageEl, slideEl);
                    }
                    scale = value;
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.zoom.enabled) {
                    swiper.zoom.enable();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.zoom.disable();
            },
            touchStart: function touchStart(e) {
                var swiper = this;
                if (!swiper.zoom.enabled) {
                    return;
                }
                swiper.zoom.onTouchStart(e);
            },
            touchEnd: function touchEnd(e) {
                var swiper = this;
                if (!swiper.zoom.enabled) {
                    return;
                }
                swiper.zoom.onTouchEnd(e);
            },
            doubleTap: function doubleTap(e) {
                var swiper = this;
                if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                    swiper.zoom.toggle(e);
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                    swiper.zoom.onTransitionEnd();
                }
            }
        }
    };
    var Lazy = {
        loadInSlide: function loadInSlide(index, loadInDuplicate) {
            if (loadInDuplicate === void 0) loadInDuplicate = true;
            var swiper = this;
            var params = swiper.params.lazy;
            if (typeof index === "undefined") {
                return;
            }
            if (swiper.slides.length === 0) {
                return;
            }
            var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + '[data-swiper-slide-index="' + index + '"]') : swiper.slides.eq(index);
            var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");
            if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
                $images = $images.add($slideEl[0]);
            }
            if ($images.length === 0) {
                return;
            }
            $images.each(function(imageIndex, imageEl) {
                var $imageEl = $(imageEl);
                $imageEl.addClass(params.loadingClass);
                var background = $imageEl.attr("data-background");
                var src = $imageEl.attr("data-src");
                var srcset = $imageEl.attr("data-srcset");
                var sizes = $imageEl.attr("data-sizes");
                swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function() {
                    if (typeof swiper === "undefined" || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) {
                        return;
                    }
                    if (background) {
                        $imageEl.css("background-image", 'url("' + background + '")');
                        $imageEl.removeAttr("data-background");
                    } else {
                        if (srcset) {
                            $imageEl.attr("srcset", srcset);
                            $imageEl.removeAttr("data-srcset");
                        }
                        if (sizes) {
                            $imageEl.attr("sizes", sizes);
                            $imageEl.removeAttr("data-sizes");
                        }
                        if (src) {
                            $imageEl.attr("src", src);
                            $imageEl.removeAttr("data-src");
                        }
                    }
                    $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                    $slideEl.find("." + params.preloaderClass).remove();
                    if (swiper.params.loop && loadInDuplicate) {
                        var slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
                        if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                            var originalSlide = swiper.$wrapperEl.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + swiper.params.slideDuplicateClass + ")");
                            swiper.lazy.loadInSlide(originalSlide.index(), false);
                        } else {
                            var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                        }
                    }
                    swiper.emit("lazyImageReady", $slideEl[0], $imageEl[0]);
                });
                swiper.emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
            });
        },
        load: function load() {
            var swiper = this;
            var $wrapperEl = swiper.$wrapperEl;
            var swiperParams = swiper.params;
            var slides = swiper.slides;
            var activeIndex = swiper.activeIndex;
            var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
            var params = swiperParams.lazy;
            var slidesPerView = swiperParams.slidesPerView;
            if (slidesPerView === "auto") {
                slidesPerView = 0;
            }
            function slideExist(index) {
                if (isVirtual) {
                    if ($wrapperEl.children("." + swiperParams.slideClass + '[data-swiper-slide-index="' + index + '"]').length) {
                        return true;
                    }
                } else if (slides[index]) {
                    return true;
                }
                return false;
            }
            function slideIndex(slideEl) {
                if (isVirtual) {
                    return $(slideEl).attr("data-swiper-slide-index");
                }
                return $(slideEl).index();
            }
            if (!swiper.lazy.initialImageLoaded) {
                swiper.lazy.initialImageLoaded = true;
            }
            if (swiper.params.watchSlidesVisibility) {
                $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function(elIndex, slideEl) {
                    var index = isVirtual ? $(slideEl).attr("data-swiper-slide-index") : $(slideEl).index();
                    swiper.lazy.loadInSlide(index);
                });
            } else if (slidesPerView > 1) {
                for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
                    if (slideExist(i)) {
                        swiper.lazy.loadInSlide(i);
                    }
                }
            } else {
                swiper.lazy.loadInSlide(activeIndex);
            }
            if (params.loadPrevNext) {
                if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
                    var amount = params.loadPrevNextAmount;
                    var spv = slidesPerView;
                    var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                    var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
                    for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
                        if (slideExist(i$1)) {
                            swiper.lazy.loadInSlide(i$1);
                        }
                    }
                    for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
                        if (slideExist(i$2)) {
                            swiper.lazy.loadInSlide(i$2);
                        }
                    }
                } else {
                    var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);
                    if (nextSlide.length > 0) {
                        swiper.lazy.loadInSlide(slideIndex(nextSlide));
                    }
                    var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);
                    if (prevSlide.length > 0) {
                        swiper.lazy.loadInSlide(slideIndex(prevSlide));
                    }
                }
            }
        }
    };
    var Lazy$1 = {
        name: "lazy",
        params: {
            lazy: {
                enabled: false,
                loadPrevNext: false,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: false,
                elementClass: "swiper-lazy",
                loadingClass: "swiper-lazy-loading",
                loadedClass: "swiper-lazy-loaded",
                preloaderClass: "swiper-lazy-preloader"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                lazy: {
                    initialImageLoaded: false,
                    load: Lazy.load.bind(swiper),
                    loadInSlide: Lazy.loadInSlide.bind(swiper)
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                    swiper.params.preloadImages = false;
                }
            },
            init: function init() {
                var swiper = this;
                if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
                    swiper.lazy.load();
                }
            },
            scroll: function scroll() {
                var swiper = this;
                if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
                    swiper.lazy.load();
                }
            },
            resize: function resize() {
                var swiper = this;
                if (swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            },
            scrollbarDragMove: function scrollbarDragMove() {
                var swiper = this;
                if (swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            },
            transitionStart: function transitionStart() {
                var swiper = this;
                if (swiper.params.lazy.enabled) {
                    if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
                        swiper.lazy.load();
                    }
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                    swiper.lazy.load();
                }
            }
        }
    };
    var Controller = {
        LinearSpline: function LinearSpline(x, y) {
            var binarySearch = function search() {
                var maxIndex;
                var minIndex;
                var guess;
                return function(array, val) {
                    minIndex = -1;
                    maxIndex = array.length;
                    while (maxIndex - minIndex > 1) {
                        guess = maxIndex + minIndex >> 1;
                        if (array[guess] <= val) {
                            minIndex = guess;
                        } else {
                            maxIndex = guess;
                        }
                    }
                    return maxIndex;
                };
            }();
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1;
            var i1;
            var i3;
            this.interpolate = function interpolate(x2) {
                if (!x2) {
                    return 0;
                }
                i3 = binarySearch(this.x, x2);
                i1 = i3 - 1;
                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
            };
            return this;
        },
        getInterpolateFunction: function getInterpolateFunction(c) {
            var swiper = this;
            if (!swiper.controller.spline) {
                swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
            }
        },
        setTranslate: function setTranslate(setTranslate$1, byController) {
            var swiper = this;
            var controlled = swiper.controller.control;
            var multiplier;
            var controlledTranslate;
            function setControlledTranslate(c) {
                var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                if (swiper.params.controller.by === "slide") {
                    swiper.controller.getInterpolateFunction(c);
                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);
                }
                if (!controlledTranslate || swiper.params.controller.by === "container") {
                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
                }
                if (swiper.params.controller.inverse) {
                    controlledTranslate = c.maxTranslate() - controlledTranslate;
                }
                c.updateProgress(controlledTranslate);
                c.setTranslate(controlledTranslate, swiper);
                c.updateActiveIndex();
                c.updateSlidesClasses();
            }
            if (Array.isArray(controlled)) {
                for (var i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTranslate(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTranslate(controlled);
            }
        },
        setTransition: function setTransition(duration, byController) {
            var swiper = this;
            var controlled = swiper.controller.control;
            var i;
            function setControlledTransition(c) {
                c.setTransition(duration, swiper);
                if (duration !== 0) {
                    c.transitionStart();
                    if (c.params.autoHeight) {
                        Utils.nextTick(function() {
                            c.updateAutoHeight();
                        });
                    }
                    c.$wrapperEl.transitionEnd(function() {
                        if (!controlled) {
                            return;
                        }
                        if (c.params.loop && swiper.params.controller.by === "slide") {
                            c.loopFix();
                        }
                        c.transitionEnd();
                    });
                }
            }
            if (Array.isArray(controlled)) {
                for (i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTransition(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTransition(controlled);
            }
        }
    };
    var Controller$1 = {
        name: "controller",
        params: {
            controller: {
                control: undefined,
                inverse: false,
                by: "slide"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                controller: {
                    control: swiper.params.controller.control,
                    getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
                    setTranslate: Controller.setTranslate.bind(swiper),
                    setTransition: Controller.setTransition.bind(swiper)
                }
            });
        },
        on: {
            update: function update() {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            },
            resize: function resize() {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            },
            observerUpdate: function observerUpdate() {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            },
            setTranslate: function setTranslate(translate, byController) {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                swiper.controller.setTranslate(translate, byController);
            },
            setTransition: function setTransition(duration, byController) {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                swiper.controller.setTransition(duration, byController);
            }
        }
    };
    var a11y = {
        makeElFocusable: function makeElFocusable($el) {
            $el.attr("tabIndex", "0");
            return $el;
        },
        addElRole: function addElRole($el, role) {
            $el.attr("role", role);
            return $el;
        },
        addElLabel: function addElLabel($el, label) {
            $el.attr("aria-label", label);
            return $el;
        },
        disableEl: function disableEl($el) {
            $el.attr("aria-disabled", true);
            return $el;
        },
        enableEl: function enableEl($el) {
            $el.attr("aria-disabled", false);
            return $el;
        },
        onEnterKey: function onEnterKey(e) {
            var swiper = this;
            var params = swiper.params.a11y;
            if (e.keyCode !== 13) {
                return;
            }
            var $targetEl = $(e.target);
            if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                    swiper.slideNext();
                }
                if (swiper.isEnd) {
                    swiper.a11y.notify(params.lastSlideMessage);
                } else {
                    swiper.a11y.notify(params.nextSlideMessage);
                }
            }
            if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                    swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                    swiper.a11y.notify(params.firstSlideMessage);
                } else {
                    swiper.a11y.notify(params.prevSlideMessage);
                }
            }
            if (swiper.pagination && $targetEl.is("." + swiper.params.pagination.bulletClass)) {
                $targetEl[0].click();
            }
        },
        notify: function notify(message) {
            var swiper = this;
            var notification = swiper.a11y.liveRegion;
            if (notification.length === 0) {
                return;
            }
            notification.html("");
            notification.html(message);
        },
        updateNavigation: function updateNavigation() {
            var swiper = this;
            if (swiper.params.loop) {
                return;
            }
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;
            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    swiper.a11y.disableEl($prevEl);
                } else {
                    swiper.a11y.enableEl($prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    swiper.a11y.disableEl($nextEl);
                } else {
                    swiper.a11y.enableEl($nextEl);
                }
            }
        },
        updatePagination: function updatePagination() {
            var swiper = this;
            var params = swiper.params.a11y;
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.bullets.each(function(bulletIndex, bulletEl) {
                    var $bulletEl = $(bulletEl);
                    swiper.a11y.makeElFocusable($bulletEl);
                    swiper.a11y.addElRole($bulletEl, "button");
                    swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
                });
            }
        },
        init: function init() {
            var swiper = this;
            swiper.$el.append(swiper.a11y.liveRegion);
            var params = swiper.params.a11y;
            var $nextEl;
            var $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                swiper.a11y.makeElFocusable($nextEl);
                swiper.a11y.addElRole($nextEl, "button");
                swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
                $nextEl.on("keydown", swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
                swiper.a11y.makeElFocusable($prevEl);
                swiper.a11y.addElRole($prevEl, "button");
                swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
                $prevEl.on("keydown", swiper.a11y.onEnterKey);
            }
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.$el.on("keydown", "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
            }
        },
        destroy: function destroy() {
            var swiper = this;
            if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) {
                swiper.a11y.liveRegion.remove();
            }
            var $nextEl;
            var $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                $nextEl.off("keydown", swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
                $prevEl.off("keydown", swiper.a11y.onEnterKey);
            }
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.$el.off("keydown", "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
            }
        }
    };
    var A11y = {
        name: "a11y",
        params: {
            a11y: {
                enabled: true,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                a11y: {
                    liveRegion: $('<span class="' + swiper.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>')
                }
            });
            Object.keys(a11y).forEach(function(methodName) {
                swiper.a11y[methodName] = a11y[methodName].bind(swiper);
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.init();
                swiper.a11y.updateNavigation();
            },
            toEdge: function toEdge() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.updateNavigation();
            },
            fromEdge: function fromEdge() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.updateNavigation();
            },
            paginationUpdate: function paginationUpdate() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.updatePagination();
            },
            destroy: function destroy() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.destroy();
            }
        }
    };
    var History = {
        init: function init() {
            var swiper = this;
            if (!swiper.params.history) {
                return;
            }
            if (!win.history || !win.history.pushState) {
                swiper.params.history.enabled = false;
                swiper.params.hashNavigation.enabled = true;
                return;
            }
            var history = swiper.history;
            history.initialized = true;
            history.paths = History.getPathValues();
            if (!history.paths.key && !history.paths.value) {
                return;
            }
            history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
                win.addEventListener("popstate", swiper.history.setHistoryPopState);
            }
        },
        destroy: function destroy() {
            var swiper = this;
            if (!swiper.params.history.replaceState) {
                win.removeEventListener("popstate", swiper.history.setHistoryPopState);
            }
        },
        setHistoryPopState: function setHistoryPopState() {
            var swiper = this;
            swiper.history.paths = History.getPathValues();
            swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
        },
        getPathValues: function getPathValues() {
            var pathArray = win.location.pathname.slice(1).split("/").filter(function(part) {
                return part !== "";
            });
            var total = pathArray.length;
            var key = pathArray[total - 2];
            var value = pathArray[total - 1];
            return {
                key: key,
                value: value
            };
        },
        setHistory: function setHistory(key, index) {
            var swiper = this;
            if (!swiper.history.initialized || !swiper.params.history.enabled) {
                return;
            }
            var slide = swiper.slides.eq(index);
            var value = History.slugify(slide.attr("data-history"));
            if (!win.location.pathname.includes(key)) {
                value = key + "/" + value;
            }
            var currentState = win.history.state;
            if (currentState && currentState.value === value) {
                return;
            }
            if (swiper.params.history.replaceState) {
                win.history.replaceState({
                    value: value
                }, null, value);
            } else {
                win.history.pushState({
                    value: value
                }, null, value);
            }
        },
        slugify: function slugify(text) {
            return text.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
        },
        scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
            var swiper = this;
            if (value) {
                for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
                    var slide = swiper.slides.eq(i);
                    var slideHistory = History.slugify(slide.attr("data-history"));
                    if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        var index = slide.index();
                        swiper.slideTo(index, speed, runCallbacks);
                    }
                }
            } else {
                swiper.slideTo(0, speed, runCallbacks);
            }
        }
    };
    var History$1 = {
        name: "history",
        params: {
            history: {
                enabled: false,
                replaceState: false,
                key: "slides"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                history: {
                    init: History.init.bind(swiper),
                    setHistory: History.setHistory.bind(swiper),
                    setHistoryPopState: History.setHistoryPopState.bind(swiper),
                    scrollToSlide: History.scrollToSlide.bind(swiper),
                    destroy: History.destroy.bind(swiper)
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.history.enabled) {
                    swiper.history.init();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.params.history.enabled) {
                    swiper.history.destroy();
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.history.initialized) {
                    swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
                }
            }
        }
    };
    var HashNavigation = {
        onHashCange: function onHashCange() {
            var swiper = this;
            var newHash = doc.location.hash.replace("#", "");
            var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr("data-hash");
            if (newHash !== activeSlideHash) {
                var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + '[data-hash="' + newHash + '"]').index();
                if (typeof newIndex === "undefined") {
                    return;
                }
                swiper.slideTo(newIndex);
            }
        },
        setHash: function setHash() {
            var swiper = this;
            if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) {
                return;
            }
            if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
                win.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr("data-hash") || "");
            } else {
                var slide = swiper.slides.eq(swiper.activeIndex);
                var hash = slide.attr("data-hash") || slide.attr("data-history");
                doc.location.hash = hash || "";
            }
        },
        init: function init() {
            var swiper = this;
            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) {
                return;
            }
            swiper.hashNavigation.initialized = true;
            var hash = doc.location.hash.replace("#", "");
            if (hash) {
                var speed = 0;
                for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
                    var slide = swiper.slides.eq(i);
                    var slideHash = slide.attr("data-hash") || slide.attr("data-history");
                    if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        var index = slide.index();
                        swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
                    }
                }
            }
            if (swiper.params.hashNavigation.watchState) {
                $(win).on("hashchange", swiper.hashNavigation.onHashCange);
            }
        },
        destroy: function destroy() {
            var swiper = this;
            if (swiper.params.hashNavigation.watchState) {
                $(win).off("hashchange", swiper.hashNavigation.onHashCange);
            }
        }
    };
    var HashNavigation$1 = {
        name: "hash-navigation",
        params: {
            hashNavigation: {
                enabled: false,
                replaceState: false,
                watchState: false
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                hashNavigation: {
                    initialized: false,
                    init: HashNavigation.init.bind(swiper),
                    destroy: HashNavigation.destroy.bind(swiper),
                    setHash: HashNavigation.setHash.bind(swiper),
                    onHashCange: HashNavigation.onHashCange.bind(swiper)
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.hashNavigation.enabled) {
                    swiper.hashNavigation.init();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.params.hashNavigation.enabled) {
                    swiper.hashNavigation.destroy();
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.hashNavigation.initialized) {
                    swiper.hashNavigation.setHash();
                }
            }
        }
    };
    var Autoplay = {
        run: function run() {
            var swiper = this;
            var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            var delay = swiper.params.autoplay.delay;
            if ($activeSlideEl.attr("data-swiper-autoplay")) {
                delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay;
            }
            swiper.autoplay.timeout = Utils.nextTick(function() {
                if (swiper.params.autoplay.reverseDirection) {
                    if (swiper.params.loop) {
                        swiper.loopFix();
                        swiper.slidePrev(swiper.params.speed, true, true);
                        swiper.emit("autoplay");
                    } else if (!swiper.isBeginning) {
                        swiper.slidePrev(swiper.params.speed, true, true);
                        swiper.emit("autoplay");
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                        swiper.emit("autoplay");
                    } else {
                        swiper.autoplay.stop();
                    }
                } else if (swiper.params.loop) {
                    swiper.loopFix();
                    swiper.slideNext(swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else if (!swiper.isEnd) {
                    swiper.slideNext(swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    swiper.slideTo(0, swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else {
                    swiper.autoplay.stop();
                }
            }, delay);
        },
        start: function start() {
            var swiper = this;
            if (typeof swiper.autoplay.timeout !== "undefined") {
                return false;
            }
            if (swiper.autoplay.running) {
                return false;
            }
            swiper.autoplay.running = true;
            swiper.emit("autoplayStart");
            swiper.autoplay.run();
            return true;
        },
        stop: function stop() {
            var swiper = this;
            if (!swiper.autoplay.running) {
                return false;
            }
            if (typeof swiper.autoplay.timeout === "undefined") {
                return false;
            }
            if (swiper.autoplay.timeout) {
                clearTimeout(swiper.autoplay.timeout);
                swiper.autoplay.timeout = undefined;
            }
            swiper.autoplay.running = false;
            swiper.emit("autoplayStop");
            return true;
        },
        pause: function pause(speed) {
            var swiper = this;
            if (!swiper.autoplay.running) {
                return;
            }
            if (swiper.autoplay.paused) {
                return;
            }
            if (swiper.autoplay.timeout) {
                clearTimeout(swiper.autoplay.timeout);
            }
            swiper.autoplay.paused = true;
            if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
                swiper.autoplay.paused = false;
                swiper.autoplay.run();
            } else {
                swiper.$wrapperEl[0].addEventListener("transitionend", swiper.autoplay.onTransitionEnd);
                swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.autoplay.onTransitionEnd);
            }
        }
    };
    var Autoplay$1 = {
        name: "autoplay",
        params: {
            autoplay: {
                enabled: false,
                delay: 3e3,
                waitForTransition: true,
                disableOnInteraction: true,
                stopOnLastSlide: false,
                reverseDirection: false
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                autoplay: {
                    running: false,
                    paused: false,
                    run: Autoplay.run.bind(swiper),
                    start: Autoplay.start.bind(swiper),
                    stop: Autoplay.stop.bind(swiper),
                    pause: Autoplay.pause.bind(swiper),
                    onTransitionEnd: function onTransitionEnd(e) {
                        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) {
                            return;
                        }
                        if (e.target !== this) {
                            return;
                        }
                        swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.autoplay.onTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.autoplay.onTransitionEnd);
                        swiper.autoplay.paused = false;
                        if (!swiper.autoplay.running) {
                            swiper.autoplay.stop();
                        } else {
                            swiper.autoplay.run();
                        }
                    }
                }
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.autoplay.enabled) {
                    swiper.autoplay.start();
                }
            },
            beforeTransitionStart: function beforeTransitionStart(speed, internal) {
                var swiper = this;
                if (swiper.autoplay.running) {
                    if (internal || !swiper.params.autoplay.disableOnInteraction) {
                        swiper.autoplay.pause(speed);
                    } else {
                        swiper.autoplay.stop();
                    }
                }
            },
            sliderFirstMove: function sliderFirstMove() {
                var swiper = this;
                if (swiper.autoplay.running) {
                    if (swiper.params.autoplay.disableOnInteraction) {
                        swiper.autoplay.stop();
                    } else {
                        swiper.autoplay.pause();
                    }
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.autoplay.running) {
                    swiper.autoplay.stop();
                }
            }
        }
    };
    var Fade = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var slides = swiper.slides;
            for (var i = 0; i < slides.length; i += 1) {
                var $slideEl = swiper.slides.eq(i);
                var offset = $slideEl[0].swiperSlideOffset;
                var tx = -offset;
                if (!swiper.params.virtualTranslate) {
                    tx -= swiper.translate;
                }
                var ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                }
                var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
                $slideEl.css({
                    opacity: slideOpacity
                }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            var slides = swiper.slides;
            var $wrapperEl = swiper.$wrapperEl;
            slides.transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
                var eventTriggered = false;
                slides.transitionEnd(function() {
                    if (eventTriggered) {
                        return;
                    }
                    if (!swiper || swiper.destroyed) {
                        return;
                    }
                    eventTriggered = true;
                    swiper.animating = false;
                    var triggerEvents = [ "webkitTransitionEnd", "transitionend" ];
                    for (var i = 0; i < triggerEvents.length; i += 1) {
                        $wrapperEl.trigger(triggerEvents[i]);
                    }
                });
            }
        }
    };
    var EffectFade = {
        name: "effect-fade",
        params: {
            fadeEffect: {
                crossFade: false
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                fadeEffect: {
                    setTranslate: Fade.setTranslate.bind(swiper),
                    setTransition: Fade.setTransition.bind(swiper)
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== "fade") {
                    return;
                }
                swiper.classNames.push(swiper.params.containerModifierClass + "fade");
                var overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: true
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== "fade") {
                    return;
                }
                swiper.fadeEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== "fade") {
                    return;
                }
                swiper.fadeEffect.setTransition(duration);
            }
        }
    };
    var Cube = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var $el = swiper.$el;
            var $wrapperEl = swiper.$wrapperEl;
            var slides = swiper.slides;
            var swiperWidth = swiper.width;
            var swiperHeight = swiper.height;
            var rtl = swiper.rtlTranslate;
            var swiperSize = swiper.size;
            var params = swiper.params.cubeEffect;
            var isHorizontal = swiper.isHorizontal();
            var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            var wrapperRotate = 0;
            var $cubeShadowEl;
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow");
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $wrapperEl.append($cubeShadowEl);
                    }
                    $cubeShadowEl.css({
                        height: swiperWidth + "px"
                    });
                } else {
                    $cubeShadowEl = $el.find(".swiper-cube-shadow");
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $el.append($cubeShadowEl);
                    }
                }
            }
            for (var i = 0; i < slides.length; i += 1) {
                var $slideEl = slides.eq(i);
                var slideIndex = i;
                if (isVirtual) {
                    slideIndex = parseInt($slideEl.attr("data-swiper-slide-index"), 10);
                }
                var slideAngle = slideIndex * 90;
                var round = Math.floor(slideAngle / 360);
                if (rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                }
                var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                var tx = 0;
                var ty = 0;
                var tz = 0;
                if (slideIndex % 4 === 0) {
                    tx = -round * 4 * swiperSize;
                    tz = 0;
                } else if ((slideIndex - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * swiperSize;
                } else if ((slideIndex - 2) % 4 === 0) {
                    tx = swiperSize + round * 4 * swiperSize;
                    tz = swiperSize;
                } else if ((slideIndex - 3) % 4 === 0) {
                    tx = -swiperSize;
                    tz = 3 * swiperSize + swiperSize * 4 * round;
                }
                if (rtl) {
                    tx = -tx;
                }
                if (!isHorizontal) {
                    ty = tx;
                    tx = 0;
                }
                var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
                if (progress <= 1 && progress > -1) {
                    wrapperRotate = slideIndex * 90 + progress * 90;
                    if (rtl) {
                        wrapperRotate = -slideIndex * 90 - progress * 90;
                    }
                }
                $slideEl.transform(transform);
                if (params.slideShadows) {
                    var shadowBefore = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                    var shadowAfter = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                    if (shadowBefore.length === 0) {
                        shadowBefore = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>');
                        $slideEl.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                        shadowAfter = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>');
                        $slideEl.append(shadowAfter);
                    }
                    if (shadowBefore.length) {
                        shadowBefore[0].style.opacity = Math.max(-progress, 0);
                    }
                    if (shadowAfter.length) {
                        shadowAfter[0].style.opacity = Math.max(progress, 0);
                    }
                }
            }
            $wrapperEl.css({
                "-webkit-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
                "-moz-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
                "-ms-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
                "transform-origin": "50% 50% -" + swiperSize / 2 + "px"
            });
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
                } else {
                    var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                    var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                    var scale1 = params.shadowScale;
                    var scale2 = params.shadowScale / multiplier;
                    var offset = params.shadowOffset;
                    $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
                }
            }
            var zFactor = Browser.isSafari || Browser.isUiWebView ? -swiperSize / 2 : 0;
            $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            var $el = swiper.$el;
            var slides = swiper.slides;
            slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                $el.find(".swiper-cube-shadow").transition(duration);
            }
        }
    };
    var EffectCube = {
        name: "effect-cube",
        params: {
            cubeEffect: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: .94
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                cubeEffect: {
                    setTranslate: Cube.setTranslate.bind(swiper),
                    setTransition: Cube.setTransition.bind(swiper)
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== "cube") {
                    return;
                }
                swiper.classNames.push(swiper.params.containerModifierClass + "cube");
                swiper.classNames.push(swiper.params.containerModifierClass + "3d");
                var overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    resistanceRatio: 0,
                    spaceBetween: 0,
                    centeredSlides: false,
                    virtualTranslate: true
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== "cube") {
                    return;
                }
                swiper.cubeEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== "cube") {
                    return;
                }
                swiper.cubeEffect.setTransition(duration);
            }
        }
    };
    var Flip = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var slides = swiper.slides;
            var rtl = swiper.rtlTranslate;
            for (var i = 0; i < slides.length; i += 1) {
                var $slideEl = slides.eq(i);
                var progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                }
                var offset = $slideEl[0].swiperSlideOffset;
                var rotate = -180 * progress;
                var rotateY = rotate;
                var rotateX = 0;
                var tx = -offset;
                var ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                    rotateX = -rotateY;
                    rotateY = 0;
                } else if (rtl) {
                    rotateY = -rotateY;
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
                if (swiper.params.flipEffect.slideShadows) {
                    var shadowBefore = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                    var shadowAfter = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                    if (shadowBefore.length === 0) {
                        shadowBefore = $('<div class="swiper-slide-shadow-' + (swiper.isHorizontal() ? "left" : "top") + '"></div>');
                        $slideEl.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                        shadowAfter = $('<div class="swiper-slide-shadow-' + (swiper.isHorizontal() ? "right" : "bottom") + '"></div>');
                        $slideEl.append(shadowAfter);
                    }
                    if (shadowBefore.length) {
                        shadowBefore[0].style.opacity = Math.max(-progress, 0);
                    }
                    if (shadowAfter.length) {
                        shadowAfter[0].style.opacity = Math.max(progress, 0);
                    }
                }
                $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            var slides = swiper.slides;
            var activeIndex = swiper.activeIndex;
            var $wrapperEl = swiper.$wrapperEl;
            slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
                var eventTriggered = false;
                slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
                    if (eventTriggered) {
                        return;
                    }
                    if (!swiper || swiper.destroyed) {
                        return;
                    }
                    eventTriggered = true;
                    swiper.animating = false;
                    var triggerEvents = [ "webkitTransitionEnd", "transitionend" ];
                    for (var i = 0; i < triggerEvents.length; i += 1) {
                        $wrapperEl.trigger(triggerEvents[i]);
                    }
                });
            }
        }
    };
    var EffectFlip = {
        name: "effect-flip",
        params: {
            flipEffect: {
                slideShadows: true,
                limitRotation: true
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                flipEffect: {
                    setTranslate: Flip.setTranslate.bind(swiper),
                    setTransition: Flip.setTransition.bind(swiper)
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== "flip") {
                    return;
                }
                swiper.classNames.push(swiper.params.containerModifierClass + "flip");
                swiper.classNames.push(swiper.params.containerModifierClass + "3d");
                var overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: true
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== "flip") {
                    return;
                }
                swiper.flipEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== "flip") {
                    return;
                }
                swiper.flipEffect.setTransition(duration);
            }
        }
    };
    var Coverflow = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var swiperWidth = swiper.width;
            var swiperHeight = swiper.height;
            var slides = swiper.slides;
            var $wrapperEl = swiper.$wrapperEl;
            var slidesSizesGrid = swiper.slidesSizesGrid;
            var params = swiper.params.coverflowEffect;
            var isHorizontal = swiper.isHorizontal();
            var transform = swiper.translate;
            var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
            var rotate = isHorizontal ? params.rotate : -params.rotate;
            var translate = params.depth;
            for (var i = 0, length = slides.length; i < length; i += 1) {
                var $slideEl = slides.eq(i);
                var slideSize = slidesSizesGrid[i];
                var slideOffset = $slideEl[0].swiperSlideOffset;
                var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
                var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
                var translateZ = -translate * Math.abs(offsetMultiplier);
                var translateY = isHorizontal ? 0 : params.stretch * offsetMultiplier;
                var translateX = isHorizontal ? params.stretch * offsetMultiplier : 0;
                if (Math.abs(translateX) < .001) {
                    translateX = 0;
                }
                if (Math.abs(translateY) < .001) {
                    translateY = 0;
                }
                if (Math.abs(translateZ) < .001) {
                    translateZ = 0;
                }
                if (Math.abs(rotateY) < .001) {
                    rotateY = 0;
                }
                if (Math.abs(rotateX) < .001) {
                    rotateX = 0;
                }
                var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
                $slideEl.transform(slideTransform);
                $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (params.slideShadows) {
                    var $shadowBeforeEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                    var $shadowAfterEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                    if ($shadowBeforeEl.length === 0) {
                        $shadowBeforeEl = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>');
                        $slideEl.append($shadowBeforeEl);
                    }
                    if ($shadowAfterEl.length === 0) {
                        $shadowAfterEl = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>');
                        $slideEl.append($shadowAfterEl);
                    }
                    if ($shadowBeforeEl.length) {
                        $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                    }
                    if ($shadowAfterEl.length) {
                        $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
                    }
                }
            }
            if (Support.pointerEvents || Support.prefixedPointerEvents) {
                var ws = $wrapperEl[0].style;
                ws.perspectiveOrigin = center + "px 50%";
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            swiper.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
        }
    };
    var EffectCoverflow = {
        name: "effect-coverflow",
        params: {
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows: true
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                coverflowEffect: {
                    setTranslate: Coverflow.setTranslate.bind(swiper),
                    setTransition: Coverflow.setTransition.bind(swiper)
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== "coverflow") {
                    return;
                }
                swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
                swiper.classNames.push(swiper.params.containerModifierClass + "3d");
                swiper.params.watchSlidesProgress = true;
                swiper.originalParams.watchSlidesProgress = true;
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== "coverflow") {
                    return;
                }
                swiper.coverflowEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== "coverflow") {
                    return;
                }
                swiper.coverflowEffect.setTransition(duration);
            }
        }
    };
    var Thumbs = {
        init: function init() {
            var swiper = this;
            var ref = swiper.params;
            var thumbsParams = ref.thumbs;
            var SwiperClass = swiper.constructor;
            if (thumbsParams.swiper instanceof SwiperClass) {
                swiper.thumbs.swiper = thumbsParams.swiper;
                Utils.extend(swiper.thumbs.swiper.originalParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
                Utils.extend(swiper.thumbs.swiper.params, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
            } else if (Utils.isObject(thumbsParams.swiper)) {
                swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
                    watchSlidesVisibility: true,
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                }));
                swiper.thumbs.swiperCreated = true;
            }
            swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
            swiper.thumbs.swiper.on("tap", swiper.thumbs.onThumbClick);
        },
        onThumbClick: function onThumbClick() {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) {
                return;
            }
            var clickedIndex = thumbsSwiper.clickedIndex;
            var clickedSlide = thumbsSwiper.clickedSlide;
            if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) {
                return;
            }
            if (typeof clickedIndex === "undefined" || clickedIndex === null) {
                return;
            }
            var slideToIndex;
            if (thumbsSwiper.params.loop) {
                slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"), 10);
            } else {
                slideToIndex = clickedIndex;
            }
            if (swiper.params.loop) {
                var currentIndex = swiper.activeIndex;
                if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                    swiper.loopFix();
                    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                    currentIndex = swiper.activeIndex;
                }
                var prevIndex = swiper.slides.eq(currentIndex).prevAll('[data-swiper-slide-index="' + slideToIndex + '"]').eq(0).index();
                var nextIndex = swiper.slides.eq(currentIndex).nextAll('[data-swiper-slide-index="' + slideToIndex + '"]').eq(0).index();
                if (typeof prevIndex === "undefined") {
                    slideToIndex = nextIndex;
                } else if (typeof nextIndex === "undefined") {
                    slideToIndex = prevIndex;
                } else if (nextIndex - currentIndex < currentIndex - prevIndex) {
                    slideToIndex = nextIndex;
                } else {
                    slideToIndex = prevIndex;
                }
            }
            swiper.slideTo(slideToIndex);
        },
        update: function update(initial) {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) {
                return;
            }
            var slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
            if (swiper.realIndex !== thumbsSwiper.realIndex) {
                var currentThumbsIndex = thumbsSwiper.activeIndex;
                var newThumbsIndex;
                if (thumbsSwiper.params.loop) {
                    if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                        thumbsSwiper.loopFix();
                        thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                        currentThumbsIndex = thumbsSwiper.activeIndex;
                    }
                    var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll('[data-swiper-slide-index="' + swiper.realIndex + '"]').eq(0).index();
                    var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll('[data-swiper-slide-index="' + swiper.realIndex + '"]').eq(0).index();
                    if (typeof prevThumbsIndex === "undefined") {
                        newThumbsIndex = nextThumbsIndex;
                    } else if (typeof nextThumbsIndex === "undefined") {
                        newThumbsIndex = prevThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = currentThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = nextThumbsIndex;
                    } else {
                        newThumbsIndex = prevThumbsIndex;
                    }
                } else {
                    newThumbsIndex = swiper.realIndex;
                }
                if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                    if (thumbsSwiper.params.centeredSlides) {
                        if (newThumbsIndex > currentThumbsIndex) {
                            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                        } else {
                            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                        }
                    } else if (newThumbsIndex > currentThumbsIndex) {
                        newThumbsIndex = newThumbsIndex - slidesPerView + 1;
                    }
                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
                }
            }
            var thumbsToActivate = 1;
            var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
                thumbsToActivate = swiper.params.slidesPerView;
            }
            thumbsSwiper.slides.removeClass(thumbActiveClass);
            if (thumbsSwiper.params.loop) {
                for (var i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.$wrapperEl.children('[data-swiper-slide-index="' + (swiper.realIndex + i) + '"]').addClass(thumbActiveClass);
                }
            } else {
                for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
                    thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
                }
            }
        }
    };
    var Thumbs$1 = {
        name: "thumbs",
        params: {
            thumbs: {
                swiper: null,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-container-thumbs"
            }
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                thumbs: {
                    swiper: null,
                    init: Thumbs.init.bind(swiper),
                    update: Thumbs.update.bind(swiper),
                    onThumbClick: Thumbs.onThumbClick.bind(swiper)
                }
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                var ref = swiper.params;
                var thumbs = ref.thumbs;
                if (!thumbs || !thumbs.swiper) {
                    return;
                }
                swiper.thumbs.init();
                swiper.thumbs.update(true);
            },
            slideChange: function slideChange() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            update: function update() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            resize: function resize() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            observerUpdate: function observerUpdate() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                var thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper) {
                    return;
                }
                thumbsSwiper.setTransition(duration);
            },
            beforeDestroy: function beforeDestroy() {
                var swiper = this;
                var thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper) {
                    return;
                }
                if (swiper.thumbs.swiperCreated && thumbsSwiper) {
                    thumbsSwiper.destroy();
                }
            }
        }
    };
    var components = [ Device$1, Support$1, Browser$1, Resize, Observer$1, Virtual$1, Keyboard$1, Mousewheel$1, Navigation$1, Pagination$1, Scrollbar$1, Parallax$1, Zoom$1, Lazy$1, Controller$1, A11y, History$1, HashNavigation$1, Autoplay$1, EffectFade, EffectCube, EffectFlip, EffectCoverflow, Thumbs$1 ];
    if (typeof Swiper.use === "undefined") {
        Swiper.use = Swiper.Class.use;
        Swiper.installModule = Swiper.Class.installModule;
    }
    Swiper.use(components);
    return Swiper;
});

(function(document, $) {
    var proto = $.fn, details, isOpera = Object.prototype.toString.call(window.opera) == "[object Opera]", isDetailsSupported = function(doc) {
        var el = doc.createElement("details"), fake, root, diff;
        if (!("open" in el)) {
            return false;
        }
        root = doc.body || function() {
            var de = doc.documentElement;
            fake = true;
            return de.insertBefore(doc.createElement("body"), de.firstElementChild || de.firstChild);
        }();
        el.innerHTML = "<summary>a</summary>b";
        el.style.display = "block";
        root.appendChild(el);
        diff = el.offsetHeight;
        el.open = true;
        diff = diff != el.offsetHeight;
        root.removeChild(el);
        if (fake) {
            root.parentNode.removeChild(root);
        }
        return diff;
    }(document), toggleOpen = function($details, $detailsSummary, $detailsNotSummary, toggle) {
        var isOpen = $details.prop("open"), close = isOpen && toggle || !isOpen && !toggle;
        if (close) {
            $details.removeClass("open").prop("open", false).triggerHandler("close.details");
            $detailsSummary.attr("aria-expanded", false);
            $detailsNotSummary.hide();
        } else {
            $details.addClass("open").prop("open", true).triggerHandler("open.details");
            $detailsSummary.attr("aria-expanded", true);
            $detailsNotSummary.show();
        }
    };
    proto.noSelect = function() {
        var none = "none";
        return this.bind("selectstart dragstart mousedown", function() {
            return false;
        }).css({
            MozUserSelect: none,
            msUserSelect: none,
            webkitUserSelect: none,
            userSelect: none
        });
    };
    if (isDetailsSupported) {
        details = proto.details = function() {
            return this.each(function(index) {
                var $details = $(this), $summary = $("summary", $details).first();
                if (!$details.attr("id")) {
                    $details.attr("id", "details-id-" + index);
                }
                $details.attr("role", "group");
                $summary.attr({
                    role: "button",
                    "aria-expanded": $details.prop("open"),
                    "aria-controls": $details.attr("id")
                }).on("click", function() {
                    var close = $details.prop("open");
                    $summary.attr("aria-expanded", !close);
                    $details.triggerHandler((close ? "close" : "open") + ".details");
                });
            });
        };
        details.support = isDetailsSupported;
    } else {
        details = proto.details = function() {
            return this.each(function(index) {
                var $details = $(this), $detailsSummary = $("summary", $details).first(), $detailsNotSummary = $details.children(":not(summary)"), $detailsNotSummaryContents = $details.contents(":not(summary)");
                if (!$details.attr("id")) {
                    $details.attr("id", "details-id-" + index);
                }
                $details.attr("role", "group");
                if (!$detailsSummary.length) {
                    $detailsSummary = $("<summary>").text("Details").prependTo($details);
                }
                if ($detailsNotSummary.length != $detailsNotSummaryContents.length) {
                    $detailsNotSummaryContents.filter(function() {
                        return this.nodeType == 3 && /[^ \t\n\f\r]/.test(this.data);
                    }).wrap("<span>");
                    $detailsNotSummary = $details.children(":not(summary)");
                }
                $details.prop("open", typeof $details.attr("open") == "string");
                toggleOpen($details, $detailsSummary, $detailsNotSummary);
                $detailsSummary.attr({
                    role: "button",
                    "aria-controls": $details.attr("id")
                }).noSelect().prop("tabIndex", 0).on("click", function() {
                    $detailsSummary.focus();
                    toggleOpen($details, $detailsSummary, $detailsNotSummary, true);
                }).keyup(function(event) {
                    if (32 == event.keyCode || 13 == event.keyCode && !isOpera) {
                        event.preventDefault();
                        $detailsSummary.click();
                    }
                });
            });
        };
        details.support = isDetailsSupported;
    }
})(document, jQuery);

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = function(root, jQuery) {
            if (jQuery === undefined) {
                if (typeof window !== "undefined") {
                    jQuery = require("jquery");
                } else {
                    jQuery = require("jquery")(root);
                }
            }
            factory(jQuery);
            return jQuery;
        };
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var w = window;
    $.fn.confirm = function(options, option2) {
        if (typeof options === "undefined") options = {};
        if (typeof options === "string") {
            options = {
                content: options,
                title: option2 ? option2 : false
            };
        }
        $(this).each(function() {
            var $this = $(this);
            if ($this.attr("jc-attached")) {
                console.warn("jConfirm has already been attached to this element ", $this[0]);
                return;
            }
            $this.on("click", function(e) {
                e.preventDefault();
                var jcOption = $.extend({}, options);
                if ($this.attr("data-title")) jcOption["title"] = $this.attr("data-title");
                if ($this.attr("data-content")) jcOption["content"] = $this.attr("data-content");
                if (typeof jcOption["buttons"] === "undefined") jcOption["buttons"] = {};
                jcOption["$target"] = $this;
                if ($this.attr("href") && Object.keys(jcOption["buttons"]).length === 0) {
                    var buttons = $.extend(true, {}, w.jconfirm.pluginDefaults.defaultButtons, (w.jconfirm.defaults || {}).defaultButtons || {});
                    var firstBtn = Object.keys(buttons)[0];
                    jcOption["buttons"] = buttons;
                    jcOption.buttons[firstBtn].action = function() {
                        location.href = $this.attr("href");
                    };
                }
                jcOption["closeIcon"] = false;
                var instance = $.confirm(jcOption);
            });
            $this.attr("jc-attached", true);
        });
        return $(this);
    };
    $.confirm = function(options, option2) {
        if (typeof options === "undefined") options = {};
        if (typeof options === "string") {
            options = {
                content: options,
                title: option2 ? option2 : false
            };
        }
        var putDefaultButtons = !(options["buttons"] === false);
        if (typeof options["buttons"] !== "object") options["buttons"] = {};
        if (Object.keys(options["buttons"]).length === 0 && putDefaultButtons) {
            var buttons = $.extend(true, {}, w.jconfirm.pluginDefaults.defaultButtons, (w.jconfirm.defaults || {}).defaultButtons || {});
            options["buttons"] = buttons;
        }
        return w.jconfirm(options);
    };
    $.alert = function(options, option2) {
        if (typeof options === "undefined") options = {};
        if (typeof options === "string") {
            options = {
                content: options,
                title: option2 ? option2 : false
            };
        }
        var putDefaultButtons = !(options["buttons"] === false);
        if (typeof options.buttons !== "object") options.buttons = {};
        if (Object.keys(options["buttons"]).length === 0 && putDefaultButtons) {
            var buttons = $.extend(true, {}, w.jconfirm.pluginDefaults.defaultButtons, (w.jconfirm.defaults || {}).defaultButtons || {});
            var firstBtn = Object.keys(buttons)[0];
            options["buttons"][firstBtn] = buttons[firstBtn];
        }
        return w.jconfirm(options);
    };
    $.dialog = function(options, option2) {
        if (typeof options === "undefined") options = {};
        if (typeof options === "string") {
            options = {
                content: options,
                title: option2 ? option2 : false,
                closeIcon: function() {}
            };
        }
        options["buttons"] = {};
        if (typeof options["closeIcon"] === "undefined") {
            options["closeIcon"] = function() {};
        }
        options.confirmKeys = [ 13 ];
        return w.jconfirm(options);
    };
    w.jconfirm = function(options) {
        if (typeof options === "undefined") options = {};
        var pluginOptions = $.extend(true, {}, w.jconfirm.pluginDefaults);
        if (w.jconfirm.defaults) {
            pluginOptions = $.extend(true, pluginOptions, w.jconfirm.defaults);
        }
        pluginOptions = $.extend(true, {}, pluginOptions, options);
        var instance = new w.Jconfirm(pluginOptions);
        w.jconfirm.instances.push(instance);
        return instance;
    };
    w.Jconfirm = function(options) {
        $.extend(this, options);
        this._init();
    };
    w.Jconfirm.prototype = {
        _init: function() {
            var that = this;
            if (!w.jconfirm.instances.length) w.jconfirm.lastFocused = $("body").find(":focus");
            this._id = Math.round(Math.random() * 99999);
            this.contentParsed = $(document.createElement("div"));
            if (!this.lazyOpen) {
                setTimeout(function() {
                    that.open();
                }, 0);
            }
        },
        _buildHTML: function() {
            var that = this;
            this._parseAnimation(this.animation, "o");
            this._parseAnimation(this.closeAnimation, "c");
            this._parseBgDismissAnimation(this.backgroundDismissAnimation);
            this._parseColumnClass(this.columnClass);
            this._parseTheme(this.theme);
            this._parseType(this.type);
            var template = $(this.template);
            template.find(".jconfirm-box").addClass(this.animationParsed).addClass(this.backgroundDismissAnimationParsed).addClass(this.typeParsed);
            if (this.typeAnimated) template.find(".jconfirm-box").addClass("jconfirm-type-animated");
            if (this.useBootstrap) {
                template.find(".jc-bs3-row").addClass(this.bootstrapClasses.row);
                template.find(".jc-bs3-row").addClass("justify-content-md-center justify-content-sm-center justify-content-xs-center justify-content-lg-center");
                template.find(".jconfirm-box-container").addClass(this.columnClassParsed);
                if (this.containerFluid) template.find(".jc-bs3-container").addClass(this.bootstrapClasses.containerFluid); else template.find(".jc-bs3-container").addClass(this.bootstrapClasses.container);
            } else {
                template.find(".jconfirm-box").css("width", this.boxWidth);
            }
            if (this.titleClass) template.find(".jconfirm-title-c").addClass(this.titleClass);
            template.addClass(this.themeParsed);
            var ariaLabel = "jconfirm-box" + this._id;
            template.find(".jconfirm-box").attr("aria-labelledby", ariaLabel).attr("tabindex", -1);
            template.find(".jconfirm-content").attr("id", ariaLabel);
            if (this.bgOpacity !== null) template.find(".jconfirm-bg").css("opacity", this.bgOpacity);
            if (this.rtl) template.addClass("jconfirm-rtl");
            this.$el = template.appendTo(this.container);
            this.$jconfirmBoxContainer = this.$el.find(".jconfirm-box-container");
            this.$jconfirmBox = this.$body = this.$el.find(".jconfirm-box");
            this.$jconfirmBg = this.$el.find(".jconfirm-bg");
            this.$title = this.$el.find(".jconfirm-title");
            this.$titleContainer = this.$el.find(".jconfirm-title-c");
            this.$content = this.$el.find("div.jconfirm-content");
            this.$contentPane = this.$el.find(".jconfirm-content-pane");
            this.$icon = this.$el.find(".jconfirm-icon-c");
            this.$closeIcon = this.$el.find(".jconfirm-closeIcon");
            this.$holder = this.$el.find(".jconfirm-holder");
            this.$btnc = this.$el.find(".jconfirm-buttons");
            this.$scrollPane = this.$el.find(".jconfirm-scrollpane");
            that.setStartingPoint();
            this._contentReady = $.Deferred();
            this._modalReady = $.Deferred();
            this.$holder.css({
                "padding-top": this.offsetTop,
                "padding-bottom": this.offsetBottom
            });
            this.setTitle();
            this.setIcon();
            this._setButtons();
            this._parseContent();
            this.initDraggable();
            if (this.isAjax) this.showLoading(false);
            $.when(this._contentReady, this._modalReady).then(function() {
                if (that.isAjaxLoading) setTimeout(function() {
                    that.isAjaxLoading = false;
                    that.setContent();
                    that.setTitle();
                    that.setIcon();
                    setTimeout(function() {
                        that.hideLoading(false);
                        that._updateContentMaxHeight();
                    }, 100);
                    if (typeof that.onContentReady === "function") that.onContentReady();
                }, 50); else {
                    that._updateContentMaxHeight();
                    that.setTitle();
                    that.setIcon();
                    if (typeof that.onContentReady === "function") that.onContentReady();
                }
                if (that.autoClose) that._startCountDown();
            }).then(function() {
                that._watchContent();
            });
            if (this.animation === "none") {
                this.animationSpeed = 1;
                this.animationBounce = 1;
            }
            this.$body.css(this._getCSS(this.animationSpeed, this.animationBounce));
            this.$contentPane.css(this._getCSS(this.animationSpeed, 1));
            this.$jconfirmBg.css(this._getCSS(this.animationSpeed, 1));
            this.$jconfirmBoxContainer.css(this._getCSS(this.animationSpeed, 1));
        },
        _typePrefix: "jconfirm-type-",
        typeParsed: "",
        _parseType: function(type) {
            this.typeParsed = this._typePrefix + type;
        },
        setType: function(type) {
            var oldClass = this.typeParsed;
            this._parseType(type);
            this.$jconfirmBox.removeClass(oldClass).addClass(this.typeParsed);
        },
        themeParsed: "",
        _themePrefix: "jconfirm-",
        setTheme: function(theme) {
            var previous = this.theme;
            this.theme = theme || this.theme;
            this._parseTheme(this.theme);
            if (previous) this.$el.removeClass(previous);
            this.$el.addClass(this.themeParsed);
            this.theme = theme;
        },
        _parseTheme: function(theme) {
            var that = this;
            theme = theme.split(",");
            $.each(theme, function(k, a) {
                if (a.indexOf(that._themePrefix) === -1) theme[k] = that._themePrefix + $.trim(a);
            });
            this.themeParsed = theme.join(" ").toLowerCase();
        },
        backgroundDismissAnimationParsed: "",
        _bgDismissPrefix: "jconfirm-hilight-",
        _parseBgDismissAnimation: function(bgDismissAnimation) {
            var animation = bgDismissAnimation.split(",");
            var that = this;
            $.each(animation, function(k, a) {
                if (a.indexOf(that._bgDismissPrefix) === -1) animation[k] = that._bgDismissPrefix + $.trim(a);
            });
            this.backgroundDismissAnimationParsed = animation.join(" ").toLowerCase();
        },
        animationParsed: "",
        closeAnimationParsed: "",
        _animationPrefix: "jconfirm-animation-",
        setAnimation: function(animation) {
            this.animation = animation || this.animation;
            this._parseAnimation(this.animation, "o");
        },
        _parseAnimation: function(animation, which) {
            which = which || "o";
            var animations = animation.split(",");
            var that = this;
            $.each(animations, function(k, a) {
                if (a.indexOf(that._animationPrefix) === -1) animations[k] = that._animationPrefix + $.trim(a);
            });
            var a_string = animations.join(" ").toLowerCase();
            if (which === "o") this.animationParsed = a_string; else this.closeAnimationParsed = a_string;
            return a_string;
        },
        setCloseAnimation: function(closeAnimation) {
            this.closeAnimation = closeAnimation || this.closeAnimation;
            this._parseAnimation(this.closeAnimation, "c");
        },
        setAnimationSpeed: function(speed) {
            this.animationSpeed = speed || this.animationSpeed;
        },
        columnClassParsed: "",
        setColumnClass: function(colClass) {
            if (!this.useBootstrap) {
                console.warn("cannot set columnClass, useBootstrap is set to false");
                return;
            }
            this.columnClass = colClass || this.columnClass;
            this._parseColumnClass(this.columnClass);
            this.$jconfirmBoxContainer.addClass(this.columnClassParsed);
        },
        _updateContentMaxHeight: function() {
            var height = $(window).height() - (this.$jconfirmBox.outerHeight() - this.$contentPane.outerHeight()) - (this.offsetTop + this.offsetBottom);
            this.$contentPane.css({
                "max-height": height + "px"
            });
        },
        setBoxWidth: function(width) {
            if (this.useBootstrap) {
                console.warn("cannot set boxWidth, useBootstrap is set to true");
                return;
            }
            this.boxWidth = width;
            this.$jconfirmBox.css("width", width);
        },
        _parseColumnClass: function(colClass) {
            colClass = colClass.toLowerCase();
            var p;
            switch (colClass) {
              case "xl":
              case "xlarge":
                p = "col-md-12";
                break;

              case "l":
              case "large":
                p = "col-md-8 col-md-offset-2";
                break;

              case "m":
              case "medium":
                p = "col-md-6 col-md-offset-3";
                break;

              case "s":
              case "small":
                p = "col-md-4 col-md-offset-4";
                break;

              case "xs":
              case "xsmall":
                p = "col-md-2 col-md-offset-5";
                break;

              default:
                p = colClass;
            }
            this.columnClassParsed = p;
        },
        initDraggable: function() {
            var that = this;
            var $t = this.$titleContainer;
            this.resetDrag();
            if (this.draggable) {
                $t.on("mousedown", function(e) {
                    $t.addClass("jconfirm-hand");
                    that.mouseX = e.clientX;
                    that.mouseY = e.clientY;
                    that.isDrag = true;
                });
                $(window).on("mousemove." + this._id, function(e) {
                    if (that.isDrag) {
                        that.movingX = e.clientX - that.mouseX + that.initialX;
                        that.movingY = e.clientY - that.mouseY + that.initialY;
                        that.setDrag();
                    }
                });
                $(window).on("mouseup." + this._id, function() {
                    $t.removeClass("jconfirm-hand");
                    if (that.isDrag) {
                        that.isDrag = false;
                        that.initialX = that.movingX;
                        that.initialY = that.movingY;
                    }
                });
            }
        },
        resetDrag: function() {
            this.isDrag = false;
            this.initialX = 0;
            this.initialY = 0;
            this.movingX = 0;
            this.movingY = 0;
            this.mouseX = 0;
            this.mouseY = 0;
            this.$jconfirmBoxContainer.css("transform", "translate(" + 0 + "px, " + 0 + "px)");
        },
        setDrag: function() {
            if (!this.draggable) return;
            this.alignMiddle = false;
            var boxWidth = this.$jconfirmBox.outerWidth();
            var boxHeight = this.$jconfirmBox.outerHeight();
            var windowWidth = $(window).width();
            var windowHeight = $(window).height();
            var that = this;
            var dragUpdate = 1;
            if (that.movingX % dragUpdate === 0 || that.movingY % dragUpdate === 0) {
                if (that.dragWindowBorder) {
                    var leftDistance = windowWidth / 2 - boxWidth / 2;
                    var topDistance = windowHeight / 2 - boxHeight / 2;
                    topDistance -= that.dragWindowGap;
                    leftDistance -= that.dragWindowGap;
                    if (leftDistance + that.movingX < 0) {
                        that.movingX = -leftDistance;
                    } else if (leftDistance - that.movingX < 0) {
                        that.movingX = leftDistance;
                    }
                    if (topDistance + that.movingY < 0) {
                        that.movingY = -topDistance;
                    } else if (topDistance - that.movingY < 0) {
                        that.movingY = topDistance;
                    }
                }
                that.$jconfirmBoxContainer.css("transform", "translate(" + that.movingX + "px, " + that.movingY + "px)");
            }
        },
        _scrollTop: function() {
            if (typeof pageYOffset !== "undefined") {
                return pageYOffset;
            } else {
                var B = document.body;
                var D = document.documentElement;
                D = D.clientHeight ? D : B;
                return D.scrollTop;
            }
        },
        _watchContent: function() {
            var that = this;
            if (this._timer) clearInterval(this._timer);
            var prevContentHeight = 0;
            this._timer = setInterval(function() {
                if (that.smoothContent) {
                    var contentHeight = that.$content.outerHeight() || 0;
                    if (contentHeight !== prevContentHeight) {
                        prevContentHeight = contentHeight;
                    }
                    var wh = $(window).height();
                    var total = that.offsetTop + that.offsetBottom + that.$jconfirmBox.height() - that.$contentPane.height() + that.$content.height();
                    if (total < wh) {
                        that.$contentPane.addClass("no-scroll");
                    } else {
                        that.$contentPane.removeClass("no-scroll");
                    }
                }
            }, this.watchInterval);
        },
        _overflowClass: "jconfirm-overflow",
        _hilightAnimating: false,
        highlight: function() {
            this.hiLightModal();
        },
        hiLightModal: function() {
            var that = this;
            if (this._hilightAnimating) return;
            that.$body.addClass("hilight");
            var duration = parseFloat(that.$body.css("animation-duration")) || 2;
            this._hilightAnimating = true;
            setTimeout(function() {
                that._hilightAnimating = false;
                that.$body.removeClass("hilight");
            }, duration * 1e3);
        },
        _bindEvents: function() {
            var that = this;
            this.boxClicked = false;
            this.$scrollPane.click(function(e) {
                if (!that.boxClicked) {
                    var buttonName = false;
                    var shouldClose = false;
                    var str;
                    if (typeof that.backgroundDismiss === "function") str = that.backgroundDismiss(); else str = that.backgroundDismiss;
                    if (typeof str === "string" && typeof that.buttons[str] !== "undefined") {
                        buttonName = str;
                        shouldClose = false;
                    } else if (typeof str === "undefined" || !!str === true) {
                        shouldClose = true;
                    } else {
                        shouldClose = false;
                    }
                    if (buttonName) {
                        var btnResponse = that.buttons[buttonName].action.apply(that);
                        shouldClose = typeof btnResponse === "undefined" || !!btnResponse;
                    }
                    if (shouldClose) that.close(); else that.hiLightModal();
                }
                that.boxClicked = false;
            });
            this.$jconfirmBox.click(function(e) {
                that.boxClicked = true;
            });
            var isKeyDown = false;
            $(window).on("jcKeyDown." + that._id, function(e) {
                if (!isKeyDown) {
                    isKeyDown = true;
                }
            });
            $(window).on("keyup." + that._id, function(e) {
                if (isKeyDown) {
                    that.reactOnKey(e);
                    isKeyDown = false;
                }
            });
            $(window).on("resize." + this._id, function() {
                that._updateContentMaxHeight();
                setTimeout(function() {
                    that.resetDrag();
                }, 100);
            });
        },
        _cubic_bezier: "0.36, 0.55, 0.19",
        _getCSS: function(speed, bounce) {
            return {
                "-webkit-transition-duration": speed / 1e3 + "s",
                "transition-duration": speed / 1e3 + "s",
                "-webkit-transition-timing-function": "cubic-bezier(" + this._cubic_bezier + ", " + bounce + ")",
                "transition-timing-function": "cubic-bezier(" + this._cubic_bezier + ", " + bounce + ")"
            };
        },
        _setButtons: function() {
            var that = this;
            var total_buttons = 0;
            if (typeof this.buttons !== "object") this.buttons = {};
            $.each(this.buttons, function(key, button) {
                total_buttons += 1;
                if (typeof button === "function") {
                    that.buttons[key] = button = {
                        action: button
                    };
                }
                that.buttons[key].text = button.text || key;
                that.buttons[key].btnClass = button.btnClass || "btn-default";
                that.buttons[key].action = button.action || function() {};
                that.buttons[key].keys = button.keys || [];
                that.buttons[key].isHidden = button.isHidden || false;
                that.buttons[key].isDisabled = button.isDisabled || false;
                $.each(that.buttons[key].keys, function(i, a) {
                    that.buttons[key].keys[i] = a.toLowerCase();
                });
                var button_element = $('<button type="button" class="btn"></button>').html(that.buttons[key].text).addClass(that.buttons[key].btnClass).prop("disabled", that.buttons[key].isDisabled).css("display", that.buttons[key].isHidden ? "none" : "").click(function(e) {
                    e.preventDefault();
                    var res = that.buttons[key].action.apply(that, [ that.buttons[key] ]);
                    that.onAction.apply(that, [ key, that.buttons[key] ]);
                    that._stopCountDown();
                    if (typeof res === "undefined" || res) that.close();
                });
                that.buttons[key].el = button_element;
                that.buttons[key].setText = function(text) {
                    button_element.html(text);
                };
                that.buttons[key].addClass = function(className) {
                    button_element.addClass(className);
                };
                that.buttons[key].removeClass = function(className) {
                    button_element.removeClass(className);
                };
                that.buttons[key].disable = function() {
                    that.buttons[key].isDisabled = true;
                    button_element.prop("disabled", true);
                };
                that.buttons[key].enable = function() {
                    that.buttons[key].isDisabled = false;
                    button_element.prop("disabled", false);
                };
                that.buttons[key].show = function() {
                    that.buttons[key].isHidden = false;
                    button_element.css("display", "");
                };
                that.buttons[key].hide = function() {
                    that.buttons[key].isHidden = true;
                    button_element.css("display", "none");
                };
                that["$_" + key] = that["$$" + key] = button_element;
                that.$btnc.append(button_element);
            });
            if (total_buttons === 0) this.$btnc.hide();
            if (this.closeIcon === null && total_buttons === 0) {
                this.closeIcon = true;
            }
            if (this.closeIcon) {
                if (this.closeIconClass) {
                    var closeHtml = '<i class="' + this.closeIconClass + '"></i>';
                    this.$closeIcon.html(closeHtml);
                }
                this.$closeIcon.click(function(e) {
                    e.preventDefault();
                    var buttonName = false;
                    var shouldClose = false;
                    var str;
                    if (typeof that.closeIcon === "function") {
                        str = that.closeIcon();
                    } else {
                        str = that.closeIcon;
                    }
                    if (typeof str === "string" && typeof that.buttons[str] !== "undefined") {
                        buttonName = str;
                        shouldClose = false;
                    } else if (typeof str === "undefined" || !!str === true) {
                        shouldClose = true;
                    } else {
                        shouldClose = false;
                    }
                    if (buttonName) {
                        var btnResponse = that.buttons[buttonName].action.apply(that);
                        shouldClose = typeof btnResponse === "undefined" || !!btnResponse;
                    }
                    if (shouldClose) {
                        that.close();
                    }
                });
                this.$closeIcon.show();
            } else {
                this.$closeIcon.hide();
            }
        },
        setTitle: function(string, force) {
            force = force || false;
            if (typeof string !== "undefined") if (typeof string === "string") this.title = string; else if (typeof string === "function") {
                if (typeof string.promise === "function") console.error("Promise was returned from title function, this is not supported.");
                var response = string();
                if (typeof response === "string") this.title = response; else this.title = false;
            } else this.title = false;
            if (this.isAjaxLoading && !force) return;
            this.$title.html(this.title || "");
            this.updateTitleContainer();
        },
        setIcon: function(iconClass, force) {
            force = force || false;
            if (typeof iconClass !== "undefined") if (typeof iconClass === "string") this.icon = iconClass; else if (typeof iconClass === "function") {
                var response = iconClass();
                if (typeof response === "string") this.icon = response; else this.icon = false;
            } else this.icon = false;
            if (this.isAjaxLoading && !force) return;
            this.$icon.html(this.icon ? '<i class="' + this.icon + '"></i>' : "");
            this.updateTitleContainer();
        },
        updateTitleContainer: function() {
            if (!this.title && !this.icon) {
                this.$titleContainer.hide();
            } else {
                this.$titleContainer.show();
            }
        },
        setContentPrepend: function(content, force) {
            if (!content) return;
            this.contentParsed.prepend(content);
        },
        setContentAppend: function(content) {
            if (!content) return;
            this.contentParsed.append(content);
        },
        setContent: function(content, force) {
            force = !!force;
            var that = this;
            if (content) this.contentParsed.html("").append(content);
            if (this.isAjaxLoading && !force) return;
            this.$content.html("");
            this.$content.append(this.contentParsed);
            setTimeout(function() {
                that.$body.find("input[autofocus]:visible:first").focus();
            }, 100);
        },
        loadingSpinner: false,
        showLoading: function(disableButtons) {
            this.loadingSpinner = true;
            this.$jconfirmBox.addClass("loading");
            if (disableButtons) this.$btnc.find("button").prop("disabled", true);
        },
        hideLoading: function(enableButtons) {
            this.loadingSpinner = false;
            this.$jconfirmBox.removeClass("loading");
            if (enableButtons) this.$btnc.find("button").prop("disabled", false);
        },
        ajaxResponse: false,
        contentParsed: "",
        isAjax: false,
        isAjaxLoading: false,
        _parseContent: function() {
            var that = this;
            var e = "&nbsp;";
            if (typeof this.content === "function") {
                var res = this.content.apply(this);
                if (typeof res === "string") {
                    this.content = res;
                } else if (typeof res === "object" && typeof res.always === "function") {
                    this.isAjax = true;
                    this.isAjaxLoading = true;
                    res.always(function(data, status, xhr) {
                        that.ajaxResponse = {
                            data: data,
                            status: status,
                            xhr: xhr
                        };
                        that._contentReady.resolve(data, status, xhr);
                        if (typeof that.contentLoaded === "function") that.contentLoaded(data, status, xhr);
                    });
                    this.content = e;
                } else {
                    this.content = e;
                }
            }
            if (typeof this.content === "string" && this.content.substr(0, 4).toLowerCase() === "url:") {
                this.isAjax = true;
                this.isAjaxLoading = true;
                var u = this.content.substring(4, this.content.length);
                $.get(u).done(function(html) {
                    that.contentParsed.html(html);
                }).always(function(data, status, xhr) {
                    that.ajaxResponse = {
                        data: data,
                        status: status,
                        xhr: xhr
                    };
                    that._contentReady.resolve(data, status, xhr);
                    if (typeof that.contentLoaded === "function") that.contentLoaded(data, status, xhr);
                });
            }
            if (!this.content) this.content = e;
            if (!this.isAjax) {
                this.contentParsed.html(this.content);
                this.setContent();
                that._contentReady.resolve();
            }
        },
        _stopCountDown: function() {
            clearInterval(this.autoCloseInterval);
            if (this.$cd) this.$cd.remove();
        },
        _startCountDown: function() {
            var that = this;
            var opt = this.autoClose.split("|");
            if (opt.length !== 2) {
                console.error("Invalid option for autoClose. example 'close|10000'");
                return false;
            }
            var button_key = opt[0];
            var time = parseInt(opt[1]);
            if (typeof this.buttons[button_key] === "undefined") {
                console.error("Invalid button key '" + button_key + "' for autoClose");
                return false;
            }
            var seconds = Math.ceil(time / 1e3);
            this.$cd = $('<span class="countdown"> (' + seconds + ")</span>").appendTo(this["$_" + button_key]);
            this.autoCloseInterval = setInterval(function() {
                that.$cd.html(" (" + (seconds -= 1) + ") ");
                if (seconds <= 0) {
                    that["$$" + button_key].trigger("click");
                    that._stopCountDown();
                }
            }, 1e3);
        },
        _getKey: function(key) {
            switch (key) {
              case 192:
                return "tilde";

              case 13:
                return "enter";

              case 16:
                return "shift";

              case 9:
                return "tab";

              case 20:
                return "capslock";

              case 17:
                return "ctrl";

              case 91:
                return "win";

              case 18:
                return "alt";

              case 27:
                return "esc";

              case 32:
                return "space";
            }
            var initial = String.fromCharCode(key);
            if (/^[A-z0-9]+$/.test(initial)) return initial.toLowerCase(); else return false;
        },
        reactOnKey: function(e) {
            var that = this;
            var a = $(".jconfirm");
            if (a.eq(a.length - 1)[0] !== this.$el[0]) return false;
            var key = e.which;
            if (this.$content.find(":input").is(":focus") && /13|32/.test(key)) return false;
            var keyChar = this._getKey(key);
            if (keyChar === "esc" && this.escapeKey) {
                if (this.escapeKey === true) {
                    this.$scrollPane.trigger("click");
                } else if (typeof this.escapeKey === "string" || typeof this.escapeKey === "function") {
                    var buttonKey;
                    if (typeof this.escapeKey === "function") {
                        buttonKey = this.escapeKey();
                    } else {
                        buttonKey = this.escapeKey;
                    }
                    if (buttonKey) if (typeof this.buttons[buttonKey] === "undefined") {
                        console.warn("Invalid escapeKey, no buttons found with key " + buttonKey);
                    } else {
                        this["$_" + buttonKey].trigger("click");
                    }
                }
            }
            $.each(this.buttons, function(key, button) {
                if (button.keys.indexOf(keyChar) !== -1) {
                    that["$_" + key].trigger("click");
                }
            });
        },
        setDialogCenter: function() {
            console.info("setDialogCenter is deprecated, dialogs are centered with CSS3 tables");
        },
        _unwatchContent: function() {
            clearInterval(this._timer);
        },
        close: function(onClosePayload) {
            var that = this;
            if (typeof this.onClose === "function") this.onClose(onClosePayload);
            this._unwatchContent();
            $(window).unbind("resize." + this._id);
            $(window).unbind("keyup." + this._id);
            $(window).unbind("jcKeyDown." + this._id);
            if (this.draggable) {
                $(window).unbind("mousemove." + this._id);
                $(window).unbind("mouseup." + this._id);
                this.$titleContainer.unbind("mousedown");
            }
            that.$el.removeClass(that.loadedClass);
            $("body").removeClass("jconfirm-no-scroll-" + that._id);
            that.$jconfirmBoxContainer.removeClass("jconfirm-no-transition");
            setTimeout(function() {
                that.$body.addClass(that.closeAnimationParsed);
                that.$jconfirmBg.addClass("jconfirm-bg-h");
                var closeTimer = that.closeAnimation === "none" ? 1 : that.animationSpeed;
                setTimeout(function() {
                    that.$el.remove();
                    var l = w.jconfirm.instances;
                    var i = w.jconfirm.instances.length - 1;
                    for (i; i >= 0; i--) {
                        if (w.jconfirm.instances[i]._id === that._id) {
                            w.jconfirm.instances.splice(i, 1);
                        }
                    }
                    if (!w.jconfirm.instances.length) {
                        if (that.scrollToPreviousElement && w.jconfirm.lastFocused && w.jconfirm.lastFocused.length && $.contains(document, w.jconfirm.lastFocused[0])) {
                            var $lf = w.jconfirm.lastFocused;
                            if (that.scrollToPreviousElementAnimate) {
                                var st = $(window).scrollTop();
                                var ot = w.jconfirm.lastFocused.offset().top;
                                var wh = $(window).height();
                                if (!(ot > st && ot < st + wh)) {
                                    var scrollTo = ot - Math.round(wh / 3);
                                    $("html, body").animate({
                                        scrollTop: scrollTo
                                    }, that.animationSpeed, "swing", function() {
                                        $lf.focus();
                                    });
                                } else {
                                    $lf.focus();
                                }
                            } else {
                                $lf.focus();
                            }
                            w.jconfirm.lastFocused = false;
                        }
                    }
                    if (typeof that.onDestroy === "function") that.onDestroy();
                }, closeTimer * .4);
            }, 50);
            return true;
        },
        open: function() {
            if (this.isOpen()) return false;
            this._buildHTML();
            this._bindEvents();
            this._open();
            return true;
        },
        setStartingPoint: function() {
            var el = false;
            if (this.animateFromElement !== true && this.animateFromElement) {
                el = this.animateFromElement;
                w.jconfirm.lastClicked = false;
            } else if (w.jconfirm.lastClicked && this.animateFromElement === true) {
                el = w.jconfirm.lastClicked;
                w.jconfirm.lastClicked = false;
            } else {
                return false;
            }
            if (!el) return false;
            var offset = el.offset();
            var iTop = el.outerHeight() / 2;
            var iLeft = el.outerWidth() / 2;
            iTop -= this.$jconfirmBox.outerHeight() / 2;
            iLeft -= this.$jconfirmBox.outerWidth() / 2;
            var sourceTop = offset.top + iTop;
            sourceTop = sourceTop - this._scrollTop();
            var sourceLeft = offset.left + iLeft;
            var wh = $(window).height() / 2;
            var ww = $(window).width() / 2;
            var targetH = wh - this.$jconfirmBox.outerHeight() / 2;
            var targetW = ww - this.$jconfirmBox.outerWidth() / 2;
            sourceTop -= targetH;
            sourceLeft -= targetW;
            if (Math.abs(sourceTop) > wh || Math.abs(sourceLeft) > ww) return false;
            this.$jconfirmBoxContainer.css("transform", "translate(" + sourceLeft + "px, " + sourceTop + "px)");
        },
        _open: function() {
            var that = this;
            if (typeof that.onOpenBefore === "function") that.onOpenBefore();
            this.$body.removeClass(this.animationParsed);
            this.$jconfirmBg.removeClass("jconfirm-bg-h");
            this.$body.focus();
            that.$jconfirmBoxContainer.css("transform", "translate(" + 0 + "px, " + 0 + "px)");
            setTimeout(function() {
                that.$body.css(that._getCSS(that.animationSpeed, 1));
                that.$body.css({
                    "transition-property": that.$body.css("transition-property") + ", margin"
                });
                that.$jconfirmBoxContainer.addClass("jconfirm-no-transition");
                that._modalReady.resolve();
                if (typeof that.onOpen === "function") that.onOpen();
                that.$el.addClass(that.loadedClass);
            }, this.animationSpeed);
        },
        loadedClass: "jconfirm-open",
        isClosed: function() {
            return !this.$el || this.$el.parent().length === 0;
        },
        isOpen: function() {
            return !this.isClosed();
        },
        toggle: function() {
            if (!this.isOpen()) this.open(); else this.close();
        }
    };
    w.jconfirm.instances = [];
    w.jconfirm.lastFocused = false;
    w.jconfirm.pluginDefaults = {
        template: "" + '<div class="jconfirm">' + '<div class="jconfirm-bg jconfirm-bg-h"></div>' + '<div class="jconfirm-scrollpane">' + '<div class="jconfirm-row">' + '<div class="jconfirm-cell">' + '<div class="jconfirm-holder">' + '<div class="jc-bs3-container">' + '<div class="jc-bs3-row">' + '<div class="jconfirm-box-container jconfirm-animated">' + '<div class="jconfirm-box" role="dialog" aria-labelledby="labelled" tabindex="-1">' + '<div class="jconfirm-closeIcon">&times;</div>' + '<div class="jconfirm-title-c">' + '<span class="jconfirm-icon-c"></span>' + '<span class="jconfirm-title"></span>' + "</div>" + '<div class="jconfirm-content-pane">' + '<div class="jconfirm-content"></div>' + "</div>" + '<div class="jconfirm-buttons">' + "</div>" + '<div class="jconfirm-clear">' + "</div>" + "</div>" + "</div>" + "</div>" + "</div>" + "</div>" + "</div>" + "</div>" + "</div></div>",
        title: "Hello",
        titleClass: "",
        type: "default",
        typeAnimated: true,
        draggable: true,
        dragWindowGap: 15,
        dragWindowBorder: true,
        animateFromElement: true,
        alignMiddle: true,
        smoothContent: true,
        content: "Are you sure to continue?",
        buttons: {},
        defaultButtons: {
            ok: {
                action: function() {}
            },
            close: {
                action: function() {}
            }
        },
        contentLoaded: function() {},
        icon: "",
        lazyOpen: false,
        bgOpacity: null,
        theme: "light",
        animation: "scale",
        closeAnimation: "scale",
        animationSpeed: 400,
        animationBounce: 1,
        escapeKey: true,
        rtl: false,
        container: "body",
        containerFluid: false,
        backgroundDismiss: false,
        backgroundDismissAnimation: "shake",
        autoClose: false,
        closeIcon: null,
        closeIconClass: false,
        watchInterval: 100,
        columnClass: "col-md-4 col-md-offset-4 col-sm-6 col-sm-offset-3 col-xs-10 col-xs-offset-1",
        boxWidth: "50%",
        scrollToPreviousElement: true,
        scrollToPreviousElementAnimate: true,
        useBootstrap: true,
        offsetTop: 40,
        offsetBottom: 40,
        bootstrapClasses: {
            container: "container",
            containerFluid: "container-fluid",
            row: "row"
        },
        onContentReady: function() {},
        onOpenBefore: function() {},
        onOpen: function() {},
        onClose: function() {},
        onDestroy: function() {},
        onAction: function() {}
    };
    var keyDown = false;
    $(window).on("keydown", function(e) {
        if (!keyDown) {
            var $target = $(e.target);
            var pass = false;
            if ($target.closest(".jconfirm-box").length) pass = true;
            if (pass) $(window).trigger("jcKeyDown");
            keyDown = true;
        }
    });
    $(window).on("keyup", function() {
        keyDown = false;
    });
    w.jconfirm.lastClicked = false;
    $(document).on("mousedown", "button, a, [jc-source]", function() {
        w.jconfirm.lastClicked = $(this);
    });
});

(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }
        g.ProgressBar = f();
    }
})(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(require, module, exports) {
            (function() {
                var root = this || Function("return this")();
                var Tweenable = function() {
                    "use strict";
                    var formula;
                    var DEFAULT_SCHEDULE_FUNCTION;
                    var DEFAULT_EASING = "linear";
                    var DEFAULT_DURATION = 500;
                    var UPDATE_TIME = 1e3 / 60;
                    var _now = Date.now ? Date.now : function() {
                        return +new Date();
                    };
                    var now = typeof SHIFTY_DEBUG_NOW !== "undefined" ? SHIFTY_DEBUG_NOW : _now;
                    if (typeof window !== "undefined") {
                        DEFAULT_SCHEDULE_FUNCTION = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.mozCancelRequestAnimationFrame && window.mozRequestAnimationFrame || setTimeout;
                    } else {
                        DEFAULT_SCHEDULE_FUNCTION = setTimeout;
                    }
                    function noop() {}
                    function each(obj, fn) {
                        var key;
                        for (key in obj) {
                            if (Object.hasOwnProperty.call(obj, key)) {
                                fn(key);
                            }
                        }
                    }
                    function shallowCopy(targetObj, srcObj) {
                        each(srcObj, function(prop) {
                            targetObj[prop] = srcObj[prop];
                        });
                        return targetObj;
                    }
                    function defaults(target, src) {
                        each(src, function(prop) {
                            if (typeof target[prop] === "undefined") {
                                target[prop] = src[prop];
                            }
                        });
                    }
                    function tweenProps(forPosition, currentState, originalState, targetState, duration, timestamp, easing) {
                        var normalizedPosition = forPosition < timestamp ? 0 : (forPosition - timestamp) / duration;
                        var prop;
                        var easingObjectProp;
                        var easingFn;
                        for (prop in currentState) {
                            if (currentState.hasOwnProperty(prop)) {
                                easingObjectProp = easing[prop];
                                easingFn = typeof easingObjectProp === "function" ? easingObjectProp : formula[easingObjectProp];
                                currentState[prop] = tweenProp(originalState[prop], targetState[prop], easingFn, normalizedPosition);
                            }
                        }
                        return currentState;
                    }
                    function tweenProp(start, end, easingFunc, position) {
                        return start + (end - start) * easingFunc(position);
                    }
                    function applyFilter(tweenable, filterName) {
                        var filters = Tweenable.prototype.filter;
                        var args = tweenable._filterArgs;
                        each(filters, function(name) {
                            if (typeof filters[name][filterName] !== "undefined") {
                                filters[name][filterName].apply(tweenable, args);
                            }
                        });
                    }
                    var timeoutHandler_endTime;
                    var timeoutHandler_currentTime;
                    var timeoutHandler_isEnded;
                    var timeoutHandler_offset;
                    function timeoutHandler(tweenable, timestamp, delay, duration, currentState, originalState, targetState, easing, step, schedule, opt_currentTimeOverride) {
                        timeoutHandler_endTime = timestamp + delay + duration;
                        timeoutHandler_currentTime = Math.min(opt_currentTimeOverride || now(), timeoutHandler_endTime);
                        timeoutHandler_isEnded = timeoutHandler_currentTime >= timeoutHandler_endTime;
                        timeoutHandler_offset = duration - (timeoutHandler_endTime - timeoutHandler_currentTime);
                        if (tweenable.isPlaying()) {
                            if (timeoutHandler_isEnded) {
                                step(targetState, tweenable._attachment, timeoutHandler_offset);
                                tweenable.stop(true);
                            } else {
                                tweenable._scheduleId = schedule(tweenable._timeoutHandler, UPDATE_TIME);
                                applyFilter(tweenable, "beforeTween");
                                if (timeoutHandler_currentTime < timestamp + delay) {
                                    tweenProps(1, currentState, originalState, targetState, 1, 1, easing);
                                } else {
                                    tweenProps(timeoutHandler_currentTime, currentState, originalState, targetState, duration, timestamp + delay, easing);
                                }
                                applyFilter(tweenable, "afterTween");
                                step(currentState, tweenable._attachment, timeoutHandler_offset);
                            }
                        }
                    }
                    function composeEasingObject(fromTweenParams, easing) {
                        var composedEasing = {};
                        var typeofEasing = typeof easing;
                        if (typeofEasing === "string" || typeofEasing === "function") {
                            each(fromTweenParams, function(prop) {
                                composedEasing[prop] = easing;
                            });
                        } else {
                            each(fromTweenParams, function(prop) {
                                if (!composedEasing[prop]) {
                                    composedEasing[prop] = easing[prop] || DEFAULT_EASING;
                                }
                            });
                        }
                        return composedEasing;
                    }
                    function Tweenable(opt_initialState, opt_config) {
                        this._currentState = opt_initialState || {};
                        this._configured = false;
                        this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;
                        if (typeof opt_config !== "undefined") {
                            this.setConfig(opt_config);
                        }
                    }
                    Tweenable.prototype.tween = function(opt_config) {
                        if (this._isTweening) {
                            return this;
                        }
                        if (opt_config !== undefined || !this._configured) {
                            this.setConfig(opt_config);
                        }
                        this._timestamp = now();
                        this._start(this.get(), this._attachment);
                        return this.resume();
                    };
                    Tweenable.prototype.setConfig = function(config) {
                        config = config || {};
                        this._configured = true;
                        this._attachment = config.attachment;
                        this._pausedAtTime = null;
                        this._scheduleId = null;
                        this._delay = config.delay || 0;
                        this._start = config.start || noop;
                        this._step = config.step || noop;
                        this._finish = config.finish || noop;
                        this._duration = config.duration || DEFAULT_DURATION;
                        this._currentState = shallowCopy({}, config.from || this.get());
                        this._originalState = this.get();
                        this._targetState = shallowCopy({}, config.to || this.get());
                        var self = this;
                        this._timeoutHandler = function() {
                            timeoutHandler(self, self._timestamp, self._delay, self._duration, self._currentState, self._originalState, self._targetState, self._easing, self._step, self._scheduleFunction);
                        };
                        var currentState = this._currentState;
                        var targetState = this._targetState;
                        defaults(targetState, currentState);
                        this._easing = composeEasingObject(currentState, config.easing || DEFAULT_EASING);
                        this._filterArgs = [ currentState, this._originalState, targetState, this._easing ];
                        applyFilter(this, "tweenCreated");
                        return this;
                    };
                    Tweenable.prototype.get = function() {
                        return shallowCopy({}, this._currentState);
                    };
                    Tweenable.prototype.set = function(state) {
                        this._currentState = state;
                    };
                    Tweenable.prototype.pause = function() {
                        this._pausedAtTime = now();
                        this._isPaused = true;
                        return this;
                    };
                    Tweenable.prototype.resume = function() {
                        if (this._isPaused) {
                            this._timestamp += now() - this._pausedAtTime;
                        }
                        this._isPaused = false;
                        this._isTweening = true;
                        this._timeoutHandler();
                        return this;
                    };
                    Tweenable.prototype.seek = function(millisecond) {
                        millisecond = Math.max(millisecond, 0);
                        var currentTime = now();
                        if (this._timestamp + millisecond === 0) {
                            return this;
                        }
                        this._timestamp = currentTime - millisecond;
                        if (!this.isPlaying()) {
                            this._isTweening = true;
                            this._isPaused = false;
                            timeoutHandler(this, this._timestamp, this._delay, this._duration, this._currentState, this._originalState, this._targetState, this._easing, this._step, this._scheduleFunction, currentTime);
                            this.pause();
                        }
                        return this;
                    };
                    Tweenable.prototype.stop = function(gotoEnd) {
                        this._isTweening = false;
                        this._isPaused = false;
                        this._timeoutHandler = noop;
                        (root.cancelAnimationFrame || root.webkitCancelAnimationFrame || root.oCancelAnimationFrame || root.msCancelAnimationFrame || root.mozCancelRequestAnimationFrame || root.clearTimeout)(this._scheduleId);
                        if (gotoEnd) {
                            applyFilter(this, "beforeTween");
                            tweenProps(1, this._currentState, this._originalState, this._targetState, 1, 0, this._easing);
                            applyFilter(this, "afterTween");
                            applyFilter(this, "afterTweenEnd");
                            this._finish.call(this, this._currentState, this._attachment);
                        }
                        return this;
                    };
                    Tweenable.prototype.isPlaying = function() {
                        return this._isTweening && !this._isPaused;
                    };
                    Tweenable.prototype.setScheduleFunction = function(scheduleFunction) {
                        this._scheduleFunction = scheduleFunction;
                    };
                    Tweenable.prototype.dispose = function() {
                        var prop;
                        for (prop in this) {
                            if (this.hasOwnProperty(prop)) {
                                delete this[prop];
                            }
                        }
                    };
                    Tweenable.prototype.filter = {};
                    Tweenable.prototype.formula = {
                        linear: function(pos) {
                            return pos;
                        }
                    };
                    formula = Tweenable.prototype.formula;
                    shallowCopy(Tweenable, {
                        now: now,
                        each: each,
                        tweenProps: tweenProps,
                        tweenProp: tweenProp,
                        applyFilter: applyFilter,
                        shallowCopy: shallowCopy,
                        defaults: defaults,
                        composeEasingObject: composeEasingObject
                    });
                    if (typeof SHIFTY_DEBUG_NOW === "function") {
                        root.timeoutHandler = timeoutHandler;
                    }
                    if (typeof exports === "object") {
                        module.exports = Tweenable;
                    } else if (typeof define === "function" && define.amd) {
                        define(function() {
                            return Tweenable;
                        });
                    } else if (typeof root.Tweenable === "undefined") {
                        root.Tweenable = Tweenable;
                    }
                    return Tweenable;
                }();
                (function() {
                    Tweenable.shallowCopy(Tweenable.prototype.formula, {
                        easeInQuad: function(pos) {
                            return Math.pow(pos, 2);
                        },
                        easeOutQuad: function(pos) {
                            return -(Math.pow(pos - 1, 2) - 1);
                        },
                        easeInOutQuad: function(pos) {
                            if ((pos /= .5) < 1) {
                                return .5 * Math.pow(pos, 2);
                            }
                            return -.5 * ((pos -= 2) * pos - 2);
                        },
                        easeInCubic: function(pos) {
                            return Math.pow(pos, 3);
                        },
                        easeOutCubic: function(pos) {
                            return Math.pow(pos - 1, 3) + 1;
                        },
                        easeInOutCubic: function(pos) {
                            if ((pos /= .5) < 1) {
                                return .5 * Math.pow(pos, 3);
                            }
                            return .5 * (Math.pow(pos - 2, 3) + 2);
                        },
                        easeInQuart: function(pos) {
                            return Math.pow(pos, 4);
                        },
                        easeOutQuart: function(pos) {
                            return -(Math.pow(pos - 1, 4) - 1);
                        },
                        easeInOutQuart: function(pos) {
                            if ((pos /= .5) < 1) {
                                return .5 * Math.pow(pos, 4);
                            }
                            return -.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                        },
                        easeInQuint: function(pos) {
                            return Math.pow(pos, 5);
                        },
                        easeOutQuint: function(pos) {
                            return Math.pow(pos - 1, 5) + 1;
                        },
                        easeInOutQuint: function(pos) {
                            if ((pos /= .5) < 1) {
                                return .5 * Math.pow(pos, 5);
                            }
                            return .5 * (Math.pow(pos - 2, 5) + 2);
                        },
                        easeInSine: function(pos) {
                            return -Math.cos(pos * (Math.PI / 2)) + 1;
                        },
                        easeOutSine: function(pos) {
                            return Math.sin(pos * (Math.PI / 2));
                        },
                        easeInOutSine: function(pos) {
                            return -.5 * (Math.cos(Math.PI * pos) - 1);
                        },
                        easeInExpo: function(pos) {
                            return pos === 0 ? 0 : Math.pow(2, 10 * (pos - 1));
                        },
                        easeOutExpo: function(pos) {
                            return pos === 1 ? 1 : -Math.pow(2, -10 * pos) + 1;
                        },
                        easeInOutExpo: function(pos) {
                            if (pos === 0) {
                                return 0;
                            }
                            if (pos === 1) {
                                return 1;
                            }
                            if ((pos /= .5) < 1) {
                                return .5 * Math.pow(2, 10 * (pos - 1));
                            }
                            return .5 * (-Math.pow(2, -10 * --pos) + 2);
                        },
                        easeInCirc: function(pos) {
                            return -(Math.sqrt(1 - pos * pos) - 1);
                        },
                        easeOutCirc: function(pos) {
                            return Math.sqrt(1 - Math.pow(pos - 1, 2));
                        },
                        easeInOutCirc: function(pos) {
                            if ((pos /= .5) < 1) {
                                return -.5 * (Math.sqrt(1 - pos * pos) - 1);
                            }
                            return .5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
                        },
                        easeOutBounce: function(pos) {
                            if (pos < 1 / 2.75) {
                                return 7.5625 * pos * pos;
                            } else if (pos < 2 / 2.75) {
                                return 7.5625 * (pos -= 1.5 / 2.75) * pos + .75;
                            } else if (pos < 2.5 / 2.75) {
                                return 7.5625 * (pos -= 2.25 / 2.75) * pos + .9375;
                            } else {
                                return 7.5625 * (pos -= 2.625 / 2.75) * pos + .984375;
                            }
                        },
                        easeInBack: function(pos) {
                            var s = 1.70158;
                            return pos * pos * ((s + 1) * pos - s);
                        },
                        easeOutBack: function(pos) {
                            var s = 1.70158;
                            return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
                        },
                        easeInOutBack: function(pos) {
                            var s = 1.70158;
                            if ((pos /= .5) < 1) {
                                return .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s));
                            }
                            return .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                        },
                        elastic: function(pos) {
                            return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                        },
                        swingFromTo: function(pos) {
                            var s = 1.70158;
                            return (pos /= .5) < 1 ? .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                        },
                        swingFrom: function(pos) {
                            var s = 1.70158;
                            return pos * pos * ((s + 1) * pos - s);
                        },
                        swingTo: function(pos) {
                            var s = 1.70158;
                            return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                        },
                        bounce: function(pos) {
                            if (pos < 1 / 2.75) {
                                return 7.5625 * pos * pos;
                            } else if (pos < 2 / 2.75) {
                                return 7.5625 * (pos -= 1.5 / 2.75) * pos + .75;
                            } else if (pos < 2.5 / 2.75) {
                                return 7.5625 * (pos -= 2.25 / 2.75) * pos + .9375;
                            } else {
                                return 7.5625 * (pos -= 2.625 / 2.75) * pos + .984375;
                            }
                        },
                        bouncePast: function(pos) {
                            if (pos < 1 / 2.75) {
                                return 7.5625 * pos * pos;
                            } else if (pos < 2 / 2.75) {
                                return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + .75);
                            } else if (pos < 2.5 / 2.75) {
                                return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + .9375);
                            } else {
                                return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + .984375);
                            }
                        },
                        easeFromTo: function(pos) {
                            if ((pos /= .5) < 1) {
                                return .5 * Math.pow(pos, 4);
                            }
                            return -.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                        },
                        easeFrom: function(pos) {
                            return Math.pow(pos, 4);
                        },
                        easeTo: function(pos) {
                            return Math.pow(pos, .25);
                        }
                    });
                })();
                (function() {
                    function cubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
                        var ax = 0, bx = 0, cx = 0, ay = 0, by = 0, cy = 0;
                        function sampleCurveX(t) {
                            return ((ax * t + bx) * t + cx) * t;
                        }
                        function sampleCurveY(t) {
                            return ((ay * t + by) * t + cy) * t;
                        }
                        function sampleCurveDerivativeX(t) {
                            return (3 * ax * t + 2 * bx) * t + cx;
                        }
                        function solveEpsilon(duration) {
                            return 1 / (200 * duration);
                        }
                        function solve(x, epsilon) {
                            return sampleCurveY(solveCurveX(x, epsilon));
                        }
                        function fabs(n) {
                            if (n >= 0) {
                                return n;
                            } else {
                                return 0 - n;
                            }
                        }
                        function solveCurveX(x, epsilon) {
                            var t0, t1, t2, x2, d2, i;
                            for (t2 = x, i = 0; i < 8; i++) {
                                x2 = sampleCurveX(t2) - x;
                                if (fabs(x2) < epsilon) {
                                    return t2;
                                }
                                d2 = sampleCurveDerivativeX(t2);
                                if (fabs(d2) < 1e-6) {
                                    break;
                                }
                                t2 = t2 - x2 / d2;
                            }
                            t0 = 0;
                            t1 = 1;
                            t2 = x;
                            if (t2 < t0) {
                                return t0;
                            }
                            if (t2 > t1) {
                                return t1;
                            }
                            while (t0 < t1) {
                                x2 = sampleCurveX(t2);
                                if (fabs(x2 - x) < epsilon) {
                                    return t2;
                                }
                                if (x > x2) {
                                    t0 = t2;
                                } else {
                                    t1 = t2;
                                }
                                t2 = (t1 - t0) * .5 + t0;
                            }
                            return t2;
                        }
                        cx = 3 * p1x;
                        bx = 3 * (p2x - p1x) - cx;
                        ax = 1 - cx - bx;
                        cy = 3 * p1y;
                        by = 3 * (p2y - p1y) - cy;
                        ay = 1 - cy - by;
                        return solve(t, solveEpsilon(duration));
                    }
                    function getCubicBezierTransition(x1, y1, x2, y2) {
                        return function(pos) {
                            return cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
                        };
                    }
                    Tweenable.setBezierFunction = function(name, x1, y1, x2, y2) {
                        var cubicBezierTransition = getCubicBezierTransition(x1, y1, x2, y2);
                        cubicBezierTransition.displayName = name;
                        cubicBezierTransition.x1 = x1;
                        cubicBezierTransition.y1 = y1;
                        cubicBezierTransition.x2 = x2;
                        cubicBezierTransition.y2 = y2;
                        return Tweenable.prototype.formula[name] = cubicBezierTransition;
                    };
                    Tweenable.unsetBezierFunction = function(name) {
                        delete Tweenable.prototype.formula[name];
                    };
                })();
                (function() {
                    function getInterpolatedValues(from, current, targetState, position, easing, delay) {
                        return Tweenable.tweenProps(position, current, from, targetState, 1, delay, easing);
                    }
                    var mockTweenable = new Tweenable();
                    mockTweenable._filterArgs = [];
                    Tweenable.interpolate = function(from, targetState, position, easing, opt_delay) {
                        var current = Tweenable.shallowCopy({}, from);
                        var delay = opt_delay || 0;
                        var easingObject = Tweenable.composeEasingObject(from, easing || "linear");
                        mockTweenable.set({});
                        var filterArgs = mockTweenable._filterArgs;
                        filterArgs.length = 0;
                        filterArgs[0] = current;
                        filterArgs[1] = from;
                        filterArgs[2] = targetState;
                        filterArgs[3] = easingObject;
                        Tweenable.applyFilter(mockTweenable, "tweenCreated");
                        Tweenable.applyFilter(mockTweenable, "beforeTween");
                        var interpolatedValues = getInterpolatedValues(from, current, targetState, position, easingObject, delay);
                        Tweenable.applyFilter(mockTweenable, "afterTween");
                        return interpolatedValues;
                    };
                })();
                (function(Tweenable) {
                    var formatManifest;
                    var R_NUMBER_COMPONENT = /(\d|\-|\.)/;
                    var R_FORMAT_CHUNKS = /([^\-0-9\.]+)/g;
                    var R_UNFORMATTED_VALUES = /[0-9.\-]+/g;
                    var R_RGB = new RegExp("rgb\\(" + R_UNFORMATTED_VALUES.source + /,\s*/.source + R_UNFORMATTED_VALUES.source + /,\s*/.source + R_UNFORMATTED_VALUES.source + "\\)", "g");
                    var R_RGB_PREFIX = /^.*\(/;
                    var R_HEX = /#([0-9]|[a-f]){3,6}/gi;
                    var VALUE_PLACEHOLDER = "VAL";
                    function getFormatChunksFrom(rawValues, prefix) {
                        var accumulator = [];
                        var rawValuesLength = rawValues.length;
                        var i;
                        for (i = 0; i < rawValuesLength; i++) {
                            accumulator.push("_" + prefix + "_" + i);
                        }
                        return accumulator;
                    }
                    function getFormatStringFrom(formattedString) {
                        var chunks = formattedString.match(R_FORMAT_CHUNKS);
                        if (!chunks) {
                            chunks = [ "", "" ];
                        } else if (chunks.length === 1 || formattedString.charAt(0).match(R_NUMBER_COMPONENT)) {
                            chunks.unshift("");
                        }
                        return chunks.join(VALUE_PLACEHOLDER);
                    }
                    function sanitizeObjectForHexProps(stateObject) {
                        Tweenable.each(stateObject, function(prop) {
                            var currentProp = stateObject[prop];
                            if (typeof currentProp === "string" && currentProp.match(R_HEX)) {
                                stateObject[prop] = sanitizeHexChunksToRGB(currentProp);
                            }
                        });
                    }
                    function sanitizeHexChunksToRGB(str) {
                        return filterStringChunks(R_HEX, str, convertHexToRGB);
                    }
                    function convertHexToRGB(hexString) {
                        var rgbArr = hexToRGBArray(hexString);
                        return "rgb(" + rgbArr[0] + "," + rgbArr[1] + "," + rgbArr[2] + ")";
                    }
                    var hexToRGBArray_returnArray = [];
                    function hexToRGBArray(hex) {
                        hex = hex.replace(/#/, "");
                        if (hex.length === 3) {
                            hex = hex.split("");
                            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                        }
                        hexToRGBArray_returnArray[0] = hexToDec(hex.substr(0, 2));
                        hexToRGBArray_returnArray[1] = hexToDec(hex.substr(2, 2));
                        hexToRGBArray_returnArray[2] = hexToDec(hex.substr(4, 2));
                        return hexToRGBArray_returnArray;
                    }
                    function hexToDec(hex) {
                        return parseInt(hex, 16);
                    }
                    function filterStringChunks(pattern, unfilteredString, filter) {
                        var pattenMatches = unfilteredString.match(pattern);
                        var filteredString = unfilteredString.replace(pattern, VALUE_PLACEHOLDER);
                        if (pattenMatches) {
                            var pattenMatchesLength = pattenMatches.length;
                            var currentChunk;
                            for (var i = 0; i < pattenMatchesLength; i++) {
                                currentChunk = pattenMatches.shift();
                                filteredString = filteredString.replace(VALUE_PLACEHOLDER, filter(currentChunk));
                            }
                        }
                        return filteredString;
                    }
                    function sanitizeRGBChunks(formattedString) {
                        return filterStringChunks(R_RGB, formattedString, sanitizeRGBChunk);
                    }
                    function sanitizeRGBChunk(rgbChunk) {
                        var numbers = rgbChunk.match(R_UNFORMATTED_VALUES);
                        var numbersLength = numbers.length;
                        var sanitizedString = rgbChunk.match(R_RGB_PREFIX)[0];
                        for (var i = 0; i < numbersLength; i++) {
                            sanitizedString += parseInt(numbers[i], 10) + ",";
                        }
                        sanitizedString = sanitizedString.slice(0, -1) + ")";
                        return sanitizedString;
                    }
                    function getFormatManifests(stateObject) {
                        var manifestAccumulator = {};
                        Tweenable.each(stateObject, function(prop) {
                            var currentProp = stateObject[prop];
                            if (typeof currentProp === "string") {
                                var rawValues = getValuesFrom(currentProp);
                                manifestAccumulator[prop] = {
                                    formatString: getFormatStringFrom(currentProp),
                                    chunkNames: getFormatChunksFrom(rawValues, prop)
                                };
                            }
                        });
                        return manifestAccumulator;
                    }
                    function expandFormattedProperties(stateObject, formatManifests) {
                        Tweenable.each(formatManifests, function(prop) {
                            var currentProp = stateObject[prop];
                            var rawValues = getValuesFrom(currentProp);
                            var rawValuesLength = rawValues.length;
                            for (var i = 0; i < rawValuesLength; i++) {
                                stateObject[formatManifests[prop].chunkNames[i]] = +rawValues[i];
                            }
                            delete stateObject[prop];
                        });
                    }
                    function collapseFormattedProperties(stateObject, formatManifests) {
                        Tweenable.each(formatManifests, function(prop) {
                            var currentProp = stateObject[prop];
                            var formatChunks = extractPropertyChunks(stateObject, formatManifests[prop].chunkNames);
                            var valuesList = getValuesList(formatChunks, formatManifests[prop].chunkNames);
                            currentProp = getFormattedValues(formatManifests[prop].formatString, valuesList);
                            stateObject[prop] = sanitizeRGBChunks(currentProp);
                        });
                    }
                    function extractPropertyChunks(stateObject, chunkNames) {
                        var extractedValues = {};
                        var currentChunkName, chunkNamesLength = chunkNames.length;
                        for (var i = 0; i < chunkNamesLength; i++) {
                            currentChunkName = chunkNames[i];
                            extractedValues[currentChunkName] = stateObject[currentChunkName];
                            delete stateObject[currentChunkName];
                        }
                        return extractedValues;
                    }
                    var getValuesList_accumulator = [];
                    function getValuesList(stateObject, chunkNames) {
                        getValuesList_accumulator.length = 0;
                        var chunkNamesLength = chunkNames.length;
                        for (var i = 0; i < chunkNamesLength; i++) {
                            getValuesList_accumulator.push(stateObject[chunkNames[i]]);
                        }
                        return getValuesList_accumulator;
                    }
                    function getFormattedValues(formatString, rawValues) {
                        var formattedValueString = formatString;
                        var rawValuesLength = rawValues.length;
                        for (var i = 0; i < rawValuesLength; i++) {
                            formattedValueString = formattedValueString.replace(VALUE_PLACEHOLDER, +rawValues[i].toFixed(4));
                        }
                        return formattedValueString;
                    }
                    function getValuesFrom(formattedString) {
                        return formattedString.match(R_UNFORMATTED_VALUES);
                    }
                    function expandEasingObject(easingObject, tokenData) {
                        Tweenable.each(tokenData, function(prop) {
                            var currentProp = tokenData[prop];
                            var chunkNames = currentProp.chunkNames;
                            var chunkLength = chunkNames.length;
                            var easing = easingObject[prop];
                            var i;
                            if (typeof easing === "string") {
                                var easingChunks = easing.split(" ");
                                var lastEasingChunk = easingChunks[easingChunks.length - 1];
                                for (i = 0; i < chunkLength; i++) {
                                    easingObject[chunkNames[i]] = easingChunks[i] || lastEasingChunk;
                                }
                            } else {
                                for (i = 0; i < chunkLength; i++) {
                                    easingObject[chunkNames[i]] = easing;
                                }
                            }
                            delete easingObject[prop];
                        });
                    }
                    function collapseEasingObject(easingObject, tokenData) {
                        Tweenable.each(tokenData, function(prop) {
                            var currentProp = tokenData[prop];
                            var chunkNames = currentProp.chunkNames;
                            var chunkLength = chunkNames.length;
                            var firstEasing = easingObject[chunkNames[0]];
                            var typeofEasings = typeof firstEasing;
                            if (typeofEasings === "string") {
                                var composedEasingString = "";
                                for (var i = 0; i < chunkLength; i++) {
                                    composedEasingString += " " + easingObject[chunkNames[i]];
                                    delete easingObject[chunkNames[i]];
                                }
                                easingObject[prop] = composedEasingString.substr(1);
                            } else {
                                easingObject[prop] = firstEasing;
                            }
                        });
                    }
                    Tweenable.prototype.filter.token = {
                        tweenCreated: function(currentState, fromState, toState, easingObject) {
                            sanitizeObjectForHexProps(currentState);
                            sanitizeObjectForHexProps(fromState);
                            sanitizeObjectForHexProps(toState);
                            this._tokenData = getFormatManifests(currentState);
                        },
                        beforeTween: function(currentState, fromState, toState, easingObject) {
                            expandEasingObject(easingObject, this._tokenData);
                            expandFormattedProperties(currentState, this._tokenData);
                            expandFormattedProperties(fromState, this._tokenData);
                            expandFormattedProperties(toState, this._tokenData);
                        },
                        afterTween: function(currentState, fromState, toState, easingObject) {
                            collapseFormattedProperties(currentState, this._tokenData);
                            collapseFormattedProperties(fromState, this._tokenData);
                            collapseFormattedProperties(toState, this._tokenData);
                            collapseEasingObject(easingObject, this._tokenData);
                        }
                    };
                })(Tweenable);
            }).call(null);
        }, {} ],
        2: [ function(require, module, exports) {
            var Shape = require("./shape");
            var utils = require("./utils");
            var Circle = function Circle(container, options) {
                this._pathTemplate = "M 50,50 m 0,-{radius}" + " a {radius},{radius} 0 1 1 0,{2radius}" + " a {radius},{radius} 0 1 1 0,-{2radius}";
                this.containerAspectRatio = 1;
                Shape.apply(this, arguments);
            };
            Circle.prototype = new Shape();
            Circle.prototype.constructor = Circle;
            Circle.prototype._pathString = function _pathString(opts) {
                var widthOfWider = opts.strokeWidth;
                if (opts.trailWidth && opts.trailWidth > opts.strokeWidth) {
                    widthOfWider = opts.trailWidth;
                }
                var r = 50 - widthOfWider / 2;
                return utils.render(this._pathTemplate, {
                    radius: r,
                    "2radius": r * 2
                });
            };
            Circle.prototype._trailString = function _trailString(opts) {
                return this._pathString(opts);
            };
            module.exports = Circle;
        }, {
            "./shape": 7,
            "./utils": 9
        } ],
        3: [ function(require, module, exports) {
            var Shape = require("./shape");
            var utils = require("./utils");
            var Line = function Line(container, options) {
                this._pathTemplate = "M 0,{center} L 100,{center}";
                Shape.apply(this, arguments);
            };
            Line.prototype = new Shape();
            Line.prototype.constructor = Line;
            Line.prototype._initializeSvg = function _initializeSvg(svg, opts) {
                svg.setAttribute("viewBox", "0 0 100 " + opts.strokeWidth);
                svg.setAttribute("preserveAspectRatio", "none");
            };
            Line.prototype._pathString = function _pathString(opts) {
                return utils.render(this._pathTemplate, {
                    center: opts.strokeWidth / 2
                });
            };
            Line.prototype._trailString = function _trailString(opts) {
                return this._pathString(opts);
            };
            module.exports = Line;
        }, {
            "./shape": 7,
            "./utils": 9
        } ],
        4: [ function(require, module, exports) {
            module.exports = {
                Line: require("./line"),
                Circle: require("./circle"),
                SemiCircle: require("./semicircle"),
                Square: require("./square"),
                Path: require("./path"),
                Shape: require("./shape"),
                utils: require("./utils")
            };
        }, {
            "./circle": 2,
            "./line": 3,
            "./path": 5,
            "./semicircle": 6,
            "./shape": 7,
            "./square": 8,
            "./utils": 9
        } ],
        5: [ function(require, module, exports) {
            var Tweenable = require("shifty");
            var utils = require("./utils");
            var EASING_ALIASES = {
                easeIn: "easeInCubic",
                easeOut: "easeOutCubic",
                easeInOut: "easeInOutCubic"
            };
            var Path = function Path(path, opts) {
                if (!(this instanceof Path)) {
                    throw new Error("Constructor was called without new keyword");
                }
                opts = utils.extend({
                    duration: 800,
                    easing: "linear",
                    from: {},
                    to: {},
                    step: function() {}
                }, opts);
                var element;
                if (utils.isString(path)) {
                    element = document.querySelector(path);
                } else {
                    element = path;
                }
                this.path = element;
                this._opts = opts;
                this._tweenable = null;
                var length = this.path.getTotalLength();
                this.path.style.strokeDasharray = length + " " + length;
                this.set(0);
            };
            Path.prototype.value = function value() {
                var offset = this._getComputedDashOffset();
                var length = this.path.getTotalLength();
                var progress = 1 - offset / length;
                return parseFloat(progress.toFixed(6), 10);
            };
            Path.prototype.set = function set(progress) {
                this.stop();
                this.path.style.strokeDashoffset = this._progressToOffset(progress);
                var step = this._opts.step;
                if (utils.isFunction(step)) {
                    var easing = this._easing(this._opts.easing);
                    var values = this._calculateTo(progress, easing);
                    var reference = this._opts.shape || this;
                    step(values, reference, this._opts.attachment);
                }
            };
            Path.prototype.stop = function stop() {
                this._stopTween();
                this.path.style.strokeDashoffset = this._getComputedDashOffset();
            };
            Path.prototype.animate = function animate(progress, opts, cb) {
                opts = opts || {};
                if (utils.isFunction(opts)) {
                    cb = opts;
                    opts = {};
                }
                var passedOpts = utils.extend({}, opts);
                var defaultOpts = utils.extend({}, this._opts);
                opts = utils.extend(defaultOpts, opts);
                var shiftyEasing = this._easing(opts.easing);
                var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);
                this.stop();
                this.path.getBoundingClientRect();
                var offset = this._getComputedDashOffset();
                var newOffset = this._progressToOffset(progress);
                var self = this;
                this._tweenable = new Tweenable();
                this._tweenable.tween({
                    from: utils.extend({
                        offset: offset
                    }, values.from),
                    to: utils.extend({
                        offset: newOffset
                    }, values.to),
                    duration: opts.duration,
                    easing: shiftyEasing,
                    step: function(state) {
                        self.path.style.strokeDashoffset = state.offset;
                        var reference = opts.shape || self;
                        opts.step(state, reference, opts.attachment);
                    },
                    finish: function(state) {
                        if (utils.isFunction(cb)) {
                            cb();
                        }
                    }
                });
            };
            Path.prototype._getComputedDashOffset = function _getComputedDashOffset() {
                var computedStyle = window.getComputedStyle(this.path, null);
                return parseFloat(computedStyle.getPropertyValue("stroke-dashoffset"), 10);
            };
            Path.prototype._progressToOffset = function _progressToOffset(progress) {
                var length = this.path.getTotalLength();
                return length - progress * length;
            };
            Path.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {
                if (opts.from && opts.to) {
                    return {
                        from: opts.from,
                        to: opts.to
                    };
                }
                return {
                    from: this._calculateFrom(easing),
                    to: this._calculateTo(progress, easing)
                };
            };
            Path.prototype._calculateFrom = function _calculateFrom(easing) {
                return Tweenable.interpolate(this._opts.from, this._opts.to, this.value(), easing);
            };
            Path.prototype._calculateTo = function _calculateTo(progress, easing) {
                return Tweenable.interpolate(this._opts.from, this._opts.to, progress, easing);
            };
            Path.prototype._stopTween = function _stopTween() {
                if (this._tweenable !== null) {
                    this._tweenable.stop();
                    this._tweenable = null;
                }
            };
            Path.prototype._easing = function _easing(easing) {
                if (EASING_ALIASES.hasOwnProperty(easing)) {
                    return EASING_ALIASES[easing];
                }
                return easing;
            };
            module.exports = Path;
        }, {
            "./utils": 9,
            shifty: 1
        } ],
        6: [ function(require, module, exports) {
            var Shape = require("./shape");
            var Circle = require("./circle");
            var utils = require("./utils");
            var SemiCircle = function SemiCircle(container, options) {
                this._pathTemplate = "M 50,50 m -{radius},0" + " a {radius},{radius} 0 1 1 {2radius},0";
                this.containerAspectRatio = 2;
                Shape.apply(this, arguments);
            };
            SemiCircle.prototype = new Shape();
            SemiCircle.prototype.constructor = SemiCircle;
            SemiCircle.prototype._initializeSvg = function _initializeSvg(svg, opts) {
                svg.setAttribute("viewBox", "0 0 100 50");
            };
            SemiCircle.prototype._initializeTextContainer = function _initializeTextContainer(opts, container, textContainer) {
                if (opts.text.style) {
                    textContainer.style.top = "auto";
                    textContainer.style.bottom = "0";
                    if (opts.text.alignToBottom) {
                        utils.setStyle(textContainer, "transform", "translate(-50%, 0)");
                    } else {
                        utils.setStyle(textContainer, "transform", "translate(-50%, 50%)");
                    }
                }
            };
            SemiCircle.prototype._pathString = Circle.prototype._pathString;
            SemiCircle.prototype._trailString = Circle.prototype._trailString;
            module.exports = SemiCircle;
        }, {
            "./circle": 2,
            "./shape": 7,
            "./utils": 9
        } ],
        7: [ function(require, module, exports) {
            var Path = require("./path");
            var utils = require("./utils");
            var DESTROYED_ERROR = "Object is destroyed";
            var Shape = function Shape(container, opts) {
                if (!(this instanceof Shape)) {
                    throw new Error("Constructor was called without new keyword");
                }
                if (arguments.length === 0) {
                    return;
                }
                this._opts = utils.extend({
                    color: "#555",
                    strokeWidth: 1,
                    trailColor: null,
                    trailWidth: null,
                    fill: null,
                    text: {
                        style: {
                            color: null,
                            position: "absolute",
                            left: "50%",
                            top: "50%",
                            padding: 0,
                            margin: 0,
                            transform: {
                                prefix: true,
                                value: "translate(-50%, -50%)"
                            }
                        },
                        autoStyleContainer: true,
                        alignToBottom: true,
                        value: null,
                        className: "progressbar-text"
                    },
                    svgStyle: {
                        display: "block",
                        width: "100%"
                    },
                    warnings: false
                }, opts, true);
                if (utils.isObject(opts) && opts.svgStyle !== undefined) {
                    this._opts.svgStyle = opts.svgStyle;
                }
                if (utils.isObject(opts) && utils.isObject(opts.text) && opts.text.style !== undefined) {
                    this._opts.text.style = opts.text.style;
                }
                var svgView = this._createSvgView(this._opts);
                var element;
                if (utils.isString(container)) {
                    element = document.querySelector(container);
                } else {
                    element = container;
                }
                if (!element) {
                    throw new Error("Container does not exist: " + container);
                }
                this._container = element;
                this._container.appendChild(svgView.svg);
                if (this._opts.warnings) {
                    this._warnContainerAspectRatio(this._container);
                }
                if (this._opts.svgStyle) {
                    utils.setStyles(svgView.svg, this._opts.svgStyle);
                }
                this.svg = svgView.svg;
                this.path = svgView.path;
                this.trail = svgView.trail;
                this.text = null;
                var newOpts = utils.extend({
                    attachment: undefined,
                    shape: this
                }, this._opts);
                this._progressPath = new Path(svgView.path, newOpts);
                if (utils.isObject(this._opts.text) && this._opts.text.value !== null) {
                    this.setText(this._opts.text.value);
                }
            };
            Shape.prototype.animate = function animate(progress, opts, cb) {
                if (this._progressPath === null) {
                    throw new Error(DESTROYED_ERROR);
                }
                this._progressPath.animate(progress, opts, cb);
            };
            Shape.prototype.stop = function stop() {
                if (this._progressPath === null) {
                    throw new Error(DESTROYED_ERROR);
                }
                if (this._progressPath === undefined) {
                    return;
                }
                this._progressPath.stop();
            };
            Shape.prototype.destroy = function destroy() {
                if (this._progressPath === null) {
                    throw new Error(DESTROYED_ERROR);
                }
                this.stop();
                this.svg.parentNode.removeChild(this.svg);
                this.svg = null;
                this.path = null;
                this.trail = null;
                this._progressPath = null;
                if (this.text !== null) {
                    this.text.parentNode.removeChild(this.text);
                    this.text = null;
                }
            };
            Shape.prototype.set = function set(progress) {
                if (this._progressPath === null) {
                    throw new Error(DESTROYED_ERROR);
                }
                this._progressPath.set(progress);
            };
            Shape.prototype.value = function value() {
                if (this._progressPath === null) {
                    throw new Error(DESTROYED_ERROR);
                }
                if (this._progressPath === undefined) {
                    return 0;
                }
                return this._progressPath.value();
            };
            Shape.prototype.setText = function setText(newText) {
                if (this._progressPath === null) {
                    throw new Error(DESTROYED_ERROR);
                }
                if (this.text === null) {
                    this.text = this._createTextContainer(this._opts, this._container);
                    this._container.appendChild(this.text);
                }
                if (utils.isObject(newText)) {
                    utils.removeChildren(this.text);
                    this.text.appendChild(newText);
                } else {
                    this.text.innerHTML = newText;
                }
            };
            Shape.prototype._createSvgView = function _createSvgView(opts) {
                var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                this._initializeSvg(svg, opts);
                var trailPath = null;
                if (opts.trailColor || opts.trailWidth) {
                    trailPath = this._createTrail(opts);
                    svg.appendChild(trailPath);
                }
                var path = this._createPath(opts);
                svg.appendChild(path);
                return {
                    svg: svg,
                    path: path,
                    trail: trailPath
                };
            };
            Shape.prototype._initializeSvg = function _initializeSvg(svg, opts) {
                svg.setAttribute("viewBox", "0 0 100 100");
            };
            Shape.prototype._createPath = function _createPath(opts) {
                var pathString = this._pathString(opts);
                return this._createPathElement(pathString, opts);
            };
            Shape.prototype._createTrail = function _createTrail(opts) {
                var pathString = this._trailString(opts);
                var newOpts = utils.extend({}, opts);
                if (!newOpts.trailColor) {
                    newOpts.trailColor = "#eee";
                }
                if (!newOpts.trailWidth) {
                    newOpts.trailWidth = newOpts.strokeWidth;
                }
                newOpts.color = newOpts.trailColor;
                newOpts.strokeWidth = newOpts.trailWidth;
                newOpts.fill = null;
                return this._createPathElement(pathString, newOpts);
            };
            Shape.prototype._createPathElement = function _createPathElement(pathString, opts) {
                var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", pathString);
                path.setAttribute("stroke", opts.color);
                path.setAttribute("stroke-width", opts.strokeWidth);
                if (opts.fill) {
                    path.setAttribute("fill", opts.fill);
                } else {
                    path.setAttribute("fill-opacity", "0");
                }
                return path;
            };
            Shape.prototype._createTextContainer = function _createTextContainer(opts, container) {
                var textContainer = document.createElement("div");
                textContainer.className = opts.text.className;
                var textStyle = opts.text.style;
                if (textStyle) {
                    if (opts.text.autoStyleContainer) {
                        container.style.position = "relative";
                    }
                    utils.setStyles(textContainer, textStyle);
                    if (!textStyle.color) {
                        textContainer.style.color = opts.color;
                    }
                }
                this._initializeTextContainer(opts, container, textContainer);
                return textContainer;
            };
            Shape.prototype._initializeTextContainer = function(opts, container, element) {};
            Shape.prototype._pathString = function _pathString(opts) {
                throw new Error("Override this function for each progress bar");
            };
            Shape.prototype._trailString = function _trailString(opts) {
                throw new Error("Override this function for each progress bar");
            };
            Shape.prototype._warnContainerAspectRatio = function _warnContainerAspectRatio(container) {
                if (!this.containerAspectRatio) {
                    return;
                }
                var computedStyle = window.getComputedStyle(container, null);
                var width = parseFloat(computedStyle.getPropertyValue("width"), 10);
                var height = parseFloat(computedStyle.getPropertyValue("height"), 10);
                if (!utils.floatEquals(this.containerAspectRatio, width / height)) {
                    console.warn("Incorrect aspect ratio of container", "#" + container.id, "detected:", computedStyle.getPropertyValue("width") + "(width)", "/", computedStyle.getPropertyValue("height") + "(height)", "=", width / height);
                    console.warn("Aspect ratio of should be", this.containerAspectRatio);
                }
            };
            module.exports = Shape;
        }, {
            "./path": 5,
            "./utils": 9
        } ],
        8: [ function(require, module, exports) {
            var Shape = require("./shape");
            var utils = require("./utils");
            var Square = function Square(container, options) {
                this._pathTemplate = "M 0,{halfOfStrokeWidth}" + " L {width},{halfOfStrokeWidth}" + " L {width},{width}" + " L {halfOfStrokeWidth},{width}" + " L {halfOfStrokeWidth},{strokeWidth}";
                this._trailTemplate = "M {startMargin},{halfOfStrokeWidth}" + " L {width},{halfOfStrokeWidth}" + " L {width},{width}" + " L {halfOfStrokeWidth},{width}" + " L {halfOfStrokeWidth},{halfOfStrokeWidth}";
                Shape.apply(this, arguments);
            };
            Square.prototype = new Shape();
            Square.prototype.constructor = Square;
            Square.prototype._pathString = function _pathString(opts) {
                var w = 100 - opts.strokeWidth / 2;
                return utils.render(this._pathTemplate, {
                    width: w,
                    strokeWidth: opts.strokeWidth,
                    halfOfStrokeWidth: opts.strokeWidth / 2
                });
            };
            Square.prototype._trailString = function _trailString(opts) {
                var w = 100 - opts.strokeWidth / 2;
                return utils.render(this._trailTemplate, {
                    width: w,
                    strokeWidth: opts.strokeWidth,
                    halfOfStrokeWidth: opts.strokeWidth / 2,
                    startMargin: opts.strokeWidth / 2 - opts.trailWidth / 2
                });
            };
            module.exports = Square;
        }, {
            "./shape": 7,
            "./utils": 9
        } ],
        9: [ function(require, module, exports) {
            var PREFIXES = "Webkit Moz O ms".split(" ");
            var FLOAT_COMPARISON_EPSILON = .001;
            function extend(destination, source, recursive) {
                destination = destination || {};
                source = source || {};
                recursive = recursive || false;
                for (var attrName in source) {
                    if (source.hasOwnProperty(attrName)) {
                        var destVal = destination[attrName];
                        var sourceVal = source[attrName];
                        if (recursive && isObject(destVal) && isObject(sourceVal)) {
                            destination[attrName] = extend(destVal, sourceVal, recursive);
                        } else {
                            destination[attrName] = sourceVal;
                        }
                    }
                }
                return destination;
            }
            function render(template, vars) {
                var rendered = template;
                for (var key in vars) {
                    if (vars.hasOwnProperty(key)) {
                        var val = vars[key];
                        var regExpString = "\\{" + key + "\\}";
                        var regExp = new RegExp(regExpString, "g");
                        rendered = rendered.replace(regExp, val);
                    }
                }
                return rendered;
            }
            function setStyle(element, style, value) {
                var elStyle = element.style;
                for (var i = 0; i < PREFIXES.length; ++i) {
                    var prefix = PREFIXES[i];
                    elStyle[prefix + capitalize(style)] = value;
                }
                elStyle[style] = value;
            }
            function setStyles(element, styles) {
                forEachObject(styles, function(styleValue, styleName) {
                    if (styleValue === null || styleValue === undefined) {
                        return;
                    }
                    if (isObject(styleValue) && styleValue.prefix === true) {
                        setStyle(element, styleName, styleValue.value);
                    } else {
                        element.style[styleName] = styleValue;
                    }
                });
            }
            function capitalize(text) {
                return text.charAt(0).toUpperCase() + text.slice(1);
            }
            function isString(obj) {
                return typeof obj === "string" || obj instanceof String;
            }
            function isFunction(obj) {
                return typeof obj === "function";
            }
            function isArray(obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
            }
            function isObject(obj) {
                if (isArray(obj)) {
                    return false;
                }
                var type = typeof obj;
                return type === "object" && !!obj;
            }
            function forEachObject(object, callback) {
                for (var key in object) {
                    if (object.hasOwnProperty(key)) {
                        var val = object[key];
                        callback(val, key);
                    }
                }
            }
            function floatEquals(a, b) {
                return Math.abs(a - b) < FLOAT_COMPARISON_EPSILON;
            }
            function removeChildren(el) {
                while (el.firstChild) {
                    el.removeChild(el.firstChild);
                }
            }
            module.exports = {
                extend: extend,
                render: render,
                setStyle: setStyle,
                setStyles: setStyles,
                capitalize: capitalize,
                isString: isString,
                isFunction: isFunction,
                isObject: isObject,
                forEachObject: forEachObject,
                floatEquals: floatEquals,
                removeChildren: removeChildren
            };
        }, {} ]
    }, {}, [ 4 ])(4);
});

(function($) {
    $.tracky = function(container, options) {
        var plugin = this, $container = $(container), $app = false, name = "Tracky", slug = "tracky", title = name + " jQuery Plugin", logging = true, logPrefix = name, delay = 2500, swiper = false, defaults = {
            delay: {
                Long: delay,
                Medium: 500,
                Short: 350
            },
            Swiper: {
                direction: "horizontal",
                loop: false,
                get wrapperClass() {
                    return classes.App.Sections.Wrapper;
                },
                get slideClass() {
                    return classes.App.Section;
                },
                autoHeight: true,
                slidesPerView: 1,
                slidesPerColumn: 1,
                spaceBetween: 20,
                shortSwipes: false,
                resistanceRatio: 0,
                simulateTouch: false
            },
            EasyTabs: {
                animate: false,
                get tabActiveClass() {
                    return classes.App.Tabs.Active;
                },
                updateHash: false
            },
            DialogBoxes: {
                title: "",
                titleClass: "",
                type: "default",
                typeAnimated: true,
                draggable: true,
                dragWindowGap: 15,
                dragWindowBorder: true,
                animateFromElement: true,
                smoothContent: true,
                content: "Are you sure to continue?",
                buttons: {},
                defaultButtons: {
                    ok: {
                        action: function() {}
                    },
                    close: {
                        action: function() {}
                    }
                },
                contentLoaded: function(data, status, xhr) {},
                icon: "",
                lazyOpen: false,
                bgOpacity: null,
                theme: "light",
                animation: "scale",
                closeAnimation: "scale",
                animationSpeed: 400,
                animationBounce: 1,
                rtl: false,
                container: "body",
                containerFluid: false,
                backgroundDismiss: false,
                backgroundDismissAnimation: "shake",
                autoClose: false,
                closeIcon: null,
                closeIconClass: false,
                watchInterval: 100,
                columnClass: "col-md-4 col-md-offset-4 col-sm-6 col-sm-offset-3 col-xs-10 col-xs-offset-1",
                boxWidth: "50%",
                scrollToPreviousElement: true,
                scrollToPreviousElementAnimate: true,
                useBootstrap: false,
                offsetTop: 40,
                offsetBottom: 40,
                bootstrapClasses: {
                    container: "container",
                    containerFluid: "container-fluid",
                    row: "row"
                },
                onContentReady: function() {},
                onOpenBefore: function() {},
                onOpen: function() {},
                onClose: function() {},
                onDestroy: function() {},
                onAction: function() {}
            },
            ProgressBars: {
                color: "black",
                duration: 3e3,
                easing: "easeInOut",
                strokeWidth: 5,
                trailWidth: 1,
                text: {
                    style: {
                        color: "#999",
                        position: "absolute",
                        right: "0",
                        top: "30px",
                        padding: 0,
                        margin: 0,
                        transform: null
                    },
                    autoStyleContainer: false
                },
                from: {
                    color: "#FB6202"
                },
                to: {
                    color: "#f00300"
                },
                step: function(state, line) {
                    line.path.setAttribute("stroke", state.color);
                    line.path.setAttribute("stroke-width", state.width);
                    var lineValue = line.value(), value = Math.round(line.value() * 100);
                    line.setText(value + "%");
                }
            }
        }, craftables = JSON.parse(database.craftables), craftable_sources = JSON.parse(database.craftable_sources), craftable_categories = JSON.parse(database.craftable_categories), craftable_groups = JSON.parse(database.craftable_groups), craftable_collectables = JSON.parse(database.craftable_collectables), collectables = JSON.parse(database.collectables), ingredients = JSON.parse(database.ingredients), ingredient_types = JSON.parse(database.ingredient_types), ingredient_qualities = JSON.parse(database.ingredient_qualities), ingredient_parts = JSON.parse(database.ingredient_parts), player_game_crafted = JSON.parse(database.player_game_crafted), player_game_collected = JSON.parse(database.player_game_collected), player_game_submitted = JSON.parse(database.player_game_submitted), player_info = JSON.parse(database.player_info), actions = {
            Insert: {
                Collected: "_ajax_insert_player_game_collected",
                Submitted: "_ajax_insert_player_game_submitted",
                Crafted: "_ajax_insert_player_game_crafted"
            },
            Update: {
                Collected: "_ajax_update_player_game_collected",
                Submitted: "_ajax_update_player_game_submitted",
                Crafted: "_ajax_update_player_game_crafted",
                Filter: "_ajax_update_player_filter"
            }
        }, content = {
            Screens: [ {
                name: "Source",
                label: "Craftables"
            }, {
                name: "IngredientType",
                label: "Collectables"
            } ],
            Label: {
                Inserted: "Inserted!",
                Inserting: "Inserting...",
                Updated: "Updated!",
                Updating: "Updating..."
            }
        }, classes = {
            App: {
                Container: "app-container",
                Section: "app-section",
                Sections: {
                    Container: "app-sections-container",
                    List: "app-sections-list",
                    Filter: "app-sections-filter",
                    Wrapper: "app-sections-wrapper"
                },
                Tab: {
                    Nav: {
                        Container: "nav-tab",
                        Icon: "nav-tab-icon"
                    }
                },
                Tabs: {
                    Wrapper: "nav-tab-wrapper",
                    Nav: "nav-tab",
                    Active: "nav-tab-active"
                },
                Checkbox: {
                    Container: "app-checkbox",
                    List: "app-checkbox-list"
                }
            },
            Category: {
                Name: "category-name",
                Groups: "category-groups",
                Group: {
                    Container: "category-group",
                    Input: "category-group-input",
                    Checkbox: "category-group-checkbox",
                    Name: "category-group-name"
                }
            },
            Checkbox: {
                List: "checkbox-list"
            },
            Collectable: {
                Input: "collectable-input",
                Item: {
                    Container: "collectable-item",
                    Input: "collectable-item-input",
                    Checkbox: "collectable-item-checkbox"
                },
                List: {
                    Container: "collectable-list"
                }
            },
            Craftable: {
                Collectable: {
                    Container: "craftable-collectable",
                    Input: "craftable-collectable-input",
                    Checkbox: "craftable-collectable-checkbox"
                }
            },
            Dashicon: "dashicons",
            Dashicons: {
                Yes: "dashicons-yes"
            },
            DeadCheckbox: "DeadCheckbox",
            Filters: {
                Remaining: "filter-remaining"
            },
            Flag: {
                Active: "active",
                Available: "available",
                Checked: "checked",
                Disabled: "disabled",
                Show: "show",
                Top: "top",
                Updating: "updating-flag"
            },
            Group: {
                Craftable: {
                    Container: "group-craftable",
                    Checkbox: "group-craftable-checkbox",
                    Input: "group-craftable-input",
                    Label: "group-craftable-label",
                    List: "group-craftable-list",
                    Name: "group-craftable-name"
                },
                Craftables: {
                    Input: "group-craftables-input"
                }
            },
            Ingredient: {
                Container: "ingredient",
                Label: "ingredient-label",
                Checkbox: "ingredient-checkbox",
                Type: {
                    Selector: "ingredient-type-selector",
                    Tab: {
                        Content: "ingredient-type-tab-content",
                        Nav: "ingredient-type-tab-nav"
                    }
                }
            },
            Input: {
                Craftable: "craftable-input"
            },
            Item: {
                Label: "item-label"
            },
            Label: {
                Updating: "updating-label"
            },
            List: {
                Horizontal: "horizontal",
                Pill: "pill"
            },
            Names: "name",
            Name: {
                Quality: "quality-name",
                Ingredient: "ingredient-name",
                Part: "part-name",
                Quantity: "quantity",
                Remaining: "remaining-amount"
            },
            Open: "open",
            Progress: {
                Container: "progress-bar-container",
                Count: "progress-bar-count",
                Percentage: "progress-bar-percentage"
            },
            ScreenReader: "screen-reader-text",
            Source: {
                Content: "source-content",
                Icons: {
                    1: "fas fa-campground",
                    2: "fas fa-dollar-sign",
                    3: "far fa-envelope",
                    4: "fas fa-paw"
                },
                Tab: "source-tab",
                Category: {
                    Container: "source-category",
                    Checkbox: "source-category-checkbox",
                    Name: "source-category-name",
                    Input: "source-category-input",
                    Label: "source-category-label"
                },
                Selector: "source-selector"
            },
            Sources: {
                Category: {
                    Container: {}
                }
            },
            Swiper: {
                Container: "swiper-container",
                Slide: "swiper-slide"
            },
            Tab: {
                Lucky: "luckytab",
                Content: "tabContent",
                Nav: "tab-nav"
            },
            Tabs: {
                Container: "tabs-container",
                Lucky: "luckytabs",
                Top: "toptabs"
            }
        }, elements = {
            Collectable: {
                Progress: null
            },
            Flag: {
                get Updating() {
                    return $("#" + ids.Flag.Updating, $container);
                }
            },
            Source: {
                Progress: null
            },
            Ingredient: {
                Progress: null
            }
        }, events = {
            Click: "click",
            Change: "change",
            Resize: "resize",
            OrientationChange: "orientationchange",
            Blur: "blur",
            Focus: "focus",
            Key: {
                Up: "keyup"
            }
        }, html = {
            App: {
                get Container() {
                    return '<div class="' + classes.App.Container + '" id="' + ids.App + '"></div>';
                },
                List: '<div class="' + classes.App.Section + " " + classes.App.Sections.List + '"><ul class="' + classes.List.Horizontal + " " + classes.List.Pill + '"><li><a data-id="0" class="' + classes.Flag.Active + '">Craftables</a></li><li><a data-id="1">Collectables</li></ul></div>',
                get Filters() {
                    return '<div class="' + classes.App.Section + " " + classes.App.Sections.Filter + '"><ul class="' + classes.List.Horizontal + " " + classes.List.Pill + '"><li><label class=""><input type="checkbox" name="' + name.Filter + '" value="1" id="' + ids.Filters.Remaining + '" ' + (player_info.FilterRemaining == 1 ? "checked" : "") + " > Show remaining only </label></li></ul></div>";
                },
                Sections: '<div class="' + classes.App.Sections.Container + '"><div class="' + classes.App.Sections.Wrapper + ' swiper-wrapper"></div></div>'
            },
            get Dashicon() {
                return !states.Dashicon || !classes.Dashicons[states.Dashicon] ? false : '<span class="' + classes.Dashicon + " " + classes.Dashicons[states.Dashicon] + '"></span>';
            },
            Flag: {
                get Updating() {
                    return '<div class="' + classes.Flag.Updating + '" id="' + ids.Flag.Updating + '"> <span class="' + classes.Label.Updating + '"> ' + content.Label.Updating + " </span> </div>";
                }
            },
            Icon: {
                get Yes() {
                    states.Dashicon = "Yes";
                    return html.Dashicon;
                }
            },
            Ingredients: {
                Heading: '<h3 class="' + classes.ScreenReader + '">Collectables</h3>'
            },
            Sources: {
                Heading: '<h3 class="' + classes.ScreenReader + '">Craftables</h3>'
            }
        }, ids = {
            App: "App",
            Collectable: {
                Tabs: "CollectableTabs"
            },
            Collected: {
                Nonce: "_ajax_collected_nonce"
            },
            Craftable: {
                Nonce: "_ajax_craftables_nonce"
            },
            Filters: {
                Remaining: "FilterRemaining",
                Nonce: "_ajax_player_filters_nonce"
            },
            Flag: {
                Updating: "UpdatingFlag"
            },
            Game: "game_id",
            Ingredient: {
                Progress: "IngredientProgress",
                Types: "IngredientTypes"
            },
            Player: "player_id",
            Source: {
                Tabs: "SourceTabs",
                Name: "Source-",
                Progress: "SourceProgress"
            },
            Sources: {
                Craftable: "CraftableSources"
            },
            Submitted: {
                Nonce: "_ajax_submitted_nonce"
            },
            Type: {
                Tabs: "TypeTabs",
                Name: "Type-"
            }
        }, name = {
            Collectable: "collectableitems",
            Craftables: "craftableitems",
            Filter: "filter",
            Group: "groupitems"
        }, property = {
            Checked: "checked",
            Disabled: "disabled",
            Open: "open"
        }, states = {
            Interval: {
                Modify: {
                    Page: false
                },
                Update: {}
            },
            Player: {
                Filter: {
                    Remaining: false
                }
            },
            Craftable: {
                Crafted: 0,
                get Progress() {
                    return states.Craftable.Crafted == 0 ? 0 : states.Craftable.Crafted / states.Craftable.Quantity;
                },
                Quantity: 0
            },
            Collectable: {
                Collected: 0,
                get Progress() {
                    return states.Collectable.Collected == 0 ? 0 : states.Collectable.Collected / states.Collectable.Quantity;
                },
                Quantity: 0,
                Submitted: 0
            }
        };
        plugin.init = function() {
            plugin.settings = $.extend({}, defaults, options);
            $container.data(slug, {});
            var data = {
                game_id: $("#" + ids.Game).val()
            };
            $container.append(html.Flag.Updating);
            $container.append(html.App.Container);
            $app = $("#" + ids.App, $container);
            plugin.setupAppScreens(data);
            setupDetailSummary();
            setupDialogs();
        };
        plugin.setupAppScreens = function(data) {
            if (!$app.length) {
                error("Cannot find App to setup Screens!");
                return false;
            }
            $app.append(html.App.List);
            $list = $("." + classes.App.Sections.List, $app);
            $app.append(html.App.Filters);
            $filters = $("." + classes.App.Sections.Filter, $app);
            $app.append(html.App.Sections);
            $swiper = $("." + classes.App.Sections.Container, $app);
            $swiper.addClass(classes.Swiper.Container);
            $sections = $("." + classes.App.Sections.Wrapper, $swiper);
            showBySource(data);
            showByIngredientType(data);
            setTimeout(function() {
                swiper = new Swiper("." + classes.Swiper.Container, $.extend(plugin.settings.Swiper, {
                    on: {
                        slideChange: function() {
                            $("a:eq(" + swiper.activeIndex + ")", $list).click();
                        }
                    }
                }));
            }, plugin.settings.delay.Short);
            $("summary", $container).on(events.Click, function(e) {
                var $checkboxList = $(this).parentsUntil("." + classes.App.Checkbox.List).parent(), $details = $(this).parent(), $siblings = $("details", $checkboxList).not($details).prop(property.Open, "");
                $siblings.prop(property.Open, "");
                _updateSwiperHeight();
            });
            $("." + classes.App.Tab.Nav.Container + " a", $container).on(events.Click, function(e) {
                e.stopPropagation();
                var wrapper = $(this).closest("." + classes.App.Tabs.Wrapper);
                if (wrapper.hasClass(classes.Open)) wrapper.removeClass(classes.Open);
                _updateSwiperHeight();
            });
            $("." + classes.App.Tabs.Wrapper, $container).on(events.Click, function(e) {
                if (!$(this).hasClass(classes.Open)) $(this).addClass(classes.Open);
                _updateSwiperHeight();
            });
            if ($("#" + ids.Filters.Remaining, $container).prop(property.Checked)) $app.addClass(classes.Filters.Remaining);
            $("#" + ids.Filters.Remaining, $container).on(events.Change, function(e) {
                var filter = null;
                _activateUpdatingFlag();
                if ($(this).prop(property.Checked) == true) {
                    $app.addClass(classes.Filters.Remaining);
                    filter = 1;
                } else {
                    $app.removeClass(classes.Filters.Remaining);
                    filter = 0;
                }
                _updateSwiperHeight();
                player_info.FilterRemaining = filter;
                data = $.extend(data, {
                    filter: filter
                });
                _updateFilter(data);
            });
            $("a", $list).on(events.Click, function() {
                $("a", $list).removeClass(classes.Flag.Active);
                $(this).addClass(classes.Flag.Active);
                swiper.slideTo($(this).data("id"));
            });
            _updateSwiperHeight();
        };
        var _updateSwiperHeight = function() {
            if (typeof swiper == "undefined" || swiper == false) return;
            setTimeout(function() {
                swiper.updateAutoHeight(plugin.settings.delay.Short);
            }, plugin.settings.delay.Short);
        };
        var showBySource = function(data) {
            var totalSourcesComplete = 0, tabsWrapper = "", navTabs = "", tabs = "";
            if (!craftable_sources.length) return;
            for (var l = 0; l < craftable_sources.length; l++) {
                var sourceCategories = craftable_categories.filter(function(obj) {
                    return obj.Source == craftable_sources[l].ID;
                }), totalCategoriesComplete = 0, sourceContent = "";
                if (!sourceCategories.length) {
                    log("Skipping Source because no Categories found!");
                    continue;
                }
                for (var c = 0; c < sourceCategories.length; c++) {
                    if (sourceCategories[c].Inactive == "1") continue;
                    var categoryID = sourceCategories[c].ID, categoryGroups = craftable_groups.filter(function(obj) {
                        return obj.Category == categoryID;
                    }), totalGroupsComplete = 0, categoryContent = "";
                    if (!categoryGroups.length) {
                        log("Skipping Category because no Groups!");
                        continue;
                    }
                    for (var g = 0; g < categoryGroups.length; g++) {
                        var groupCraftables = craftables.filter(function(obj) {
                            return obj.Craftable_Group == categoryGroups[g].ID;
                        }), totalCrafted = 0, groupsContent = "";
                        if (!groupCraftables.length) {
                            log("Skipping Group because no Craftables!");
                            continue;
                        }
                        if (categoryGroups[g].Name !== sourceCategories[c].Name) groupsContent += '<ul class="' + classes.Group.Craftable.List + " " + classes.Checkbox.List + " " + classes.App.Checkbox.List + '"> ';
                        for (var i = 0; i < groupCraftables.length; i++) {
                            var craftableCollectables = craftable_collectables.filter(function(obj) {
                                return obj.Craftable == groupCraftables[i].ID;
                            }), totalCollectable = 0, totalCollected = 0, totalSubmitted = 0, totalRemaining = false, craftableContent = "";
                            if (!craftableCollectables.length) continue;
                            craftableContent += '<ul class="' + classes.Checkbox.List + " " + classes.App.Checkbox.List + '">';
                            for (var s = 0; s < craftableCollectables.length; s++) {
                                var collectableID = craftableCollectables[s].Collectable, collectable = collectables.filter(function(obj) {
                                    return obj.ID == collectableID;
                                })[0], ingredient = ingredients.filter(function(obj) {
                                    return obj.ID == collectable.Ingredient;
                                })[0], quality = ingredient_qualities.filter(function(obj) {
                                    return obj.ID == collectable.Quality;
                                })[0], part = ingredient_parts.filter(function(obj) {
                                    return obj.ID == collectable.Part;
                                })[0], quantity = craftableCollectables[s].Quantity, collectableCollected = player_game_collected.filter(function(obj) {
                                    return obj.Collectable == collectableID;
                                })[0], quantityCollected = typeof collectableCollected !== "undefined" ? collectableCollected.Collected : 0, collectableSubmitted = player_game_submitted.filter(function(obj) {
                                    return obj.CraftableCollectable == craftableCollectables[s].ID;
                                })[0], quantitySubmitted = typeof collectableSubmitted !== "undefined" ? collectableSubmitted.Quantity : 0, collectableContent = "";
                                totalCollectable = totalCollectable + parseInt(quantity);
                                totalCollected = totalCollected + parseInt(quantityCollected);
                                totalSubmitted = totalSubmitted + parseInt(quantitySubmitted);
                                for (var q = 0; q < quantity; q++) {
                                    var isCollected = q < quantityCollected, availableVal = isCollected ? classes.Flag.Available : "", isSubmitted = q < quantitySubmitted, checkedVal = isSubmitted ? property.Checked : "", checkedClass = isSubmitted ? classes.Flag.Checked : "", disabledVal = "";
                                    collectableContent += '<label class="' + classes.DeadCheckbox + " " + classes.Craftable.Collectable.Checkbox + " " + availableVal + " " + disabledVal + '" > <input type="checkbox" name="' + name.Collectable + '" class="' + classes.Craftable.Collectable.Input + '" value="' + craftableCollectables[s].ID + '" data-craftable="' + groupCraftables[i].ID + '" data-collectable="' + collectable.ID + '" ' + checkedVal + " > </label>";
                                }
                                craftableContent += '<li> <label class="' + classes.Ingredient.Label + '"> <span class="' + classes.Name.Quality + '">' + quality.Name + '</span> <span class="' + classes.Name.Ingredient + '">' + ingredient.Name + '</span> <span class="' + classes.Name.Part + '">' + part.Name + '</span> x <span class="' + classes.Name.Quantity + '">' + craftableCollectables[s].Quantity + "</span> </label> " + collectableContent + " </li>";
                            }
                            craftableContent += "</ul>";
                            var craftedCraftable = player_game_crafted.filter(function(obj) {
                                return obj.Craftable == groupCraftables[i].ID;
                            })[0], totalRemaining = totalCollectable - totalSubmitted, isSubmittable = totalSubmitted < totalCollectable, isCraftable = !isSubmittable, isCrafted = typeof craftedCraftable !== "undefined" && craftedCraftable.Acquired == 1, abled = isSubmittable ? property.Disabled : "", opened = false, available = isCraftable ? classes.Flag.Available : "", checkedVal = isCrafted ? property.Checked : "", craftableClass = isCrafted ? classes.Flag.Disabled : "", checkedClass = isCrafted ? classes.Flag.Checked : "";
                            if (isCrafted) totalCrafted++;
                            groupsContent += '<li> <details class="' + classes.Group.Craftable.Container + " " + craftableClass + '" ' + opened + ' > <summary class="' + abled + '"> <label class="' + classes.DeadCheckbox + " " + classes.Group.Craftable.Checkbox + " " + abled + " " + available + " " + checkedClass + '"> <span class="' + classes.Name.Remaining + '">' + totalRemaining + '</span> <input type="checkbox" class="' + classes.Group.Craftable.Input + '" name="' + name.Craftables + '" value="' + groupCraftables[i].ID + '" ' + abled + " " + checkedVal + ' > </label> <label class="' + classes.Group.Craftable.Label + " " + classes.Item.Label + '"> <span class="' + classes.Group.Craftable.Name + '">' + groupCraftables[i].Name + "</span> </label> </summary> " + craftableContent + " </details> </li>";
                        }
                        states.Craftable.Quantity += groupCraftables.length;
                        states.Craftable.Crafted += totalCrafted;
                        var craftablesRemaining = groupCraftables.length - totalCrafted, groupComplete = !craftablesRemaining, abled = property.Disabled, disabled = groupComplete ? classes.Flag.Disabled : "", groupClass = groupComplete ? classes.Flag.Checked + " " + classes.Flag.Disabled : "", checkedVal = groupComplete ? property.Checked : "";
                        if (groupComplete) totalGroupsComplete++;
                        if (groupsContent == "") {
                            log("Skipping empty group!");
                            continue;
                        }
                        if (categoryGroups[g].Name !== sourceCategories[c].Name) {
                            groupsContent += "</ul>";
                            categoryContent += '<li> <details class="' + classes.Category.Group.Container + " " + groupClass + '" > <summary> <label class="' + classes.DeadCheckbox + " " + classes.Category.Group.Checkbox + " " + disabled + '"> <span class="' + classes.Name.Remaining + '">' + craftablesRemaining + '</span> <input type="checkbox" class="' + classes.Category.Group.Input + '" name="' + name.Group + '" value="' + categoryGroups[g].ID + '" ' + abled + " " + checkedVal + ' > </label> <span class="' + classes.Category.Group.Name + '">' + categoryGroups[g].Name + "</span> </summary>";
                        }
                        categoryContent += groupsContent;
                        if (categoryGroups[g].Name !== sourceCategories[c].Name) categoryContent += "</details> </li>";
                    }
                    if (categoryContent == "") {
                        log("Skipping Category because STILL no Craftables!");
                        continue;
                    }
                    categoryContentStart = '<ul class="' + classes.Category.Groups + " " + classes.Checkbox.List + " " + classes.App.Checkbox.List + '">';
                    categoryContentEnd = "</ul>";
                    categoryContent = categoryContentStart + categoryContent + categoryContentEnd;
                    var groupsRemaining = categoryGroups.length - totalGroupsComplete, categoryComplete = groupsRemaining == 0, categoryClasses = categoryComplete ? classes.Flag.Checked + " " + classes.Flag.Disabled : "", categoryOpen = "", checkedVal = categoryComplete ? property.Checked : "";
                    if (categoryComplete) totalCategoriesComplete++;
                    sourceContent += '<details class="' + classes.Source.Category.Container + " " + categoryClasses + '" ' + categoryOpen + '> <summary> <label class="' + classes.DeadCheckbox + " " + classes.Source.Category.Checkbox + " " + categoryClasses + '"> <span class="' + classes.Name.Remaining + '">' + groupsRemaining + '</span> <input type="checkbox" name="" class="' + classes.Source.Category.Input + '" ' + checkedVal + '> </label> <span class="' + classes.Source.Category.Name + '">' + sourceCategories[c].Name + "</span> </summary> " + categoryContent + " </details>";
                }
                var categoriesRemaining = sourceCategories.length - totalCategoriesComplete, sourceComplete = categoriesRemaining == 0;
                if (sourceComplete) totalSourcesComplete++;
                navTabs += '<li class="' + classes.App.Tab.Nav.Container + '"> <a href="#' + ids.Source.Name + craftable_sources[l].Name + '" class="" data-sourceid="' + craftable_sources[l].ID + '" data-tabid="' + l + '"> <div class="' + classes.App.Tab.Nav.Icon + '"> <span class="' + classes.Source.Icons[craftable_sources[l].ID] + '"> </span> </div> <span>' + craftable_sources[l].Name + "</span> </a> </li>";
                tabs += '<div class="' + classes.Source.Tab + " " + classes.Tab.Lucky + '" id="' + ids.Source.Name + craftable_sources[l].Name + '"> <h3 class="' + classes.ScreenReader + " " + classes.Source.Name + '">' + craftable_sources[l].Name + '</h3> <div class="' + classes.Tab.Content + " " + classes.Source.Content + '" > ' + sourceContent + " </div> </div>";
            }
            var progressBarContainer = '<div class="' + classes.Progress.Container + '" id="' + ids.Source.Progress + '"></div>';
            tabsWrapper += '<div id="' + ids.Sources.Craftable + '" class="' + classes.App.Section + " " + classes.Swiper.Slide + '" > ' + html.Sources.Heading + " " + progressBarContainer + ' <div id="' + ids.Source.Tabs + '" class="' + classes.Tabs.Container + " " + classes.Tabs.Lucky + " " + classes.Tabs.Top + '"> <ul class="' + classes.Source.Selector + " " + classes.List.Pill + " " + classes.App.Tabs.Wrapper + '">' + navTabs + "</ul>" + tabs + "</div> </div>";
            $sections.append(tabsWrapper);
            $div = $("#" + ids.Source.Tabs);
            _setupSourceActions(data, $div);
        };
        var _setupSourceProgressBar = function() {
            if (typeof ProgressBar == "undefined") {
                error("ProgressBar is undefined!");
                return false;
            }
            if (states.Craftable.Quantity == 0) {
                error("Craftable Quantity is zero!");
                return false;
            }
            elements.Source.Progress = new ProgressBar.Line("#" + ids.Source.Progress, $.extend(plugin.settings.ProgressBars, {
                step: function(state, line) {
                    line.path.setAttribute("stroke", state.color);
                    line.path.setAttribute("stroke-width", state.width);
                    var lineValue = line.value(), value = Math.round(lineValue * 100), percentage = value + "%";
                    line.setText('<span class="' + classes.Progress.Count + '" > ' + Math.round(states.Craftable.Quantity * lineValue) + "/" + states.Craftable.Quantity + ' </span> <span class="' + classes.Progress.Percentage + '"> ' + percentage + " </span>");
                }
            }));
            _updateCraftableProgressBar();
        };
        var _updateCraftableProgressBar = function() {
            elements.Source.Progress.animate(states.Craftable.Progress);
        };
        var _setupSourceActions = function(data, $div) {
            _setupSourceProgressBar();
            $("." + classes.DeadCheckbox, $div).each(function() {
                if ($("input", this).prop(property.Checked)) $(this).addClass(property.Checked);
            });
            $("." + classes.Craftable.Collectable.Checkbox, $div).on(events.Click, function(e) {
                e.preventDefault();
                log("Clicked Craftable Collectable checkbox...");
                var $input = $("input", $(this)), checked = $input.prop(property.Checked), $all = $(this).parent().children(), $siblings = $(this).siblings(), $sold = $("input:" + property.Checked, $(this).parent()).parent(), $notSold = $("input", $all).not(":" + property.Checked).parent(), $available = $("." + classes.Flag.Available, $(this).parent()), $availableAny = $(this).siblings("." + classes.Flag.Available), $availableAnyNotSold = $("input", $availableAny).not(":" + property.Checked).parent(), $availableNotSold = $("input", $available).not(":" + property.Checked).parent(), $notAvailableNotSold = $notSold.not("." + classes.Flag.Available), availableThis = $(this).hasClass(classes.Flag.Available), availableAny = $availableAnyNotSold.length > 0, craftableCollectable = $input.val(), collectable = $input.data("collectable");
                if (checked == true) {
                    log("Checked is true...");
                    uncheck($("input", $sold.last()));
                    return;
                }
                if (availableThis) {
                    log("Checkbox is available...");
                    check($("input", $availableNotSold.first()));
                    return;
                }
                if (availableAny) {
                    log("ANY Checkbox is available...");
                    check($("input", $availableAnyNotSold.first()));
                    return;
                }
                log("No checkboxes are available...");
                $.confirm({
                    title: "Item has not been collected!",
                    content: "Do you want to mark as collected and sell?",
                    type: "red",
                    icon: "fa fa-warning",
                    buttons: {
                        ok: function() {
                            collectNextAvailable(collectable);
                            check($("input", $notSold.first()));
                        },
                        cancel: function() {}
                    }
                });
            });
            $("." + classes.Craftable.Collectable.Input, $div).on(events.Change, function(e) {
                _activateUpdatingFlag();
                clicked = {
                    collectable: $(this).val()
                };
                data = $.extend(data, clicked);
                _submitCollectable(data);
                var $checkboxList = $(this).parentsUntil("." + classes.App.Checkbox.List).parent(), $craftable = $checkboxList.parent(), $craftableSummary = $("> summary", $craftable), $craftableCheckbox = $("> label", $craftableSummary), $craftableRemaining = $("> ." + classes.Name.Remaining, $craftableCheckbox);
                $craftableCheckboxInput = $("> input", $craftableCheckbox), unchecked = $("." + classes.Craftable.Collectable.Input, $checkboxList).not(":" + property.Checked).length, 
                collectable = $(this).data("collectable");
                $craftableRemaining.text(unchecked);
                if ($(this).prop(property.Checked)) {
                    log("This is checked...");
                    disableNextCollectable(collectable);
                    $(this).parent().addClass(classes.Flag.Checked);
                    if (unchecked) return;
                    $craftable.addClass(classes.Flag.Disabled);
                    $craftableSummary.removeClass(classes.Flag.Disabled);
                    $craftableCheckbox.removeClass(classes.Flag.Disabled).addClass(classes.Flag.Available);
                    $craftableCheckboxInput.prop(property.Disabled, "");
                    return;
                }
                log("This is unchecked...");
                undisableLastCollectable(collectable);
                $(this).parent().removeClass(classes.Flag.Checked);
                $craftableSummary.addClass(classes.Flag.Disabled);
                $craftableCheckbox.addClass(classes.Flag.Disabled).removeClass(classes.Flag.Available);
                $craftableCheckboxInput.prop(property.Disabled, property.Disabled);
                uncheck($craftableCheckboxInput);
            });
            $("." + classes.Category.Group.Checkbox, $div).on(events.Click, function(e) {
                e.preventDefault();
                $(this).parent().click();
            });
            $("." + classes.Group.Craftable.Checkbox, $div).on(events.Click, function(e) {
                e.preventDefault();
                log("Clicked a Group Craftable!");
                var $checkboxList = $(this).parentsUntil("." + classes.App.Checkbox.List).parent(), $group = $checkboxList.parentsUntil("details").parent(), $groupSummary = $("> summary", $group), $groupCheckbox = $("> label", $groupSummary), $groupRemaining = $("> ." + classes.Name.Remaining, $groupCheckbox);
                $input = $("> input", $(this)), checked = $input.prop(property.Checked), availableThis = $(this).hasClass(classes.Flag.Available), 
                $craftable = $(this).parentsUntil("details").parent(), unchecked = $("." + classes.Group.Craftable.Input, $checkboxList).not(":" + property.Checked).length;
                if (checked == true) {
                    uncheck($input);
                } else if (!availableThis) {
                    $(this).parent().click();
                } else {
                    check($input);
                    $craftable.prop(property.Open, "");
                    $craftable.removeClass(classes.Flag.Available).addClass(classes.Flag.Disabled);
                }
                var unchecked = $("." + classes.Group.Craftable.Input, $checkboxList).not(":" + property.Checked).length;
                $groupRemaining.text(unchecked);
            });
            $("." + classes.Group.Craftable.Input, $div).on(events.Change, function(e) {
                e.preventDefault();
                log("Craftable input changed!");
                _activateUpdatingFlag();
                var checked = $(this).prop(property.Checked);
                clicked = {
                    craftable: $(this).val(),
                    acquired: checked == true ? 1 : 0
                };
                data = $.extend(data, clicked);
                var $craftable = $(this).parentsUntil("details").parent(), $checkboxList = $(this).parentsUntil("." + classes.App.Checkbox.List).parent(), $group = $checkboxList.parentsUntil("details").parent(), $groupSummary = $("> summary", $group), $groupCheckbox = $("> label", $groupSummary), $groupCheckboxInput = $("> input", $groupCheckbox), unchecked = $("input", $checkboxList).not(":" + property.Checked).length;
                if (checked) {
                    states.Craftable.Crafted = states.Craftable.Crafted + 1;
                    _updateCraftable(data);
                    $(this).parent().addClass(classes.Flag.Checked);
                    if (unchecked) return;
                    $groupCheckbox.addClass(classes.Flag.Checked);
                    $groupCheckbox.addClass(classes.Flag.Disabled);
                    $group.addClass(classes.Flag.Disabled);
                    $groupCheckboxInput.prop(property.Checked, property.Checked);
                    $craftable.removeAttr(property.Open);
                    $group.removeAttr(property.Open);
                    return;
                }
                states.Craftable.Crafted = states.Craftable.Crafted - 1;
                _updateCraftable(data);
                $(this).parent().removeClass(classes.Flag.Checked);
                $groupCheckbox.removeClass(classes.Flag.Checked);
                $group.removeClass(classes.Flag.Disabled);
                $groupCheckboxInput.removeAttr(property.Checked);
            });
            setupTabs($div);
        };
        var showByIngredientType = function(data) {
            var ingredientTypes = ingredient_types, typeIcons = {
                1: "fas fa-hippo",
                2: "fas fa-crow",
                3: "fas fa-fish",
                4: "far fa-gem",
                5: "far fa-snowflake"
            }, heading = '<h3 class="' + classes.ScreenReader + '">Collectables</h3>', tabsWrapper = "", navTabs = "", tabs = "", remaining = [];
            if (!ingredientTypes.length) return;
            for (var t = 0; t < ingredientTypes.length; t++) {
                var typeIngredients = ingredients.filter(function(obj) {
                    return obj.Type == ingredientTypes[t].ID;
                }), typesContent = "";
                if (!typeIngredients.length) continue;
                for (var n = 0; n < typeIngredients.length; n++) {
                    var ingredientID = typeIngredients[n].ID, ingredientCollectables = collectables.filter(function(obj) {
                        return obj.Ingredient == ingredientID;
                    }), totalCollectable = 0, totalCollected = 0, totalSubmitted = 0, ingredientsContent = "", collectablesContent = "";
                    if (!ingredientCollectables.length) continue;
                    for (var c = 0; c < ingredientCollectables.length; c++) {
                        var collectable = ingredientCollectables[c].ID, ingredient = ingredients.filter(function(obj) {
                            return obj.ID == ingredientCollectables[c].Ingredient;
                        })[0], part = ingredient_parts.filter(function(obj) {
                            return obj.ID == ingredientCollectables[c].Part;
                        })[0], quality = ingredient_qualities.filter(function(obj) {
                            return obj.ID == ingredientCollectables[c].Quality;
                        })[0], craftableCollectables = craftable_collectables.filter(function(obj) {
                            return obj.Collectable == collectable;
                        }), quantity = ingredientCollectables[c].Quality == 2 ? 1 : sumColumn(craftableCollectables, "Quantity"), collectableCollected = player_game_collected.filter(function(obj) {
                            return obj.Collectable == collectable;
                        })[0], quantityCollected = typeof collectableCollected !== "undefined" ? collectableCollected.Collected : 0, collectableSubmitted = [], quantitySubmitted = 0;
                        for (var i = 0; i < craftableCollectables.length; i++) {
                            var submittedCollectables = player_game_submitted.filter(function(obj) {
                                return obj.CraftableCollectable == craftableCollectables[i].ID;
                            });
                            if (!submittedCollectables) continue;
                            if (submittedCollectables.length == 0) continue;
                            var submittedCollectablesFlat = flatten(submittedCollectables);
                            if (submittedCollectablesFlat.length == 0) continue;
                            collectableSubmitted.push(submittedCollectablesFlat);
                        }
                        var quantitySubmitted = collectableSubmitted.length ? sumColumn(collectableSubmitted, "Quantity") : 0;
                        states.Collectable.Submitted += quantitySubmitted;
                        totalCollectable += parseInt(quantity);
                        states.Collectable.Quantity += totalCollectable;
                        totalCollected += parseInt(quantityCollected);
                        states.Collectable.Collected += totalCollected;
                        totalRemaining = totalCollectable - totalCollected;
                        var remainingObject = {
                            Collectable: ingredientCollectables[c].ID,
                            Remaining: totalRemaining
                        };
                        remaining.push(remainingObject);
                        collectablesContent += '<ul class="' + classes.Collectable.List.Container + " " + classes.Checkbox.List + " " + classes.App.Checkbox.List + '">';
                        collectablesContent += '<li class="' + classes.Ingredient.Container + '"> <label class="' + classes.Ingredient.Label + '" > <span class="' + classes.Name.Quantity + '">' + quantity + '</span> x <span class="' + classes.Name.quality + '">' + quality.Name + '</span> <span class="' + classes.Name.Ingredient + '">' + ingredient.Name + '</span> <span class="' + classes.Name.Part + '">' + part.Name + "</span> </label>";
                        for (var q = 0; q < quantity; q++) {
                            var checkedVal = q < quantityCollected ? property.Checked : "", disabledVal = quantitySubmitted > 0 && q < quantitySubmitted ? property.Disabled : "", disabledClass = quantitySubmitted > 0 && q < quantitySubmitted ? classes.Flag.Disabled : "";
                            collectablesContent += '<label class="' + classes.DeadCheckbox + " " + classes.Collectable.Item.Checkbox + " " + disabledClass + '"> <input type="checkbox" name="' + name.Collectable + '" class="' + classes.Collectable.Item.Input + '" value="' + collectable + '" ' + checkedVal + " " + disabledVal + " > </label>";
                        }
                        collectablesContent += "</li>";
                        collectablesContent += "</ul>";
                    }
                    var ingredientContainerClasses = totalRemaining == 0 ? classes.Flag.Disabled : "", ingredientContainerClass = classes.Ingredient.Container + "-" + ingredient.Name.replace(/ /g, "_").toLowerCase(), ingredientContainerID = capitalize(classes.Ingredient.Container) + ingredient.Name.replace(/ /g, "");
                    ingredientsContent += '<details class="' + classes.Ingredient.Container + " " + ingredientContainerClass + " " + ingredientContainerClasses + '" data-ingredient="' + ingredientID + '" data-ingredienttype="' + ingredientTypes[t].ID + '" data-remaining="' + totalRemaining + '" id="' + ingredientContainerID + '"> <summary> <label class="' + classes.DeadCheckbox + " " + classes.Ingredient.Checkbox + '"><span class="' + classes.Name.Remaining + '">' + totalRemaining + '</span></label> <span class="' + classes.Name.Ingredient + '">' + ingredient.Name + "</span> </summary> " + collectablesContent + " </details>";
                    typesContent += ingredientsContent;
                }
                navTabs += '<li class="' + classes.Ingredient.Type.Tab.Nav + " " + classes.App.Tab.Nav.Container + '"><a href="#' + ids.Type.Name + ingredient_types[t].Plural + '" data-typeid="' + ingredient_types[t].ID + '" data-tabid="' + t + '"> <div class="' + classes.App.Tab.Nav.Icon + '" > <span class="' + typeIcons[ingredient_types[t].ID] + '"> </span> </div> <span>' + ingredient_types[t].Plural + " </span> </a> </li>";
                tabs += '<div class="' + classes.Ingredient.Type.Tab.Content + " " + classes.Tab.Lucky + '" id="' + ids.Type.Name + ingredient_types[t].Plural + '"><h3 class="' + classes.Ingredient.Type.Name + " " + classes.ScreenReader + '">' + ingredient_types[t].Plural + '</h3> <div class="' + classes.Tab.Content + '">' + typesContent + "</div> </div>";
            }
            var progressBarContainer = '<div class="' + classes.Progress.Container + '" id="' + ids.Ingredient.Progress + '"></div>';
            var tabsWrapper = '<div id="' + ids.Ingredient.Types + '" class="' + classes.App.Section + " " + classes.Swiper.Slide + '">' + heading + " " + progressBarContainer + ' <div id="' + ids.Collectable.Tabs + '" class="' + classes.Tabs.Container + " " + classes.Tabs.Lucky + " " + classes.Tabs.Top + '"><ul class="' + classes.Source.Selector + " " + classes.List.Pill + " " + classes.App.Tabs.Wrapper + '">' + navTabs + "</ul>" + tabs + "</div></div>";
            $sections.append(tabsWrapper);
            $div = $("#" + ids.Collectable.Tabs);
            _setupIngredientActions(data, $div);
        };
        var _setupIngredientProgressBar = function() {
            if (typeof ProgressBar == "undefined") {
                error("ProgressBar is undefined!");
                return false;
            }
            if (states.Collectable.Quantity == 0) {
                error("Collectable Quantity is zero!");
                return false;
            }
            elements.Collectable.Progress = new ProgressBar.Line("#" + ids.Ingredient.Progress, $.extend(plugin.settings.ProgressBars, {
                step: function(state, line) {
                    line.path.setAttribute("stroke", state.color);
                    line.path.setAttribute("stroke-width", state.width);
                    var lineValue = line.value(), value = Math.round(lineValue * 100), percentage = value + "%";
                    line.setText('<span class="' + classes.Progress.Count + '" > ' + Math.round(states.Collectable.Quantity * lineValue) + "/" + states.Collectable.Quantity + ' </span> <span class="' + classes.Progress.Percentage + '"> ' + percentage + " </span>");
                }
            }));
            _updateCollectableProgressBar();
        };
        var _updateCollectableProgressBar = function() {
            elements.Collectable.Progress.animate(states.Collectable.Progress);
        };
        var _setupIngredientActions = function(data, $div) {
            _setupIngredientProgressBar();
            $("." + classes.DeadCheckbox, $div).each(function() {
                if ($("input", $(this)).prop(property.Checked)) $(this).addClass(classes.Flag.Checked);
                $(this).on(events.Click, function(e) {
                    log("Clicked checkbox!");
                    e.preventDefault();
                });
            });
            $("input", $("." + classes.DeadCheckbox, $div)).on(events.Change, function(e) {
                if ($(this).prop(property.Checked)) $(this).parent().addClass(classes.Flag.Checked); else $(this).parent().removeClass(classes.Flag.Checked);
            });
            $("." + classes.Collectable.Item.Checkbox, $div).on(events.Click, function() {
                var input = $("input", $(this)), checked = input.prop(property.Checked) == true, collectable = input.val(), $source = $("#" + ids.Source.Tabs), $prevCollectable = false;
                if (checked == true) {
                    log("Collectable Item is currently checked...");
                    $("input:" + property.Checked, $(this).parent()).last().prop(property.Checked, "").trigger(events.Change);
                    return;
                }
                log("Collectable not currently checked...");
                $("input", $(this).parent()).not(":" + property.Checked).first().prop(property.Checked, property.Checked).trigger(events.Change);
            });
            $("." + classes.Collectable.Item.Input, $div).on(events.Change, function() {
                var collectable = $(this).val(), $source = $("#" + ids.Source.Tabs), currentCraftable = false;
                _activateUpdatingFlag();
                clicked = {
                    collectable: collectable
                };
                data = $.extend(data, clicked);
                var remainingIngredients = getRemaining($(this).parent());
                updateRemaining($(this).parent(), remainingIngredients);
                if (!$source.length) {
                    error("No source found!");
                    return;
                }
                if ($(this).prop(property.Checked) == undefined || $(this).prop(property.Checked) == "") {
                    states.Collectable.Collected = states.Collectable.Collected - 1;
                    _collectCollectable(data);
                    $craftableCollectables = $("." + classes.Craftable.Collectable.Input + "[data-collectable=" + collectable + "]:not(." + classes.Flag.Available + ")", $source);
                    if (!$craftableCollectables) {
                        error("No matching Craftable Collectable inputs found!");
                        return;
                    }
                    $($craftableCollectables.get().reverse()).each(function() {
                        var craftable = $(this).data("craftable");
                        if (craftable == currentCraftable) return;
                        log("Making last available Collectable " + collectable + " 'unavailable' of Craftable " + craftable);
                        $(this).parent().removeClass(classes.Flag.Available);
                        currentCraftable = craftable;
                    });
                    return;
                }
                states.Collectable.Collected = states.Collectable.Collected + 1;
                _collectCollectable(data);
                $craftableCollectables = $("." + classes.Craftable.Collectable.Input + "[data-collectable=" + collectable + "]", $source).not("." + classes.Flag.Available);
                if (!$craftableCollectables) {
                    error("No matching Craftable Collectable inputs found!");
                    return;
                }
                $craftableCollectables.each(function() {
                    var craftable = $(this).data("craftable");
                    if (craftable == currentCraftable) return;
                    log("Making first unavailable Collectable " + collectable + " 'available' of Craftable " + craftable);
                    $(this).parent().addClass(classes.Flag.Available);
                    currentCraftable = craftable;
                });
            });
            setupTabs($div);
        };
        var collectNextAvailable = function(collectable) {
            log("Attempt to collect next available Collectable");
            if (!collectable) {
                error("No collectable ID passed!");
                return false;
            }
            log("Collecting next available Collectable ID: " + collectable);
            var $next = $("input." + classes.Collectable.Item.Input + "[value=" + collectable + "]").not(":" + property.Checked).first();
            if (!$next.length) {
                error("Could not get next unchecked collectable!");
                return false;
            }
            $next.prop(property.Checked, property.Checked).trigger(events.Change);
            $next.parent().addClass(classes.Flag.Disabled);
        };
        var disableNextCollectable = function(collectable) {
            log("Disable Next Collected Collectable");
            if (!collectable) {
                error("No Collectable ID passed!");
                return false;
            }
            log("Disabling next collected Collectable ID: " + collectable);
            var $next = $("." + classes.Collectable.Item.Input + ":" + property.Checked + "[value=" + collectable + "]").not(":" + property.Disabled).first();
            if (!$next.length) {
                error("Could not get next collected Collectable!");
                return false;
            }
            $next.prop(property.Disabled, property.Disabled);
            $next.parent().addClass(classes.Flag.Disabled);
        };
        var undisableLastCollectable = function(collectable) {
            log("Undisable Last Collected Collectable");
            if (!collectable) {
                error("No collectable ID passed!");
                return false;
            }
            log("Undisabling last collected Collectable ID: " + collectable);
            var $last = $("." + classes.Collectable.Item.Input + ":" + property.Disabled + "[value=" + collectable + "]").last();
            if (!$last.length) {
                error("Could not get last disabled Collectable!");
                return false;
            }
            $last.removeAttr(property.Disabled);
            $last.parent().removeClass(classes.Flag.Disabled);
        };
        var updateRemaining = function($el, remaining) {
            if (!$el || remaining == null) {
                error("No element or remaining");
                return;
            }
            var $details = $el.closest("details"), $remainingAmountSpan = $("." + classes.Name.Remaining, $details);
            if (!$remainingAmountSpan.length) {
                error("Cannot find ." + classes.Name.Remaining + " span!");
                return;
            }
            if (!remaining || remaining < 1) $details.addClass(classes.Flag.Disabled); else $details.removeClass(classes.Flag.Disabled);
            $remainingAmountSpan.html(remaining);
        };
        var getRemaining = function($el) {
            if (!$el) return;
            var $details = $el.closest("details");
            return $("input", $details).not(":" + property.Checked).length;
        };
        plugin.update = function(data) {
            _updateCraftable(data);
            return;
        };
        var _updateCraftable = function(data) {
            if (typeof data.craftable == "undefined" || !data.craftable) {
                error("No Craftable ID passed!");
                _deactivateUpdatingFlag();
                return false;
            }
            _updateCraftableProgressBar();
            var craftable = data.craftable, game_id = $("#" + ids.Game).val(), craftableCurrent = player_game_crafted.length ? player_game_crafted.filter(function(obj) {
                return obj.Craftable == craftable;
            }) : false, ajaxActions = {
                update: actions.Update.Crafted,
                insert: actions.Insert.Crafted
            }, intervalKey = "craftable" + craftable;
            if (typeof states.Interval.Update[intervalKey] !== "undefined" && states.Interval.Update[intervalKey] !== false) clearInterval(states.Interval.Update[intervalKey]);
            var action = "insert";
            if (craftableCurrent.length) var action = "update";
            extra = {
                _ajax_craftables_nonce: $("#" + ids.Craftable.Nonce).val(),
                action: ajaxActions[action],
                game_id: game_id
            };
            data = $.extend(data, extra);
            log(data, false);
            states.Interval.Update[intervalKey] = setTimeout(function() {
                log(action == "update" ? content.Label.Updating : content.Label.Inserting);
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: data,
                    success: function(response) {
                        _deactivateUpdatingFlag();
                        log("Craftable " + craftable + " " + (action == "update" ? content.Label.Updated : content.Label.Inserted));
                        var updatedLocally = false;
                        $.each(player_game_crafted, function() {
                            if (this.Craftable === data.craftable) {
                                this.Acquired = data.acquired;
                                updatedLocally = true;
                                return;
                            }
                        });
                        if (updatedLocally == false && player_game_crafted !== false) {
                            player_game_crafted.push({
                                Craftable: data.craftable,
                                Acquired: data.acquired
                            });
                        }
                    },
                    error: function(response) {
                        _deactivateUpdatingFlag();
                        error("Error " + (action == "update" ? content.Label.Updating : content.Label.Inserting));
                        error(response, false);
                    }
                });
            }, plugin.settings.delay.Long);
        };
        var _submitCollectable = function(data) {
            log("Submitting Collectable");
            if (typeof data.collectable == "undefined" || !data.collectable) {
                error("No Collectable ID received!");
                _deactivateUpdatingFlag();
                return false;
            }
            var collectable = data.collectable, checked = $("." + classes.Craftable.Collectable.Input + "[value=" + collectable + "]:" + property.Checked), quantity = checked.length, game_id = $("#" + ids.Game).val(), submittedCurrent = player_game_submitted.filter(function(obj) {
                return obj.CraftableCollectable == collectable;
            })[0], ajaxActions = {
                update: actions.Update.Submitted,
                insert: actions.Insert.Submitted
            }, intervalKey = "submit" + collectable;
            if (typeof states.Interval.Update[intervalKey] !== "undefined" && states.Interval.Update[intervalKey] !== false && states.Interval.Update[intervalKey] !== null) clearInterval(states.Interval.Update[intervalKey]);
            if (!submittedCurrent) {
                var action = "insert";
            } else {
                var action = "update";
                if (submittedCurrent.Quantity == quantity) {
                    log("No change to Item Collectable! Cancelling update.");
                    _deactivateUpdatingFlag();
                    return false;
                }
            }
            var data = {
                _ajax_submitted_nonce: $("#" + ids.Submitted.Nonce).val(),
                action: ajaxActions[action],
                collectable: collectable,
                quantity: quantity,
                game_id: game_id
            };
            log(data, false);
            states.Interval.Update[intervalKey] = setTimeout(function() {
                log(action == "update" ? content.Label.Updating : content.Label.Inserting);
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: data,
                    success: function(response) {
                        var updatedLocally = false;
                        var collectable = data.collectable;
                        $.each(player_game_submitted, function() {
                            if (this.CraftableCollectable == collectable) {
                                this.Quantity = data.quantity;
                                updatedLocally = true;
                            }
                        });
                        if (updatedLocally == false) player_game_submitted.push({
                            CraftableCollectable: collectable,
                            Quantity: data.quantity
                        });
                        _deactivateUpdatingFlag();
                        log("Craftable Collectable " + collectable + " " + (action == "update" ? content.Label.Updated : content.Label.Inserted));
                    },
                    error: function(response) {
                        _deactivateUpdatingFlag();
                        error("Error " + (action == "update" ? content.Label.Updating : content.Label.Inserting) + " Item Collectable " + collectable + "!");
                        error(response, false);
                    }
                });
            }, plugin.settings.delay.Long);
        };
        var _collectCollectable = function(data) {
            if (typeof data.collectable == "undefined" || !data.collectable) {
                error("No collectable passed!");
                _deactivateUpdatingFlag();
                return false;
            }
            _updateCollectableProgressBar();
            var collectable = data.collectable, checkedSelector = "." + classes.Collectable.Item.Input + "[value=" + collectable + "]:" + property.Checked, checked = $(checkedSelector), quantity = checked.length, game_id = $("#" + ids.Game).val(), collectableCurrent = player_game_collected.filter(function(obj) {
                return obj.Collectable == collectable;
            }), ajaxActions = {
                update: actions.Update.Collected,
                insert: actions.Insert.Collected
            }, intervalKey = "collect" + collectable;
            if (typeof states.Interval.Update[intervalKey] !== "undefined" && states.Interval.Update[intervalKey] !== false) clearInterval(states.Interval.Update[intervalKey]);
            if (!collectableCurrent.length) var action = "insert"; else {
                var action = "update";
                if (collectableCurrent[0].Collected == quantity) {
                    log("No change! Cancelling update.");
                    _deactivateUpdatingFlag();
                    return false;
                }
            }
            var data = {
                _ajax_collected_nonce: $("#" + ids.Collected.Nonce).val(),
                action: ajaxActions[action],
                collectable: collectable,
                quantity: quantity,
                game_id: game_id
            };
            log(data, false);
            states.Interval.Update[intervalKey] = setTimeout(function() {
                log(action == "update" ? content.Label.Updating : content.Label.Inserting);
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: data,
                    success: function(response) {
                        var collectable = data.collectable, updatedLocally = false;
                        $.each(player_game_collected, function() {
                            if (this.Collectable == collectable) {
                                this.Collected = data.quantity;
                                updatedLocally = true;
                            }
                        });
                        if (updatedLocally == false) {
                            log("Adding Collectable and Quantity to Player Game Collected tally...");
                            player_game_collected.push({
                                Collectable: collectable,
                                Collected: data.quantity
                            });
                            updatedLocally = true;
                        }
                        if (updatedLocally == false) log("Updated Locally is STILL false...");
                        _deactivateUpdatingFlag();
                        log("Collectable " + collectable + " collected!");
                    },
                    error: function(response) {
                        _deactivateUpdatingFlag();
                        error("Error " + (action == "update" ? "updating!" : "inserting!"));
                        error(response, false);
                    }
                });
            }, plugin.settings.delay.Long);
        };
        var _updateFilter = function(data) {
            log("Updating filters... ");
            if (typeof data.filter == "undefined") {
                error("No filter value passed!");
                _deactivateUpdatingFlag();
                return false;
            }
            var filter = !data.filter ? "0" : data.filter, player_id = $("#" + ids.Player).val(), ajaxActions = {
                update: actions.Update.Collected,
                insert: actions.Insert.Collected
            }, intervalKey = "filter" + player_id;
            if (typeof states.Interval.Update[intervalKey] !== "undefined" && states.Interval.Update[intervalKey] !== false) clearInterval(states.Interval.Update[intervalKey]);
            var data = {
                _ajax_filters_nonce: $("#" + ids.Filters.Nonce).val(),
                action: actions.Update.Filter,
                player_id: player_id,
                filter: filter
            };
            states.Interval.Update[intervalKey] = setTimeout(function() {
                log(content.Label.Updating);
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: data,
                    success: function(response) {
                        _deactivateUpdatingFlag();
                        log(content.Label.Updated);
                    },
                    error: function(response) {
                        _deactivateUpdatingFlag();
                        error("Error " + content.Label.Updating);
                        error(response, false);
                    }
                });
            }, plugin.settings.delay.Long);
        };
        var getDistinct = function(array, key, value) {
            if (!array || !key || !value) return false;
            var result = [], map = new Map();
            for (var i = 0; i < array.length; i++) {
                if (map.has(array[i].key)) continue;
                map.set(array[i].key, true);
                result.push({
                    ID: array[i].key,
                    Ingredient: array[i].value
                });
            }
            return result ? result : false;
        };
        var check = function(element) {
            if (typeof element == "undefined" || !element) return false;
            if (element.prop(property.Checked)) return;
            element.prop(property.Checked, property.Checked).trigger(events.Change);
        };
        var uncheck = function(element) {
            if (typeof element == "undefined" || !element) return false;
            if (element.prop(property.Checked) == "") return;
            element.removeAttr(property.Checked).trigger(events.Change);
        };
        var sumColumn = function sumColumn(array, col) {
            if (!array || !col) return false;
            var sum = 0;
            array.forEach(function(value, index, array) {
                sum += parseInt(value[col]);
            });
            return sum;
        };
        var merge = function(objects) {
            var out = {};
            for (var i = 0; i < objects.length; i++) {
                for (var p in objects[i]) {
                    out[p] = objects[i][p];
                }
            }
            return out;
        };
        var flatten = function(obj, name, stem) {
            var out = {}, newStem = name;
            if (typeof obj !== "object") {
                out[newStem] = obj;
                return out;
            }
            for (var p in obj) {
                var prop = flatten(obj[p], p, newStem);
                out = merge([ out, prop ]);
            }
            return out;
        };
        var query = function(query, variable) {
            var vars = query.split("&");
            for (var i = 0; i < vars.length; i++) {
                var pair = vars[i].split("=");
                if (pair[0] == variable) return pair[1];
            }
            return false;
        };
        var toggleUpdatingFlag = function() {
            elements.Flag.Updating.toggleClass(classes.Flag.Top);
            elements.Flag.Updating.toggleClass(classes.Flag.Show);
        };
        var _activateUpdatingFlag = function() {
            elements.Flag.Updating.addClass(classes.Flag.Top);
            elements.Flag.Updating.addClass(classes.Flag.Show);
        };
        var _deactivateUpdatingFlag = function() {
            elements.Flag.Updating.removeClass(classes.Flag.Show);
            setTimeout(function() {
                elements.Flag.Updating.removeClass(classes.Flag.Top);
            }, 300);
        };
        var setupTabs = function(tabElement) {
            if (!tabElement.length) return;
            var $element = tabElement;
            if (!$(" > ul > li:first-child", $element).length) {
                error("REALLY Cannot find the appropriate children for tabs!");
                error($element, false);
            }
            $element.easytabs($.extend({}, plugin.settings.EasyTabs, {}));
        };
        var setupDetailSummary = function() {
            if (!$("details").length) return false;
            $("details").details();
            $("html").addClass($.fn.details.support ? "details" : "no-details");
            $(document).on(events.Key.Up + " " + events.Click, "summary", function(e) {
                $(window).trigger(events.Resize).trigger("scroll");
            });
        };
        var setupDialogs = function() {
            if (typeof jconfirm == "undefined") {
                error("No jconfirm plugin found!");
                return false;
            }
            jconfirm.defaults = plugin.settings.DialogBoxes;
        };
        var confirmBox = function(title, question) {
            if (!question) return false;
            title = title || "";
            return $.confirm(question, title);
        };
        var getFields = function(input, field) {
            var output = [];
            for (var i = 0; i < input.length; i++) output.push(input[i][field]);
            return output;
        };
        var capitalize = function(s) {
            if (typeof s !== "string") return "";
            return s.charAt(0).toUpperCase() + s.slice(1);
        };
        var postpone = function(func) {
            if (typeof func !== "function") return false;
            window.setTimeout(func, 0);
        };
        var log = function(text, showPrefix) {
            if (logging !== true) return;
            var message = showPrefix == false ? text : logPrefix + ": " + text;
            console.log(message);
        };
        var error = function(text, showPrefix) {
            if (logging !== true) return;
            var message = showPrefix == false ? text : logPrefix + ": " + text;
            console.error(message);
        };
        plugin.publicMethods = {};
        plugin.init();
    };
    $.fn.tracky = function(options) {
        var args = arguments;
        return this.each(function() {
            var $this = $(this), plugin = $this.data("tracky");
            if (undefined === plugin) {
                plugin = new $.tracky(this, options);
                $this.data("tracky", plugin);
            }
            if (plugin.publicMethods[options]) return plugin.publicMethods[options](Array.prototype.slice.call(args, 1));
            return;
        });
    };
})(jQuery);

(function($) {
    $.tippy = function(container, options) {
        var plugin = this, $container = $(container);
        var tipRecord = [];
        var defaults = {
            delay: 300,
            action: "_ajax_fetch_tips"
        };
        var classes = {
            updating: "updating",
            section: "app-section"
        };
        var ids = {
            nonce: "_ajax_tip_nonce"
        };
        plugin.init = function() {
            plugin.settings = settings = $.extend({}, defaults, options);
            $container.data("tippy", {});
            $container.addClass(classes.updating);
            $container.html('<div class="' + classes.section + '"> </div>');
            $section = $("." + classes.section, $container);
            var data = {
                game_id: 1
            };
            $.ajax({
                url: ajaxurl,
                dataType: "json",
                contentType: "application/json",
                data: $.extend({
                    _ajax_tip_nonce: $("#" + ids.nonce).val(),
                    action: plugin.settings.action
                }, data),
                success: function(response) {
                    plugin.update(response);
                    $container.on("click", function() {
                        $container.addClass(classes.updating);
                        plugin.update(response);
                    });
                },
                error: function(response) {
                    console.error(response);
                    $container.removeClass(classes.updating);
                }
            });
        };
        plugin.update = function(response) {
            setTimeout(function() {
                var responseNumber = getRandomTipNumber(response);
                tipRecord.push(responseNumber);
                $section.html("<p>" + response[responseNumber].Description + "</p>");
                $container.removeClass(classes.updating);
            }, plugin.settings.delay);
        };
        plugin.publicMethods = {};
        var getRandomTipNumber = function(tips) {
            if (!tips.length) return false;
            var newTipNumber = getRandomNumber(tips.length);
            if (tipRecord.length) {
                halfTipLength = tips.length / 2;
                limitStart = tipRecord.length > halfTipLength ? tipRecord.length - halfTipLength : 0;
                if (tipRecord.slice(limitStart, tipRecord.length).indexOf(newTipNumber) !== -1) newTipNumber = getRandomTipNumber(tips);
            }
            return newTipNumber;
        };
        var getRandomNumber = function(limit) {
            return Math.floor(Math.random() * limit);
        };
        var query = function(query, variable) {
            var vars = query.split("&");
            for (var i = 0; i < vars.length; i++) {
                var pair = vars[i].split("=");
                if (pair[0] == variable) return pair[1];
            }
            return false;
        };
        plugin.init();
    };
    $.fn.tippy = function(options) {
        var args = arguments;
        return this.each(function() {
            var $this = $(this), plugin = $this.data("tippy");
            if (undefined === plugin) {
                plugin = new $.tippy(this, options);
                $this.data("tippy", plugin);
            }
            if (plugin.publicMethods[options]) return plugin.publicMethods[options](Array.prototype.slice.call(args, 1));
        });
    };
})(jQuery);

jQuery(document).ready(function($) {
    var $PortalContainer = $("#PlayerPortal"), $RandomTip = $("#RandomTip"), $tabsContainer = $(".luckytabs");
    $("html").removeClass("no-js");
    if ($RandomTip.length) $RandomTip.tippy();
    if ($PortalContainer.length) $PortalContainer.tracky();
});